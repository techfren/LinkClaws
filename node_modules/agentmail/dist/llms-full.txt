# Welcome

> Your starting point for building with the AgentMail API.

<Tip title="Welcome to AgentMail!" icon="fa-solid fa-star">
  We're thrilled to have you here! Dive in to learn how to give your AI agents their own email inboxes.
</Tip>

<Frame caption="We're excited to have you onboard!">
  <img src="https://files.buildwithfern.com/https://agentmail-production.docs.buildwithfern.com/9594f1f7c411d8f6e6a3d1e6de0661b1c8b82a57d29de765f0f90dc9da66149b/assets/doc-intro.png" alt="We're excited to have you onboard!" />
</Frame>

AgentMail is an API platform for giving AI agents their own inboxes to send, receive, and act upon emails. This allows agents to assume their own identity and communicate via the universal protocol of email with services, people, and other agents.

## Get Started

<CardGroup>
  <Card title="Introduction" icon="fa-solid fa-rocket" href="/introduction">
    Learn about the core concepts and what makes AgentMail unique.
  </Card>

  <Card title="Quickstart" icon="fa-solid fa-book" href="/quickstart">
    Create your first inbox and send an email in minutes.
  </Card>

  <Card title="API Reference" icon="fa-solid fa-code" href="/api-reference">
    Explore the full API with interactive examples.
  </Card>
</CardGroup>

## Need Help?

<CardGroup>
  <Card title="Join our Discord" icon="fa-brands fa-discord" href="https://discord.gg/hTYatWYWBc">
    Ask questions and share your projects with the community.
  </Card>

  <Card title="Email Support" icon="fa-solid fa-envelope" href="mailto:support@agentmail.cc">
    Get in touch with our team for personalized help.
  </Card>
</CardGroup>


# Introduction

> Give AI agents email inboxes

## What is AgentMail?

AgentMail is an API platform for giving AI agents their own inboxes to send, receive, and act upon emails. We handle the infrastructure so you can focus on building email agents.

**Email agents** can:

* Have conversations with users in their inboxes
* Automate email-based workflows for enterprises
* Authenticate with third party applications
* Act as first-class users on the internet

## The Problem with Traditional Email

Existing email infrastructure was built for humans. Legacy providers such as Gmail and Outlook have several limitations for agentic use cases:

<CardGroup>
  <Card title="No API for Inboxes" icon="fa-solid fa-link-slash">
    Legacy providers lack API support for creating new inboxes on-demand.
  </Card>

  <Card title="Per-Inbox Pricing" icon="fa-solid fa-dollar-sign">
    They charge monthly subscriptions per inbox(\$12/inbox/month !!), which is
    costly for agents.
  </Card>

  <Card title="Restrictive Limits" icon="fa-solid fa-ban">
    They impose restrictive rate and sending limits not suitable for automation.
  </Card>

  <Card title="Poor DX" icon="fa-solid fa-face-frown">
    Overall, they offer a poor developer experience for building on top of
    email. The Gmail API sucks!
  </Card>
</CardGroup>

## The Solution

AgentMail is an API-first email provider that is designed for agents. Think of it like Gmail, but with:

<Steps>
  <Step title="API-First Infrastructure">
    <Callout icon="fa-solid fa-laptop-code">
      **Programmatic Inboxes**: Create and manage inboxes via API.
    </Callout>

    <Callout icon="fa-solid fa-money-bill-wave">
      **Usage-Based Pricing**: Pay only for what you use.
    </Callout>

    <Callout icon="fa-solid fa-unlock">
      **High-Volume Ready**: No restrictive rate or sending limits.
    </Callout>

    <Callout icon="fa-solid fa-bolt">
      **Real-Time Events**: Get notified instantly with webhooks and websockets.
    </Callout>

    <Callout icon="fa-solid fa-key">
      **Simple Authentication**: Use API keys, no complex OAuth flows.
    </Callout>
  </Step>

  <Step title="AI-Native Features">
    <Callout icon="fa-solid fa-shield-halved">
      **Built-in Security**: Use API permissions and agent guardrails to control
      access.
    </Callout>

    <Callout icon="fa-solid fa-magnifying-glass">
      **Semantic Search**: Search across all inboxes in your organization by
      meaning.
    </Callout>

    <Callout icon="fa-solid fa-tags">
      **Automatic Labeling**: Automatically categorize emails with user-defined
      prompts.
    </Callout>

    <Callout icon="fa-solid fa-file-invoice">
      **Structured Data Extraction**: Pull structured data from unstructured
      emails.
    </Callout>

    <Callout icon="fa-solid fa-ellipsis-h">
      And more on the way...
    </Callout>
  </Step>
</Steps>

Our customers use AgentMail for agent identity, authentication, and communication. To get started make an account on our [console](https://console.agentmail.to) and please email [support@agentmail.cc](mailto:support@agentmail.cc) if you run into any issues.

<iframe width="560" height="315" src="https://www.youtube.com/embed/1V7BISeFUTM?si=4asiGnuV4O81nu5B" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen />

## Get Started

<CardGroup>
  <Card title="Quickstart" icon="fa-solid fa-book" href="/quickstart" />

  <Card title="API Reference" icon="fa-solid fa-code" href="/api-reference" />
</CardGroup>

## Support

<CardGroup>
  <Card title="Discord" icon="brands discord" href="https://discord.gg/hTYatWYWBc" />

  <Card title="Email" icon="fa-solid fa-envelope" href="mailto:support@agentmail.cc" />
</CardGroup>


# Quickstart

> Follow this guide to make your first AgentMail API request and create a new email inbox.

This guide will walk you through installing the AgentMail SDK, authenticating with your API key, and creating your first email inbox.

<Steps>
  <Step title="Access the AgentMail Console">
    First, you'll need to access the AgentMail Console to manage your account and API keys. Click the link below to get started.

    <Card title="Open AgentMail Console" icon="fa-solid fa-desktop" href="https://console.agentmail.to" target="_blank" />

    If you don't have an account yet, you can sign up directly from the console. Once you're logged in, you'll be able to manage your inboxes, view analytics, and create API keys.
  </Step>

  <Step title="Create an API Key">
    Now that you're in the console, you'll need to create an API key to
    authenticate your requests. Navigate to the API Keys section in your console
    dashboard. ![API Key Creation Screenshot](https://files.buildwithfern.com/https://agentmail-production.docs.buildwithfern.com/4e665f546efdf08d30178fcfbd996298ed7b3d1d44709fc742ed5315fed9532e/assets/api-key-creation.png) Click
    "Create New API Key" and give it a descriptive name. Once created, copy the
    API key and store it securely. Create a `.env` file in your project's root
    directory and add your key to it. We recommend using environment variables to
    keep your keys secure.
  </Step>

  <Step title="Install the SDK">
    Install the AgentMail SDK using your preferred package manager. We'll also
    use a library to load the environment variable from the `.env` file.

    <CodeBlocks>
      ```bash title="Python"
      pip install agentmail python-dotenv
      ```

      ```bash title="Node"
      npm install agentmail dotenv
      ```
    </CodeBlocks>
  </Step>

  <Step title="Create an inbox and send an email">
    Now you're ready to make your first API call. Create a new file (e.g.,
    `quickstart.py` or `quickstart.ts`) and add the following code. This script
    will initialize the AgentMail client, create a new inbox, and then send a
    test email.

    <CodeBlocks>
      ```python title="Python"
      import os
      from dotenv import load_dotenv
      from agentmail import AgentMail

      # Load the API key from the .env file
      load_dotenv()
      api_key = os.getenv("AGENTMAIL_API_KEY")

      # Initialize the client
      client = AgentMail(api_key=api_key)

      # Create an inbox
      print("Creating inbox...")
      inbox = client.inboxes.create() # domain is optional
      print("Inbox created successfully!")
      print(inbox)

      # Send Email

      client.inboxes.messages.send(
      inbox_id="your-email@example.com",
      to="contact@agentmail.to",
      subject="Hello from AgentMail!",
      text="This is my first email sent with the AgentMail API."

      )

      ```

      ```typescript title="TypeScript"
      import { AgentMailClient } from "agentmail";
      import "dotenv/config"; // loads .env file

      async function main() {
        // Initialize the client
        const client = new AgentMailClient({
          apiKey: process.env.AGENTMAIL_API_KEY,
        });

        // Create an inbox
        console.log("Creating inbox...");
        const inbox = await client.inboxes.create(); // domain is optional
        console.log("Inbox created successfully!");
        console.log(inbox);

        // Send an email from the new inbox
        console.log("Sending email...");
        await client.inboxes.messages.send(inbox.inboxId, {
          to: "your-email@example.com",
          subject: "Hello from AgentMail!",
          text: "This is my first email sent with the AgentMail API.",
        });
        console.log("Email sent successfully!");
      }

      main();
      ```
    </CodeBlocks>

    <Note>
      The `domain` parameter is optional. If not provided, AgentMail will
      use the default `@agentmail.to` domain. If you would like a custom domain, please <a href="https://agentmail.to/pricing" target="_blank" rel="noopener noreferrer">upgrade to a paid plan</a>.
    </Note>
  </Step>

  <Step title="Run the code">
    Execute the script from your terminal.

    <CodeBlocks>
      ```bash title="Python"
      python quickstart.py
      ```

      ```bash title="TypeScript"
      npx ts-node quickstart.ts
      ```
    </CodeBlocks>

    You should see the details of your newly created inbox printed to the
    console. Congratulations, you've successfully created your first AgentMail
    inbox!
  </Step>
</Steps>

## Next Steps

Congrats, you sent your first email via AgentMail. But this isn't our strength. Explore the full power of creating agents that can autonomously reply, take action, parse attachments, semantically search your inbox, by exploring our docs and tutorials below.

<Note>
  Looking for a different language? Email us at
  [support@agentmail.cc](mailto:support@agentmail.cc) and we'll get you set up.
</Note>


# Inboxes

> Learn how AgentMail Inboxes act as scalable, API-first email accounts for your agents.

## What is an Inbox?

People are used to the traditional Gmail limitations -- only having one inbox. That's of the past.

An `Inbox` is now a fully loaded, programmatically accessible API resource re-designed for the scale of AI Agents.

Think of it as being similar to a Gmail or Outlook account, but built API-first. Each `Inbox` has a unique email address and serves as the primary resource your agent uses to send and receive emails, giving it a first-class identity on the internet.

Unlike traditional email providers that are designed for human scale, AgentMail `Inboxes` are built to scale horizontally. You can create tens, hundreds, or even thousands of `Inboxes` for your agents on demand.

<Tip>
  Psst! Rather than sending 1000 emails from 1 `Inbox`, sending 10 emails
  across 100 `Inboxes` actually improves deliverability! Read more about
  optimizing for deliverability [here](/best-practices/email-deliverability)
</Tip>

### The AgentMail Hierarchy

As the diagram below illustrates, your `organization` is the top-level container that holds all your resources. You can provision many `Inboxes` within your `organization`, each with its own `Threads`, `Messages`, and `Attachments`, allowing you to manage a large fleet of agents seamlessly.

<img src="https://files.buildwithfern.com/https://agentmail-production.docs.buildwithfern.com/800085ec8545f404e194c8c6e463be1677715204ac5705be777fa95ace0e6d26/assets/hierarchy-diagram.png" alt="AgentMail Organizational Hierarchy" />

<Steps>
  <Step title="Organization">
    Your `organization` is the highest-level entity. It acts as a container for
    all your `Inboxes`, `Domains`, and API keys, allowing you to manage
    everything in one place.
  </Step>

  <Step title="Inbox">
    An `Inbox` is a single, scalable "email account" for your agent. You can
    create thousands of `Inboxes` within your organization, each with its own
    unique email address.
  </Step>

  <Step title="Thread">
    A `Thread` represents a single conversation. It groups together all replies
    and forwards related to an initial email, keeping your interactions
    organized.
  </Step>

  <Step title="Message">
    A `Message` is an individual email. It contains the content, sender,
    recipients, and any associated metadata or `Attachments`. You can cc humans
    at any point in time to keep a "human-in-the-loop"
  </Step>

  <Step title="Attachment">
    An `Attachment` is a file that is sent along with a `Message`. You can
    programmatically access and download attachments from incoming `Messages`.
  </Step>
</Steps>

## Core Capabilities

Here at AgentMail we've now made an `Inbox` an API resource, meaning you can perform standard CRUD operations on it. Here are the core capabilities you'll use to manage your `Inboxes`.

<CodeBlocks>
  ```python
  from agentmail import AgentMail

  # Initialize the client
  client = AgentMail(api_key="YOUR_API_KEY")

  # --- Create an Inbox ---
  # Creates a new inbox with a default agentmail.to domain
  new_inbox = client.inboxes.create()
  print(f"Created Inbox: {new_inbox.inbox_id}")

  # --- Retrieve an Inbox ---
  # Gets a specific inbox by its ID
  retrieved_inbox = client.inboxes.get(inbox_id = 'my_name@domain.com')
  print(f"Retrieved Inbox: {retrieved_inbox.inbox_id}")

  # --- List Inboxes ---
  # Lists all inboxes in your organization
  all_inboxes = client.inboxes.list()

  print(f"Total Inboxes: {all_inboxes.count}")

  ```

  ```typescript title="TypeScript"
  import { AgentMailClient } from "agentmail";

  // Initialize the client
  const client = new AgentMailClient({ apiKey: "YOUR_API_KEY" });

  // --- Create an Inbox ---
  // Creates a new inbox with a default agentmail.to domain
  const newInbox = await client.inboxes.create({
    username: "docs-testing",
    domain: "domain.com",
    displayName: "Docs Tester",
  });
  console.log(`Created Inbox: ${newInbox.id}`);

  // --- Retrieve an Inbox ---
  // Gets a specific inbox by its ID
  const inboxId = newInbox.id;
  const retrievedInbox = await client.inboxes.get(inboxId);
  console.log(`Retrieved Inbox: ${retrievedInbox.inbox_id}`);

  // --- List Inboxes ---
  // Lists all inboxes in your organization
  const allInboxes = await client.inboxes.list();
  console.log(`Total Inboxes: ${allInboxes.count}`);



  ```
</CodeBlocks>

<Tip>
  When creating an `Inbox`, the `username` and `domain` are optional. If you
  don't provide them, AgentMail will generate a unique address for you using our
  default domain. Check out our [guide on managing
  domains](/guides/domains/managing-domains) to learn more.
</Tip>


# Messages

> Learn how to send, receive, and manage emails as Message objects with the AgentMail API.

## What is a Message?

In the AgentMail ecosystem, a `Message` is the API-first representation of a traditional email. It's a structured object containing all the elements you'd expect: a sender, recipients, a subject line, and the body of the email.

Every `Message` lives inside a `Thread` to keep conversations organized. When you send a new `Message`, a new `Thread` is created. When you reply, the new `Message` is added to the existing `Thread`. Literally a normal email thread as we know it.

One of the powerful features of AgentMail is the ability to seamlessly include humans in agent-driven conversations. You can `cc` or `bcc` a real person on any message your agent sends, creating a "human-in-the-loop" workflow for oversight, escalations, or quality assurance.

## Core Capabilities

You can interact with `Message` resources in several ways, from sending new `Messages` to listing a history of correspondence.

### 1. Initialize the Client

First, you need to initialize the AgentMail client with your API key. This client object is your gateway to interacting with the AgentMail API.

<CodeBlocks>
  ```python title="Python"
  from agentmail import AgentMail

  client = AgentMail(api_key="YOUR_API_KEY")

  ```

  ```typescript title="TypeScript"
  import { AgentMailClient } from "agentmail";

  const client = new AgentMailClient({ apiKey: "YOUR_API_KEY" });
  ```
</CodeBlocks>

### 2. Send a New `Message`

To start a new conversation, you can send a `Message` from one of your inboxes. This action will create a new `Thread` and return the `Message` object.

<CodeBlocks>
  ```python
  # You'll need an inbox ID to send from.
  # Let's assume we have one:

  sent_message = client.inboxes.messages.send(
  inbox_id = 'my_inbox@domain.com',
  to = 'recipient@domain.com',
  labels=[
  "outreach",
  "startup"
  ],
  subject="[YC S25] Founder Reachout ",
  text="Hello, I'm Michael, and I'm a founder at AgentMail...",
  html="<div dir=\"ltr\">Hello,<br /><br />I'm Michael, and I'm a founder at AgentMail..."
  )
  print(f"Message sent successfully with ID: {sent_message.message_id}")

  ```

  ```typescript title="TypeScript"
  // You'll need an inbox ID to send from.

  const sentMessage = await client.inboxes.messages.send(
  	"outreach@agentmail.to", // this is your inbox you are trying to send from
  	{
      to: "recipient@domain.com",
  		labels: [
  				"outreach",
  				"startup"
  		],
  		subject: "[YC S25] Founder Reachout ",
  		text: "Hello, I'm Michael, and I'm a founder at AgentMail...",
  		html: "<div dir=\"ltr\">Hello,<br /><br />I'm Michael, and I'm a founder at AgentMail..."
  	}
  )

  console.log(`Message sent successfully with ID: ${sentMessage.id}`);
  ```
</CodeBlocks>

### 3. List `Messages` in an `Inbox`

You can retrieve a list of all `Messages` within a specific `Inbox`. This is useful for getting a history of all correspondence.

<CodeBlocks>
  ```python
  all_messages = client.inboxes.messages.list(inbox_id='my_inbox@agentmail.to')

  print(f"Found {all_messages.count} messages in the inbox.")

  ```

  ```typescript title="TypeScript"

  const allMessages = await client.inboxes.messages.list("outreach@agentmail.to")

  console.log(`Found ${allMessages.count} messages in the inbox.`);
  ```
</CodeBlocks>

### 4. Reply to a `Message`

Replying to an existing `Message` adds your new `Message` to the same `Thread`, keeping the conversation organized.

<CodeBlocks>
  ```python
  # Python example
  reply = client.inboxes.messages.reply(
      inbox_id='my_inbox@domain.com'
      message_id='msg_id',
      text="Thanks for the referral!",
      attachments=[
          SendAttachment(
              content="resume" # this would obviously be your resume content, refer to the attachment section of the core-concepts for more details
          )
      ]
  )

  print(f"Reply sent successfully with ID: {reply.message_id}")

  ```

  ```typescript title="TypeScript"


  const reply = await client.inboxes.messages.reply(
  	"my_inbox@domain.com",
  	"msg_id",
  	{
  		text: "Thanks for the referral!",
  		attachments: [
  			{
  				content: "resume"
  			}
  		]
  	}
  )

  console.log(`Reply sent successfully with ID: ${reply.id}`);
  ```
</CodeBlocks>

<Callout>
  Note that the `inbox_id` in reply is different from send, in that this is the
  `inbox_id` we are sending FROM. Remember we can have potentially infinite
  `Inboxes` to send from, so we need to tell the api which one we are sending
  from.
</Callout>

### 5. Get a `Message`

You can retrieve the details of any specific `Message` by providing its ID along with the `inbox_id` it belongs to.

<CodeBlocks>
  ```python title="Python"

  message = client.inboxes.messages.get(inbox_id = 'my_inbox@agentmail.to', message_id = 'msg_id')

  print(f"Retrieved message with subject: {message.subject}")

  ```

  ```typescript title="TypeScript"

  await client.inboxes.messages.get(
  	"my_inbox@domain.com",
  	"msg_id"
  )

  console.log(`Retrieved message with subject: ${message.subject}`);
  ```
</CodeBlocks>

### Crafting Your Message: HTML, Text, and CSS

When sending a `Message`, you can provide the body in two formats: `text` for a plain-text version and `html` for a rich, styled version.

* **`text`**: A simple, unformatted string. This is a fallback for email clients that don't render HTML, ensuring your message is always readable.
* **`html`**: A full HTML document. This allows you to create visually rich emails with custom layouts, colors, fonts, and images.

<Tip>
  **Best Practice**: Always send both `text` and `html` versions.
</Tip>

## "Why both text and HTML?"

Most modern email clients will display the HTML version, not all of them can render HTML -- a text fallback makes sure your message is displayed regardless. Furthermore it significantly improves deliverability.

#### Styling with CSS

To style your HTML in the `Message`, you should embed your CSS directly inside a `<style>` tag in the `<head>` in the payload of the API request. This is the most reliable method for ensuring your styles are applied correctly across different email clients like Gmail, Outlook, and Apple Mail.

Here is an example of a well-structured and styled HTML header:

<CodeBlocks>
  ```html title="Styled HTML Email Example"
  <html>
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Your AgentMail Invoice</title>
      <style>
        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
          line-height: 1.6;
          color: #333;
          max-width: 600px;
          margin: 0 auto;
          padding: 20px;
          background-color: #f8f9fa;
        }
        .email-wrapper {
          background: #ffffff;
          border: 1px solid #e9ecef;
          border-radius: 8px;
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05);
          overflow: hidden;
        }
        .email-header {
          background-color: #000000;
          color: #ffffff;
          padding: 24px;
          text-align: center;
        }
        .email-header h1 {
          margin: 0;
          font-size: 24px;
          font-weight: 600;
        }
        .email-content {
          padding: 32px;
        }
        .greeting {
          font-size: 18px;
          font-weight: 500;
          margin-bottom: 24px;
        }
        .main-message {
          font-size: 16px;
          margin-bottom: 24px;
        }
        .cta-button {
          display: inline-block;
          padding: 12px 24px;
          background-color: #1a73e8;
          color: #ffffff;
          text-decoration: none;
          border-radius: 6px;
          font-weight: 500;
          font-size: 16px;
          margin-top: 8px;
          margin-bottom: 24px;
        }
        .invoice-details {
          background-color: #f8f9fa;
          padding: 16px;
          border-radius: 6px;
          margin-bottom: 24px;
          border: 1px solid #dee2e6;
        }
        .invoice-details p {
          margin: 0;
          font-size: 14px;
        }
        .invoice-details strong {
          color: #000;
        }
        .signature {
          margin-top: 24px;
          font-size: 14px;
          color: #555;
        }
        .email-footer {
          text-align: center;
          padding: 20px;
          font-size: 12px;
          color: #6c757d;
        }
        .email-footer a {
          color: #1a73e8;
          text-decoration: none;
        }
      </style>
    </head>
    <body>
      <div class="email-wrapper">
        <div class="email-header">
          <h1>AgentMail</h1>
        </div>
        <div class="email-content">
          <div class="greeting">Hi there,</div>
          <div class="main-message">
            Your invoice for the period of October 2025 is ready. We've automatically charged your saved payment method. Thank you for your business!
          </div>

          <div class="invoice-details">
            <p><strong>Invoice Number:</strong> INV-2025-10-0123</p>
            <p><strong>Amount:</strong> $49.00</p>
            <p><strong>Status:</strong> Paid</p>
          </div>

          <a href="#" class="cta-button">View Full Invoice</a>

          <div class="signature">
            Best regards,<br />
            The AgentMail Team
          </div>
        </div>
      </div>
      <div class="email-footer">
        <p>&copy; 2025 AgentMail, Inc. All Rights Reserved.</p>
        <p><a href="#">Unsubscribe</a> | <a href="#">Billing Settings</a></p>
      </div>
    </body>
  </html>
  ```
</CodeBlocks>

<Frame caption="Look how pretty this message looks!">
  <img src="https://files.buildwithfern.com/https://agentmail-production.docs.buildwithfern.com/a598fc722b5882421ffb977dc567bd75b4f4541b1e4ff7ab18657c7435b300dc/assets/css-rendered.png" alt="rendered css" />
</Frame>

## Receiving `Messages`

While you can periodically list `Messages` to check for new emails, the most efficient way to handle incoming `Messages` for your agents is with `Webhooks`. By configuring a `Webhook` endpoint, AgentMail can notify your application/agent in real-time as soon as a new `Message` arrives, so you can take action on them.

<CardGroup>
  <Card title="Guide: Webhooks" icon="fa-solid fa-bolt" href="/overview">
    Learn how to set up webhooks for real-time message processing.
  </Card>
</CardGroup>

```
```


# Threads

> Learn how AgentMail Threads group messages into conversations and how to query them across your entire organization.

## What is a Thread?

A `Thread` is an API resource that represents a single conversation. It acts as a container, grouping a series of related `Messages` together in chronological order, just like a conversation thread in a traditional email client.

`Threads` are created automatically. When your agent sends a `Message` that isn't a reply to a previous one, a new `Thread` is initiated. Any subsequent replies are automatically added to this same `Thread`, allowing your agent to easily maintain the context of a conversation over time.

## Querying `Threads`

While `Threads` are created implicitly, you can retrieve them in two powerful ways: scoped to a single `Inbox` or across your entire `Organization`.

### Listing `Threads` per `Inbox`

This is the standard way to retrieve all the conversations associated with a single agent or `Inbox`.

<CodeBlocks>
  ```python title="Python"
  # You'll need an inbox ID to list threads from.
  inbox_id = "inbound-agent@agentmail.to"

  # This retrieves all threads within the specified Inbox

  inbox_threads = client.inboxes.threads.list(inbox_id=inbox_id)

  ```

  ```typescript title="TypeScript"
  // You'll need an inbox ID to list threads from.
  const inboxId = "inbound-agent@agentmail.to";

  // This retrieves all threads within the specified Inbox
  const inboxThreads = await client.inboxes.threads.list("inbound-agent@agentmail.to");

  console.log(`Found ${inboxThreads.count} threads in Inbox ${inboxId}.`);
  ```
</CodeBlocks>

### Listing `Threads` Across an `Organization`

This is one of AgentMail's most powerful features. By omitting the `inbox_id`, you can retrieve a list of `Threads` from **every `Inbox`** in your `Organization`. This org-wide querying capability is essential for building:

* **Supervisor Agents:** An agent that monitors conversations from a fleet of other agents.
* **Analytics Dashboards:** Building something where you need visibility across all inboxes across the organization
* **Advanced Workflows:** Systems that can route or escalate conversations between different agents with different permissions.

<CodeBlocks>
  ```python
  # By not providing an inbox_id, we get all threads in the organization
  all_threads = client.threads.list()

  print(f"Found {all_threads.count} threads across the entire organization.")

  ```

  ```typescript title="TypeScript"
  // By not providing an inboxId, we get all threads in the organization
  const allThreads = await client.threads.list();

  console.log(`Found ${allThreads.count} threads across the entire organization.`);
  ```
</CodeBlocks>

<Callout title="Coming Soon: Org-Wide Semantic Search" intent="info">
  We are actively developing semantic search for the organization-wide thread
  listing endpoint. Soon, you'll be able to find `Threads` based on the meaning
  and concepts within the `Messages`, not just keywords.
</Callout>

### Getting a Single `Thread`

You can also retrieve a single `Thread` by its ID. This will return the `Thread` object, which typically contains a list of all its associated `Messages` and their ID's. A common workflow is listing the messages in a thread and calling the `messages.reply` method on the last one.

<CodeBlocks>
  ```python
  thread_id = "thread_456def"

  # This retrieves a single thread and its messages

  thread = client.threads.get(
  thread_id="thread_id"
  )

  print(f"Retrieved thread {thread.thread_id} with {len(thread.messages)} messages.")

  ```

  ```typescript title="TypeScript"
  const threadId = "thread_456def";

  // This retrieves a single thread and its messages
  const thread = await client.threads.get(
  	"thread_id"
  )

  console.log(`Retrieved thread ${thread.thread_id} with ${thread.messages.length} messages.`);
  ```
</CodeBlocks>


# Drafts

> Learn how to create, manage, and send Drafts to enable advanced agent workflows like human-in-the-loop review and scheduled sending.

## What is a Draft?

A `Draft` is an unsent `Message`. It's a resource that allows your agent to prepare the contents of an email—including recipients, a subject, a body, and `Attachments`—without sending it immediately.

We know agent reliability is big these days--with `Drafts` you can have agents have ready-to-send emails and only with your permission it can send them off into the world.

`Drafts` are a key component for building advanced agent workflows. They enable:

* **Human-in-the-Loop Review:** An agent can create a `Draft` for a sensitive or important `Message`, which a human can then review and approve before it's sent.
* **Scheduled Sending:** Your agent can create a `Draft` and then have a separate process send it at a specific time, such as during business hours for the recipient.
* **Complex Composition:** For `Messages` that require multiple steps to build (e.g., fetching data from several sources, generating content), `Drafts` allow you to save the state of the email as it's being composed.

## The `Draft` Lifecycle

You can interact with `Drafts` throughout their lifecycle, from creation to the moment they are sent.

### 1. Create a `Draft`

This is the first step. You create a `Draft` in a specific `Inbox` that will eventually be the sender.

<CodeBlocks>
  ```python
  # You'll need an inbox ID to create a draft in.

  new_draft=client.inboxes.drafts.create(
      inbox_id="outbound@domain.com",
      to=["review-team@example.com"],
      subject="[NEEDS REVIEW] Agent's proposed response"
  )

  print(f"Draft created successfully with ID: {new_draft.draft_id}")

  ```

  ```typescript title="TypeScript"
  // You'll need an inbox ID to create a draft in.

  const newDraft = await client.inboxes.drafts.create(
  	"my_inbox@domain.com",
  	{
  		to: [
  				"review-team@example.com"
  			],
  		subject: "[NEEDS REVIEW] Agent's proposed response"
  	}
  )

  console.log(`Draft created successfully with ID: ${newDraft.id}`);
  ```
</CodeBlocks>

### 2. Get `Draft`

Once a `Draft` is created, you can retrieve it by its ID

<CodeBlocks>
  ```python title="Python"
  # Get the draft
  draft = client.inboxes.drafts.get(inbox_id = “my_inbox@domain.com”, draft_id = “draft_id_123”)

  ```

  ```typescript title="TypeScript"

  // Get the draft
  const draft = await client.inboxes.drafts.get(
  	"inbox_id",
  	"draft_id_123"
  )

  ```
</CodeBlocks>

### 3. Send a `Draft`

This is the final step that converts the `Draft` into a sent `Message`. Once sent, the `Draft` is deleted.

<CodeBlocks>
  ```python title="Python"

  # This sends the draft and deletes it

  sent_message = client.inboxes.drafts.send(inbox_id = 'my_inbox@domain.com', draft_id = 'draft_id_123')

  print(f"Draft sent! New message ID: {sent_message.message_id}")

  ```

  ```typescript title="TypeScript"

  const sentMessage = await client.inboxes.drafts.send('my_inbox@domain.com', 'draft_id_123');

  console.log(`Draft sent! New message ID: ${sentMessage.message_id}`);
  ```
</CodeBlocks>

Note that now we access it by message\_id now because now its a message!!

## Org-Wide `Draft` Management

Similar to `Threads`, you can list all `Drafts` across your entire `Organization`. This is perfect for building a central dashboard where a human supervisor can view, approve, or delete any `Draft` created by any agent in your fleet.

<CodeBlocks>
  ```python title="Python"
  # Get all drafts across the entire organization
  all_drafts = client.drafts.list()

  print(f"Found {all_drafts.count} drafts pending review.")

  ```

  ```typescript title="TypeScript"
  // Get all drafts across the entire organization
  const allDrafts = await client.drafts.list();

  console.log(`Found ${allDrafts.count} drafts pending review.`);
  ```
</CodeBlocks>


# Labels

> Learn how to use Labels to manage state, track campaigns, and filter messages for powerful agentic workflows.

## What are `Labels`?

`Labels` are simple, string-based tags that you can attach to your `Messages` and `Threads`. They are the primary mechanism for organizing, categorizing, and managing the state of your conversations, whether its automatically bucketing threads into specific categories for your outbound campaign, to segmenting warm leads for your outreach, to categorizing inbound into low-ticket, medium-ticket, high-ticket customers.

A `Message` can have multiple `Labels`, allowing you to create a flexible and powerful system for managing complex workflows.

## Use Cases for `Labels`

By strategically applying `Labels`, you can build sophisticated agent systems. Here are a few common use cases:

<Steps>
  <Step title="State Management">
    Use `Labels` to track the state of a conversation. For example, an agent
    could apply `needs-human-review` when it's unsure how to respond, or a
    supervisor could apply `approved-to-send` to a `Draft`.
  </Step>

  <Step title="Campaign Tracking">
    When running outbound campaigns, tag every `Message` with a unique campaign
    `Label` like `q4-2024-outreach`, or `mercor-campaign` and adding a second
    tag as `warm-lead`. This allows you to easily filter for and analyze the
    performance of that specific campaign later on.
  </Step>

  <Step title="Automated Triage">
    An inbound agent can classify incoming `Messages` with `Labels` like
    `billing-question`, `feature-request`, or `bug-report`, allowing specialized
    agents or human teams to handle them efficiently.
  </Step>
</Steps>

## Core Capabilities

Here's how you can programmatically work with `Labels`.

### 1. Adding `Labels` When Sending a `Message`

You can attach an array of `Labels` directly when you send a `Message`.

<CodeBlocks>
  ```python title="Python"
  sent_message = client.inboxes.messages.send(
      inbox_id="outbound@agentmail.to",
      to=["test@example.com"],
      subject="Following up on our conversation",
      text="Here is the information you requested.",
      labels=["follow-up", "q4-campaign"]
  )
  ```

  ```typescript title="TypeScript"
  const sentMessage = await client.inboxes.messages.send(
    "outbound@agentmail.to",
    {
      to: ["test@example.com"],
      subject: "Following up on our conversation",
      text: "Here is the information you requested.",
      labels: ["follow-up", "q4-campaign"],
    }
  );
  ```
</CodeBlocks>

### 2. Adding or Removing `Labels` on an Existing `Message`

You can modify the `Labels` on a `Message` that has already been sent using the `update` (PATCH) method. This is perfect for changing the state of a conversation as your agent works on it.

<CodeBlocks>
  ```python
  # Let's add a 'resolved' label to a message

  client.messages.update(
  inbox_id='outbound@domain.com',
  message_id='msg_id_123',
  add_labels=["resolved"],
  remove_labels=['unresolved']
  )

  ```

  ```typescript title="TypeScript"
  // Let's add a 'resolved' label to a message


  await client.inboxes.messages.update(
    "my_inbox@domain.com",
    "msg_id_123",
    {
      addLabels: [
          "resolved"
      ],
      removeLabels: [
          "unresolved"
      ]
    }
  )

  ```
</CodeBlocks>

### 3. Filtering by `Labels`

This is where `Labels` become truly powerful. You can list `Threads`, `Messages`, and `Drafts` by filtering for one or more `Labels`, allowing you to create highly targeted queries.

<CodeBlocks>
  ```python
  # Find all threads from a specific campaign that need a follow-up
  filtered_threads = client.inboxes.threads.list(
      inbox_id = 'outbound-agent@domain.com',
      labels=[
          "q4-campaign",
          "follow_up"
      ]
  )

  print(f"Found {filtered_threads.count} threads that need a follow-up.")

  ```

  ```typescript title="TypeScript"
  // Find all threads from a specific campaign that need a follow-up
  const filteredThreads = await client.inboxes.threads.list(
    "leads@agentmail.to",
    {
      labels: [
        "q4-campaign",
        "follow_up"
      ]
    }
  )


  console.log(`Found ${filteredThreads.count} threads that need a follow-up.`);
  ```
</CodeBlocks>

## Best Practices

* **Be Consistent:** Establish a clear and consistent naming convention for your labels (e.g., `kebab-case`, `snake_case`).
* **Use Prefixes:** For state management, consider using prefixes like `status-pending` or `priority-high` to create an organized system.
* **Don't Over-Label:** While you can add many `Labels`, aim for a concise and meaningful set to keep your system manageable.

<Callout title="Coming Soon: AI-Powered Auto-Labeling" intent="info">
  We are actively developing an AI-powered auto-labeling feature. Soon, your
  agents will be able to provide a set of `Labels` and instructions, and
  AgentMail will automatically apply the correct `Labels` to incoming `Messages`
  based on their content.
</Callout>


# Attachments

> Learn how to send files as attachments, and download incoming attachments from both messages and threads.

## What are `Attachments`?

An `Attachment` is a file that is associated with a `Message`. This can be anything from a PDF invoice to a CSV report or an image(though we don't recommend sending images in the first email sent. We go more into this in the [deliverability section](/email-deliverability)). Your agents can both send `Attachments` in outgoing `Messages` and process `Attachments` from incoming `Messages`.

## Sending `Attachments`

To send a file, you include it in an `Attachments` array when sending a `Message`. Each object in the array represents one file and must have a `content` property.

* **`content`** (required): The Base64 encoded content of your file.
* **`filename`** (optional): The name of the file (e.g., `invoice.pdf`).
* **`content_type`** (optional): The MIME type of the file (e.g., `application/pdf`).

<CodeBlocks>
  ```python
  import base64

  # A simple text file for this example

  file_content = "This is the content of our report."

  # You must Base64 encode the file content before sending

  encoded_content = base64.b64encode(file_content.encode()).decode()

  sent_message = client.inboxes.messages.send(
  inbox_id="reports@agentmail.to",
  to=["supervisor@example.com"],
  subject="Q4 Financial Report",
  text="Please see the attached report.",
  attachments=[{
  "content": encoded_content,
  "filename": "Q4-report.txt",
  "content_type": "text/plain"
  }]
  )

  ```

  ```typescript title="TypeScript"
  // A simple text file for this example
  const fileContent = "This is the content of our report.";
  // You must Base64 encode the file content before sending
  const encodedContent = Buffer.from(fileContent).toString("base64");

  const sentMessage = await client.inboxes.messages.send("reports@agentmail.to", {
    to: ["supervisor@example.com"],
    subject: "Q4 Financial Report",
    text: "Please see the attached report.",
    attachments: [{
      content: encodedContent,
      filename: "Q4-report.txt",
      contentType: "text/plain",
    }],
  });
  ```
</CodeBlocks>

## Retrieving `Attachments`

To retrieve an `Attachment`, you first need its `attachment_id`. You can get this ID from the `attachments` array on a `Message` object. Once you have the ID, you can download the file.

The API response for getting an attachment is the raw file itself, which you can then save to disk or process in memory.

### From a Specific `Message`

If you know the `Message` an `Attachment` belongs to, you can retrieve it directly.

<CodeBlocks>
  ```python
  inbox_id = "inbox_123"
  message_id = "msg_456"
  attachment_id = "attach_789" # From the message object

  file_data = client.inboxes.messages.get_attachment(
  inbox_id=inbox_id,
  message_id=message_id,
  attachment_id=attachment_id
  )

  # Now you can save the file

  with open("downloaded_file.pdf", "wb") as f:
  f.write(file_data)

  ```

  ```typescript title="TypeScript"
  const inboxId = "inbox_123";
  const messageId = "msg_456";
  const attachmentId = "attach_789"; // From the message object

  const fileData = await client.inboxes.messages.get_attachment(
    inboxId,
    messageId,
    attachmentId
  );

  // fileData is a Blob/Buffer that you can process
  // For example, in Node.js:
  // import fs from 'fs';
  // fs.writeFileSync('downloaded_file.pdf', fileData);
  ```
</CodeBlocks>

### From a Specific `Thread`

Similarly, you can retrieve an `Attachment` if you know the `Thread` it's in, which can be more convenient for multi-message conversations.

<CodeBlocks>
  ```python
  inbox_id = "inbox_123"
  thread_id = "thread_abc"
  attachment_id = "attach_789" # From a message within the thread

  file_data = client.inboxes.threads.get_attachment(
  inbox_id=inbox_id,
  thread_id=thread_id,
  attachment_id=attachment_id
  )

  ```

  ```typescript title="TypeScript"
  const inboxId = "inbox_123";
  const threadId = "thread_abc";
  const attachmentId = "attach_789"; // From a message within the thread

  const fileData = await client.inboxes.threads.get_attachment(
    inboxId,
    threadId,
    attachmentId
  );
  ```
</CodeBlocks>


# Pods

> Learn how to use pods for multi-tenant email management

## What are Pods?

Pods are an isolated abstraction that sits between your **organization** and your **inboxes**, providing a method to segment and organize email infrastructure for multi-tenant applications. If you're building a service that offers email functionality to your customers, pods are your key to ensure customer resource isolation.

### The Hierarchy

```
Organization (Your Business)
    └── Pod (Your Customer A)
        ├── Inbox 1
        ├── Inbox 2
        └── Domain 1
    └── Pod (Your Customer B)
        ├── Inbox 3
        ├── Inbox 4
        └── Domain 2
```

**Organization**: Your company's AgentMail account

* You have one organization that represents your business

**Pod**: Each of your customers

* Create one pod per customer/tenant in your system
* Pods provide complete isolation between your customers' data
* All resources (inboxes, domains, threads, drafts) can be scoped to a pod

**Inbox**: Individual email accounts within a pod

* Your customers can have multiple inboxes within their pod
* It is on you to provision resources for each of your customers

## Why Use Pods?

### Multi-Tenancy

Pods enable you to offer AgentMail's email infrastructure to your own customers while maintaining strict data isolation. Here's how our customers use pods:

**SaaS/Agency Platforms**: Create a pod for each customer account. Each customer gets their own isolated email workspace.

**White-Label Email**: Offer email services under your own brand. Each end-user gets their own pod with complete data isolation.

**AI Agent Platforms**: Give each AI agent with its own purpose its own pod with dedicated inboxes and domains.

## How Pods Work

### Pod Lifecycle

As a basis, here are a couple of logistical stuff that happens on the API side when you create resources.

* When you sign up, you are automatically created a `Default Pod`, and all resources created whether its `Inboxes` or `Domains` all are associated with this `Default Pod`.
* You cannot delete a `Pod` that has existing children resources. Make sure to delete any existing `Inboxes` or `Domains` before deleting a `Pod`.

### What You Can Do With Pods

#### Creating Resources

You can create the following resources **within** a pod:

* **Inboxes**
* **Domains**

<Callout>
  NOTE: as of now domains can only be either scoped to one pod, or all pods. I.E
  it is not possible to create a domain scoped to more than one but not all
  pods.
</Callout>

<Tip>
  TIP: specify a `client_id` when creating a `Pod` so that you can decide how to
  uniquely identify pods. That way you don't need to create a table mapping your
  `organization_id`'s for your customers or segment of your business to our
  `pod_id`'s you can just set the `client_id` as your internal id so you can
  access the resource using a unique identifier determined by you!
</Tip>

These resources are automatically associated with the pod and inherit its isolation guarantees.

#### Listing Resources

You can list the following resources **scoped to** a pod:

* **Inboxes** (`GET /pods/{pod_id}/inboxes`) - View all inboxes in a pod
* **Threads** (`GET /pods/{pod_id}/threads`) - View all email conversations across all inboxes in the pod
* **Drafts** (`GET /pods/{pod_id}/drafts`) - View all draft emails across all inboxes in the pod
* **Domains** (`GET /pods/{pod_id}/domains`) - View all custom domains in the pod

This gives you a unified view of all activity within a customer's workspace, making it easy to build features like:

* "Show me all unread emails for Customer X" (use labels here too!)
* "List all threads across all of Customer Y's team inboxes"
* "Display all pending drafts for Customer Z"

## Important Considerations

### Pod Deletion Constraints

<Warning>
  **Critical**: You cannot delete a pod that has resources still attached to it.
  You must delete all inboxes and domains within the pod before you can delete
  the pod itself.
</Warning>

This is a safety mechanism to prevent accidental data loss. Here's the correct deletion sequence:

```typescript
// This will FAIL if the pod has any resources
await client.pods.delete(podId);

// Correct approach: Clean up resources first
async function offboardCustomer(podId: string) {
  // 1. Delete all inboxes
  const inboxRes = await client.inboxes.list(podId);
  for (const inbox of inboxRes.inboxes) {
    await client.inboxes.delete(inbox.inbox_id);
  }

  // 2. Delete all domains
  const domainRes = await client.domains.list({ podId });
  for (const domain of domainRes.domains) {
    await client.domains.delete(domain.domain_id);
  }

  // 3. Now you can delete the pod
  await client.pods.delete(podId);
}
```

<Info>
  When you delete an inbox or domain, all associated data (messages, threads,
  drafts) is automatically cleaned up. You don't need to manually delete
  individual threads or messages.
</Info>

**What's NOT Isolated to a Pod:**

* API keys (these are organization-level and can access any resources in any pod)

## Common Patterns and Use Cases

### Pattern 1: Multi-Tenant SaaS

Each company using your platform gets their own pod:

```typescript
// Customer A's workspace
Pod: "Acme Corp"
├── Inbox: support@acme.com
├── Inbox: sales@acme.com
└── Domain: acme.com

// Customer B's workspace
Pod: "TechStart Inc"
├── Inbox: hello@techstart.io
├── Inbox: team@techstart.io
└── Domain: techstart.io
```

### Pattern 2: Agency Client Management

Each client gets their own isolated pod:

```typescript
// Client 1
Pod: "Client - Retail Co"
├── Inbox: info@retailco.com
└── Domain: retailco.com

// Client 2
Pod: "Client - FinTech"
├── Inbox: support@fintech.ai
└── Domain: fintech.ai
```

### Pattern 3: AI Agent Platform

Each AI agent gets its own pod with dedicated email infrastructure:

```typescript
// Agent 1: Customer Support Agent
Pod: "Support-Agent"
├── Inbox: support@mycompany.com
├── Inbox: help@mycompany.com
└── Inbox: tickets@mycompany.com

// Agent 2: Sales Outreach Agent
Pod: "Sales-Agent"
├── Inbox: sales@mycompany.com
├── Inbox: outreach@mycompany.com
└── Inbox: leads@mycompany.com

// Agent 3: Marketing Agent
Pod: "Marketing-Agent"
├── Inbox: newsletter@mycompany.com
├── Inbox: campaigns@mycompany.com
└── Inbox: events@mycompany.com
```

## FAQ

<Accordion title="Can inboxes communicate between pods?">
  Yes! Inboxes in different pods can send and receive emails from each other
  just like any other email addresses. Pods only provide organizational
  isolation, not network isolation.
</Accordion>

<Accordion title="Can I move an inbox from one pod to another?">
  No, inboxes cannot be moved between pods. You will need to create a new inbox
  in the pod you want.
</Accordion>

<Accordion title="How many pods can I create?">
  There's no hard limit on the number of pods. You can create as many as you
  need for your customers.
</Accordion>

<Accordion title="Do I need to use pods?">
  Pods are optional but highly recommended for multi-tenant applications. If
  you're only managing email for your own organization, you can work directly
  with inboxes without creating pods.
</Accordion>

<Accordion title="Can I set custom permissions per pod?">
  Pod isolation is upon the caller (you). As of now we don't support pod-scoped
  API keys so it will be on you to make the calls to AgentMail.
</Accordion>

## Next Steps

* Learn about [Inboxes](/inboxes) and how to create email accounts within pods
* Explore [Domains](/custom-domains) to set up custom email domains for your pods


# Skills

> AgentMail's official skill for Moltbot, Claude Code, Cursor, and other AI assistants

## Getting started

AgentMail provides an official skill that can be installed on AI coding assistants and agents that support the [AgentSkills](https://skills.sh) format. This includes Moltbot, Claude Code, Cursor, Codex, and other compatible tools.

The skill is available at [skills.sh/agentmail-to/agentmail-skills/agentmail](https://skills.sh/agentmail-to/agentmail-skills/agentmail).

## Installation

### Moltbot

Install the skill using the Moltbot CLI:

```bash
moltbot skills install agentmail-to/agentmail-skills/agentmail
```

Or install via ClawdHub:

```bash
clawdhub install agentmail
```

### Claude Code

Add the skill to your Claude Code configuration:

```bash
claude-code skills install agentmail-to/agentmail-skills/agentmail
```

### Cursor

Install the skill in Cursor:

```bash
cursor skills install agentmail-to/agentmail-skills/agentmail
```

### Manual installation

You can also manually clone the skill repository:

```bash
git clone https://github.com/agentmail-to/agentmail-skills.git ~/.skills/agentmail
```

## Configuration

After installation, configure your AgentMail API key. The method varies by platform:

### Environment variable

Set the `AGENTMAIL_API_KEY` environment variable:

```bash
export AGENTMAIL_API_KEY="your-api-key-here"
```

### Moltbot configuration

Add the API key to `~/.clawdbot/moltbot.json`:

```json
{
  "skills": {
    "entries": {
      "agentmail": {
        "enabled": true,
        "env": {
          "AGENTMAIL_API_KEY": "your-api-key-here"
        }
      }
    }
  }
}
```

Get your API key from the [AgentMail Console](https://console.agentmail.to).

## Features

The official AgentMail skill provides comprehensive email functionality:

### Inboxes

Create scalable inboxes on-demand. Each inbox has a unique email address that your AI agent can use to send and receive emails.

### Messages

Send emails with both plain text and HTML content for best deliverability. The skill handles proper formatting and headers automatically.

### Threads

Threads group related messages in a conversation, making it easy to follow email chains and maintain context across multiple exchanges.

### Attachments

Send and receive attachments with Base64 encoding. The skill can retrieve attachments from messages or threads.

### Drafts

Create drafts for human-in-the-loop approval before sending. This is useful when you want to review emails before they go out.

### Pods

Multi-tenant isolation for SaaS platforms. Each customer gets isolated inboxes, perfect for building email-enabled applications.

### Idempotency

Use idempotency keys for safe retries on create operations. This prevents duplicate emails when network errors occur.

### Real-time events

The skill supports both WebSockets (persistent connection, no public URL needed) and webhooks (HTTP-based notifications) for real-time email notifications.

## Example usage

Once installed, you can ask your AI assistant to perform email tasks:

* "Create a new email inbox for my project"
* "Send an email to [john@example.com](mailto:john@example.com) about the meeting tomorrow"
* "Check my inbox for new emails"
* "Reply to the latest email from Sarah"
* "Create a draft response to the support ticket"

## Resources

* [Official AgentMail Skill on skills.sh](https://skills.sh/agentmail-to/agentmail-skills/agentmail)
* [AgentMail Skills Repository](https://github.com/agentmail-to/agentmail-skills)
* [AgentMail API Reference](/api-reference)
* [AgentMail Console](https://console.agentmail.to)


# MCP

> AgentMail's Model Context Protocol (MCP) integration

## Getting started

The Model Context Protocol (MCP) is an open standard that enables AI applications to connect with external tools and data sources. AgentMail provides an MCP server that allows any MCP-compatible client to interact with the AgentMail API.

### Setup

To get started with the AgentMail MCP server, visit [mcp.agentmail.to](https://mcp.agentmail.to) for installation instructions and configuration details.

## Features

The AgentMail MCP server provides tools for:

* **Inbox management:** Create, list, and delete inboxes
* **Message operations:** Send, receive, and reply to emails
* **Thread management:** Access and manage email threads
* **Attachments:** Handle email attachments

## Compatible clients

The AgentMail MCP server works with any MCP-compatible client, including:

* Claude Desktop
* Cursor
* Windsurf
* Other MCP-enabled AI applications

For detailed setup instructions and available tools, visit [mcp.agentmail.to](https://mcp.agentmail.to).


# Openclaw

> AgentMail's Openclaw integration

## Getting started

Openclaw (formerly Moltbot) is an open-source AI personal assistant that runs on your own devices and integrates with messaging platforms like WhatsApp, Telegram, Discord, and Slack. By adding AgentMail to Openclaw, your agent gains the ability to send and receive emails, enabling two-way email conversations alongside your existing chat channels.

There are two ways to integrate AgentMail with Openclaw: using the official AgentMail skill or creating a custom skill.

## Option 1: Official AgentMail Skill (Recommended)

The easiest way to add email capabilities to Openclaw is by installing the official AgentMail skill from [skills.sh](https://skills.sh/agentmail-to/agentmail-skills/agentmail). This skill is maintained by the AgentMail team and provides comprehensive email functionality.

### Installation

Install the skill using the Openclaw CLI:

```bash
openclaw skills install agentmail-to/agentmail-skills/agentmail
```

Or install via ClawdHub:

```bash
clawdhub install agentmail
```

### Configuration

Add your AgentMail API key to the skill configuration in `~/.openclaw/openclaw.json`:

```json
{
  "skills": {
    "entries": {
      "agentmail": {
        "enabled": true,
        "env": {
          "AGENTMAIL_API_KEY": "your-api-key-here"
        }
      }
    }
  }
}
```

Get your API key from the [AgentMail Console](https://console.agentmail.to).

### Features

The official skill includes:

* **Inbox management:** Create scalable inboxes on-demand with unique email addresses
* **Message operations:** Send emails with text and HTML content for best deliverability
* **Thread management:** Group related messages in conversations
* **Attachments:** Send and receive attachments with Base64 encoding
* **Drafts:** Create drafts for human-in-the-loop approval before sending
* **Pods:** Multi-tenant isolation for SaaS platforms
* **Idempotency:** Safe retries on create operations
* **Real-time events:** WebSocket and webhook support for notifications

### Verify installation

Check that the skill is loaded:

```bash
openclaw skills list --eligible
```

You should see `agentmail` in the list of available skills.

## Option 2: Custom Skill

For more control over the integration, you can create a custom AgentMail skill. Skills are directories containing a `SKILL.md` file with instructions for Openclaw.

### Create the skill directory

Create a new skill in your Openclaw workspace:

```bash
mkdir -p ~/.openclaw/skills/agentmail
```

### Create the skill file

Create `~/.openclaw/skills/agentmail/SKILL.md` with the following content:

````markdown
---
name: agentmail
description: Send and receive emails using AgentMail
requires:
  env:
    - AGENTMAIL_API_KEY
---

# AgentMail Skill

You can send and receive emails using the AgentMail API. Use the `exec` tool to run curl commands against the AgentMail API.

## API Base URL

```
https://api.agentmail.to/v1
```

## Authentication

Include your API key in the Authorization header:

```
Authorization: Bearer $AGENTMAIL_API_KEY
```

## Common Operations

### List inboxes

```bash
curl -s -H "Authorization: Bearer $AGENTMAIL_API_KEY" \
  https://api.agentmail.to/v1/inboxes
```

### Create an inbox

```bash
curl -s -X POST -H "Authorization: Bearer $AGENTMAIL_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"display_name": "My Agent"}' \
  https://api.agentmail.to/v1/inboxes
```

### Send an email

```bash
curl -s -X POST -H "Authorization: Bearer $AGENTMAIL_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "to": ["recipient@example.com"],
    "subject": "Hello from Openclaw",
    "text": "This email was sent by my AI assistant."
  }' \
  https://api.agentmail.to/v1/inboxes/{inbox_id}/messages
```

### List messages in an inbox

```bash
curl -s -H "Authorization: Bearer $AGENTMAIL_API_KEY" \
  https://api.agentmail.to/v1/inboxes/{inbox_id}/messages
```

### Reply to a message

```bash
curl -s -X POST -H "Authorization: Bearer $AGENTMAIL_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"text": "Thanks for your email!"}' \
  https://api.agentmail.to/v1/inboxes/{inbox_id}/messages/{message_id}/reply
```
````

### Configure the skill

Add your AgentMail API key to the skill configuration in `~/.openclaw/openclaw.json`:

```json
{
  "skills": {
    "entries": {
      "agentmail": {
        "enabled": true,
        "env": {
          "AGENTMAIL_API_KEY": "your-api-key-here"
        }
      }
    }
  }
}
```

### Verify the skill

Check that the skill is loaded:

```bash
openclaw skills list --eligible
```

You should see `agentmail` in the list of available skills.

## Example use cases

Once AgentMail is integrated with Openclaw, you can ask your agent to:

* "Create a new email inbox for my project"
* "Check my inbox for new emails"
* "Send an email to [john@example.com](mailto:john@example.com) about the meeting tomorrow"
* "Reply to the latest email from Sarah"
* "Forward the invoice email to [accounting@company.com](mailto:accounting@company.com)"

## Real-time email notifications

For proactive email handling, you can combine AgentMail webhooks with Openclaw's webhook support. This allows Openclaw to notify you immediately when new emails arrive.

1. Set up a webhook endpoint in Openclaw (see [Openclaw webhook documentation](https://docs.openclaw.ai/automation/webhook))

2. Register the webhook with AgentMail:

```bash
curl -X POST -H "Authorization: Bearer $AGENTMAIL_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "url": "https://your-openclaw-webhook-url",
    "events": ["message.received"]
  }' \
  https://api.agentmail.to/v1/webhooks
```

Now Openclaw will be notified whenever a new email arrives, allowing it to proactively inform you or take action.

## Resources

* [Official AgentMail Skill](https://skills.sh/agentmail-to/agentmail-skills/agentmail)
* [AgentMail API Reference](/api-reference)
* [Openclaw Documentation](https://docs.openclaw.ai)
* [Openclaw Skills Guide](https://docs.openclaw.ai/tools/skills)


# Replit

> AgentMail's Replit integration

## Getting started

Replit is a cloud-based app and agent builder with a built in IDE, AI assistant, and deployment infrastructure.

AgentMail is a "connector" integration on Replit, meaning your Replit apps and agents can use it directly.

### Setup

Navigate to the Intregrations tab in the Replit builder. Find AgentMail and click Connect/Sign in. Then paste in your AgentMail API key from the AgentMail Console. That's it.

## How it works

Replit uses Mastra, a TypeScript framework for building agents. Everytime you create a new app/agent Replit will generate a set of Mastra tools to interface with the AgentMail API, based on your use case and requirements.

Below is a collections of prebuilt tools that Replit can use out of the box to serve virtually any use case.

### Tools

<CodeBlocks>
  ```typescript title="TypeScript"
  import { createTool } from '@mastra/core/tools'
  import { z } from 'zod'

  import { AgentMailClient } from 'agentmail'

  const ListItemsInput = z.object({
      limit: z.number().optional().describe('Max number of items to return'),
      pageToken: z.string().optional().describe('Pagination page token'),
  })

  const InboxId = z.string().describe('ID of inbox')

  const GetInboxInput = z.object({ inboxId: InboxId })

  const CreateInboxInput = z.object({
      username: z.string().optional().describe('Username'),
      domain: z.string().optional().describe('Domain'),
      displayName: z.string().optional().describe('Display name'),
  })

  const ListInboxItemsInput = ListItemsInput.extend({
      inboxId: InboxId,
      labels: z.array(z.string()).optional().describe('Filter items with labels'),
      before: z.coerce.date().optional().describe('Filter items before datetime'),
      after: z.coerce.date().optional().describe('Filter items after datetime'),
  })

  const GetThreadInput = GetInboxInput.extend({
      threadId: z.string().describe('ID of thread'),
  })

  const MessageId = z.string().describe('ID of message')

  const BaseMessageInput = z.object({
      inboxId: InboxId,
      text: z.string().optional().describe('Plain text body'),
      html: z.string().optional().describe('HTML body'),
      labels: z.array(z.string()).optional().describe('Labels'),
  })

  const SendMessageInput = BaseMessageInput.extend({
      to: z.union([z.string(), z.array(z.string())]).describe('To recipients'),
      cc: z
          .union([z.string(), z.array(z.string())])
          .optional()
          .describe('CC recipients'),
      bcc: z
          .union([z.string(), z.array(z.string())])
          .optional()
          .describe('BCC recipients'),
      subject: z.string().optional().describe('Subject'),
  })

  const ReplyToMessageInput = BaseMessageInput.extend({ messageId: MessageId })

  const UpdateMessageInput = z.object({
      inboxId: InboxId,
      messageId: MessageId,
      addLabels: z.array(z.string()).optional().describe('Labels to add'),
      removeLabels: z.array(z.string()).optional().describe('Labels to remove'),
  })

  const listInboxesTool = createTool({
      id: 'list-inboxes',
      description: 'List inboxes',
      inputSchema: ListItemsInput,
      execute: ({ context }) => {
          const client = new AgentMailClient()
          return client.inboxes.list(context)
      },
  })

  const createInboxTool = createTool({
      id: 'create-inbox',
      description: 'Create inbox',
      inputSchema: CreateInboxInput,
      execute: ({ context }) => {
          const client = new AgentMailClient()
          return client.inboxes.create(context)
      },
  })

  const deleteInboxTool = createTool({
      id: 'delete-inbox',
      description: 'Delete inbox',
      inputSchema: GetInboxInput,
      execute: ({ context }) => {
          const client = new AgentMailClient()
          return client.inboxes.delete(context.inboxId)
      },
  })

  const listThreadsTool = createTool({
      id: 'list-threads',
      description: 'List threads',
      inputSchema: ListInboxItemsInput,
      execute: ({ context }) => {
          const client = new AgentMailClient()
          return client.inboxes.threads.list(context.inboxId, context)
      },
  })

  const getThreadTool = createTool({
      id: 'get-thread',
      description: 'Get thread and its messages',
      inputSchema: GetThreadInput,
      execute: ({ context }) => {
          const client = new AgentMailClient()
          return client.inboxes.threads.get(context.inboxId, context.threadId)
      },
  })

  const sendMessageTool = createTool({
      id: 'send-message',
      description: 'Send message',
      inputSchema: SendMessageInput,
      execute: ({ context }) => {
          const client = new AgentMailClient()
          return client.inboxes.messages.send(context.inboxId, context)
      },
  })

  const replyToMessageTool = createTool({
      id: 'reply-to-message',
      description: 'Reply to message',
      inputSchema: ReplyToMessageInput,
      execute: ({ context }) => {
          const client = new AgentMailClient()
          return client.inboxes.messages.reply(context.inboxId, context.messageId, context)
      },
  })

  const updateMessageTool = createTool({
      id: 'update-message',
      description: 'Update message',
      inputSchema: UpdateMessageInput,
      execute: ({ context }) => {
          const client = new AgentMailClient()
          return client.inboxes.messages.update(context.inboxId, context.messageId, context)
      },
  })

  export const tools = {
      listInboxesTool,
      createInboxTool,
      deleteInboxTool,
      listThreadsTool,
      getThreadTool,
      sendMessageTool,
      replyToMessageTool,
      updateMessageTool,
  }
  ```
</CodeBlocks>

## About AgentMail

AgentMail is the email inbox API for AI agents. It gives agents their own email inboxes, like Gmail does for humans. Unlike other email APIs, AgentMail is for both sending and receiving, supporting two-way email conversations.

Email is critical to identity and communication on the internet. Much of the context that people use for their work exists within email. AgentMail enables AI agents to meet people where they work and use the internet like humans do.

### Features

1. **Programmatic inboxes:** Create, manage, and delete inboxes via API
2. **Threads and replies:** Facilitate 2-way emals conversations with persistant and relevant context
3. **Attachments:** Send, receive, and download attachments so agents can work with documents
4. **Realtime events:** Build event-driven agents and systems with Webhooks and Websockets
5. **Custom domains:** Whitelabel your or your customers' inboxes to automate client-facing work
6. **Language/Framework SDKs:** Use your prefered language and framework

### Use cases

1. **Process inbound:** Receive, triage, and process inbound emails
2. **Automate outbound:** Draft, schedule, and send outbound emails
3. **Join conversations:** Address an agent directly or CC it in an existing email thread
4. **Identify and authenticate:** Agents can sign up, receive 2FA code, and authenticate with any application

### Verticals

1. **Operations:** Automate internal workflows, vendor communications, and cross-team coordination
2. **Support:** Handle customer inquiries, ticket management, and automated responses at scale
3. **Procurement:** Streamline vendor onboarding, RFP processes, and purchase order management
4. **Sales:** Automate lead qualification, follow-ups, and customer outreach campaigns
5. **Recruiting:** Automate candidate outreach, interview scheduling, and applicant communication

These are just a few select verticals, but we have seen AgentMail be effective in automating any email task across every function. If a human does it with email, it can be automated with AgentMail.


# Guide: Sending & Receiving Email

> A step-by-step guide to the practical workflow of sending initial emails and handling replies to have a full conversation.

This guide walks you through the complete, practical workflow of an agent having a conversation. While the `Core Concepts` pages detail the individual API calls, this guide shows you how to stitch them together to create a functional conversational loop.

## The Foundation: Sending HTML & Text

As a quick reminder from our `Messages` documentation, it's a critical best practice to always provide both an `html` and a `text` version of your email. This ensures readability on all email clients and significantly improves deliverability.

```python
# Always provide both html and text when possible
client.inboxes.messages.send(
    inbox_id="outreach@agentmail.to",
    to=["potential-customer@example.com"],
    subject="Following up",
    text="Hi Jane,\n\nThis is a plain-text version of our email.",
    html="<p>Hi Jane,</p><p>This is a <strong>rich HTML</strong> version of our email.</p>",
    labels=["outreach-campaign"]
)
```

## The Conversational Loop

A common task for an agent is to check for replies in an `Inbox` and then respond to them. While using `Webhooks` is the most efficient method for this, you can also build a simple polling mechanism.

Here's the step-by-step logic for a polling-based conversational agent.

<Steps>
  <Step title="1. Find a Thread that Needs a Reply">
    First, you need to identify which conversations have new messages that your agent hasn't responded to. A great way to manage this is with `Labels`. You can list `Threads` in a specific `Inbox` that have an `unreplied` `Label`.

    <CodeBlocks>
      ```python
      # Find all threads in this inbox that are marked as unreplied
      threadsRes = client.threads.list(
          labels = ["unreplied"]
      )
      if threadsRes.count == 0:
          print("No threads need a reply.")
      else:
          # Let's work on the first unreplied thread
          thread_to_reply_to = threadsRes.thread[0]
      ```

      ```typescript
      // Find all threads in this inbox that are marked as unreplied
      const threadRes = await client.threads.list(
          {
              labels: [
                  "huh"
              ]
          }
      )

      if (threadRes.count === 0) {
          console.log("No threads need a reply.");
      } else {
          // Let's work on the first unreplied thread
          const threadToReplyTo = threadRes.threads[0];
      }
      ```
    </CodeBlocks>
  </Step>

  <Step title="2. Get the Last Message ID from the Thread">
    To reply to a conversation, you need to reply to the *most recent message* in the `Thread`. You can get a specific `Thread` by its ID, which will contain a list of all its `Messages`. You'll then grab the ID of the last `Message` in that list.

    <CodeBlocks>
      ```python
      # Get the full thread object to access its messages
      thread_details = client.threads.get(thread_to_reply_to.thread_id)

      # The last message in the list is the one we want to reply to
      last_message = thread_details.messages[-1]
      message_id_to_reply_to = last_message.message_id
      ```

      ```typescript
      // Get the full thread object to access its messages
      const threadDetails = await client.threads.get('thread_id');

      // The last message in the array is the one we want to reply to
      const lastMessage = threadDetails.messages[threadDetails.messages.length - 1];
      const messageIdToReplyTo = lastMessage.message_id;
      ```
    </CodeBlocks>
  </Step>

  <Step title="3. Send the Reply and Update Labels">
    Now that you have the `message_id` to reply to, you can send your agent's response. It's also a best practice to update the `Labels` on the original `Message` at the same time, removing the `unreplied` `Label` and adding a `replied` `Label` to prevent the agent from replying to the same message twice.

    <CodeBlocks>
      ```python
      # Send the reply
      client.inboxes.messages.reply(
          inbox_id="support@agentmail.to",
          message_id=message_id_to_reply_to,
          text="This is our agent's helpful reply!"
      )

      # Update the labels on the original message
      client.inboxes.messages.update(
          inbox_id="support@agentmail.to",
          message_id=message_id_to_reply_to,
          add_labels=["replied"],
          remove_labels=["unreplied"]
      )
      ```

      ```typescript
      // Send the reply
      await client.inboxes.messages.reply("support@agentmail.to", messageIdToReplyTo, {
          text: "This is our agent's helpful reply!",
      });

      // Update the labels on the original message
      await client.inboxes.messages.update("support@agentmail.to", messageIdToReplyTo, {
          addLabels: ["replied"],
          removeLabels: ["unreplied"],
      });
      ```
    </CodeBlocks>
  </Step>
</Steps>

<Callout intent="success" title="Real-Time Processing with Webhooks">
  For production applications, polling is inefficient. The best way to handle incoming replies is to use `Webhooks`. This allows AgentMail to notify your agent instantly when a new `Message` arrives, so you can reply in real-time.

  [**Learn how to set up `Webhooks` →**](/overview)
</Callout>


# IMAP & SMTP

> Configure IMAP and SMTP to access your AgentMail inboxes using email clients or programmatic access.

AgentMail supports standard IMAP and SMTP protocols, allowing you to connect using traditional email clients or integrate with existing systems that rely on these protocols.

## What are IMAP and SMTP?

**IMAP (Internet Message Access Protocol)** and **SMTP (Simple Mail Transfer Protocol)** are the standard protocols that power email communication across the internet.

* **IMAP** is used to **read and manage emails**. It allows email clients to sync with a mail server, keeping your messages organized across multiple devices. When you check your inbox in Outlook or Thunderbird, you're using IMAP.

* **SMTP** is used to **send emails**. When you hit "Send" on an email, SMTP handles delivering that message to the recipient's mail server.

### Why Use IMAP/SMTP with AgentMail?

* **Email Client Integration**: Connect Outlook, Thunderbird, Apple Mail, or any IMAP/SMTP-compatible client to your AgentMail inbox
* **Programmatic Access**: Send and receive emails using standard libraries (like Python's `imaplib` or `smtplib`) in any programming language
* **Legacy System Integration**: Bridge AgentMail with existing systems that only support IMAP/SMTP protocols
* **Familiar Tooling**: Use email tools you already know during development and testing

## Finding Your Credentials

Before configuring IMAP or SMTP, you'll need two pieces of information from the [AgentMail Console](https://console.agentmail.to):

<Steps>
  <Step title="Get Your Inbox ID (Username)">
    Navigate to **Dashboard → Inboxes** and find the **Inbox ID** column. Your
    inbox ID is your inbox's email address (e.g., `myinbox@agentmail.to`). This
    will be your username for IMAP authentication.
  </Step>

  <Step title="Get Your API Key (Password)">
    Navigate to **Dashboard → API Keys** and create or copy an API key—this will
    be your password.
  </Step>
</Steps>

## IMAP Configuration

Use IMAP to read emails from your AgentMail inbox.

<Callout intent="warning" title="SSL/TLS Required">
  SSL/TLS is **required** for all IMAP connections. Connections without SSL will
  be rejected. Make sure to enable SSL/TLS in your email client settings.
</Callout>

| Setting      | Value                                           |
| ------------ | ----------------------------------------------- |
| **Host**     | `imap.agentmail.to`                             |
| **Port**     | `993`                                           |
| **Username** | Your inbox email (e.g., `myinbox@agentmail.to`) |
| **Password** | Your API key                                    |
| **SSL/TLS**  | **Required** (must be enabled)                  |

<Callout intent="tip" title="Folder Support">
  Currently, only the **INBOX** folder is accessible via IMAP. Other folders
  (Sent, Drafts, Trash) are not available through IMAP. Use the [AgentMail
  API](/introduction) for full folder access.
</Callout>

### Python IMAP Example

```python
import imaplib
import os
import email

# Your credentials from AgentMail Console
inbox_email = "myinbox@agentmail.to"  # From Dashboard → Inboxes
api_key = os.getenv("AGENTMAIL_API_KEY")  # From Dashboard → API Keys

# Connect with SSL (required)
imap = imaplib.IMAP4_SSL("imap.agentmail.to", 993)

try:
    # Authenticate using inbox email as username
    imap.login(inbox_email, api_key)

    # Select INBOX (only supported folder)
    imap.select("INBOX")

    # Search for all messages
    status, message_ids = imap.search(None, "ALL")

    if status == "OK":
        for msg_id in message_ids[0].split():
            # Fetch message
            status, msg_data = imap.fetch(msg_id, "(RFC822)")
            if status == "OK":
                email_body = msg_data[0][1]
                message = email.message_from_bytes(email_body)
                print(f"Subject: {message['subject']}")
finally:
    imap.logout()
```

### TypeScript IMAP Example

```typescript
import Imap from "imap";

// Your credentials from AgentMail Console
const inboxEmail = "myinbox@agentmail.to"; // From Dashboard → Inboxes
const apiKey = process.env.AGENTMAIL_API_KEY!; // From Dashboard → API Keys

const imap = new Imap({
  user: inboxEmail,
  password: apiKey,
  host: "imap.agentmail.to",
  port: 993,
  tls: true, // SSL required
});

imap.once("ready", () => {
  imap.openBox("INBOX", false, (err, box) => {
    if (err) throw err;
    console.log(`${box.messages.total} messages in INBOX`);
    imap.end();
  });
});

imap.once("error", (err: Error) => {
  console.error("IMAP error:", err.message);
});

imap.connect();
```

## SMTP Configuration

Use SMTP to send emails from your AgentMail inbox.

<Callout intent="warning" title="SSL/TLS Required">
  SSL/TLS is **required** for all SMTP connections. Connections without SSL will
  be rejected. Make sure to enable SSL/TLS in your email client settings.
</Callout>

| Setting      | Value                          |
| ------------ | ------------------------------ |
| **Host**     | `smtp.agentmail.to`            |
| **Port**     | `465`                          |
| **Username** | agentmail                      |
| **Password** | Your API key                   |
| **SSL/TLS**  | **Required** (must be enabled) |

<Callout intent="warning" title="From Address">
  The "From" address in your email should match the email address of your inbox
  (e.g., `myinbox@agentmail.to`). Using a different From address may result in
  delivery failures.
</Callout>

### SMTP Limits

* **Max recipients**: 50 per email
* **Max message size**: 10MB
* **Session timeout**: 30 minutes

### Python SMTP Example

```python
import smtplib
import os
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

# Your credentials from AgentMail Console
inbox_email = "myinbox@agentmail.to"  # From Dashboard → Inboxes
api_key = os.getenv("AGENTMAIL_API_KEY")  # From Dashboard → API Keys

# Create message
msg = MIMEMultipart()
msg["Subject"] = "Hello from AgentMail"
msg["From"] = inbox_email  # Use your inbox email as the From address
msg["To"] = "recipient@example.com"
msg.attach(MIMEText("This is a test email sent via SMTP.", "plain"))

# Connect with SSL (required) and send
with smtplib.SMTP_SSL("smtp.agentmail.to", 465) as server:
    server.login(inbox_email, api_key)
    server.send_message(msg)
    print("Email sent successfully!")
```

### TypeScript SMTP Example

```typescript
import nodemailer from "nodemailer";

// Your credentials from AgentMail Console
const inboxEmail = "myinbox@agentmail.to"; // From Dashboard → Inboxes
const apiKey = process.env.AGENTMAIL_API_KEY!; // From Dashboard → API Keys

const transporter = nodemailer.createTransport({
  host: "smtp.agentmail.to",
  port: 465,
  secure: true, // SSL required
  auth: {
    user: inboxEmail,
    pass: apiKey,
  },
});

async function sendEmail() {
  const info = await transporter.sendMail({
    from: inboxEmail, // Use your inbox email as the From address
    to: "recipient@example.com",
    subject: "Hello from AgentMail",
    text: "This is a test email sent via SMTP.",
  });
  console.log("Email sent:", info.messageId);
}

sendEmail().catch(console.error);
```

## Troubleshooting

| Error                   | Cause                   | Solution                                               |
| ----------------------- | ----------------------- | ------------------------------------------------------ |
| "Authentication failed" | Invalid credentials     | Verify your inbox email and API key from the console   |
| "Connection refused"    | SSL not enabled         | Enable SSL/TLS in your client settings                 |
| "Connection timeout"    | Firewall blocking ports | Ensure ports 993 (IMAP) and 465/587 (SMTP) are open    |
| "Sender not authorized" | Wrong From address      | Use your inbox's email address as the From address     |
| "Folder not found"      | Non-INBOX folder        | Only INBOX is supported; use the API for other folders |

## When to Use IMAP/SMTP vs API

| Use Case                    | Recommendation |
| --------------------------- | -------------- |
| Email client integration    | IMAP/SMTP      |
| Simple programmatic sending | SMTP           |
| Full inbox management       | API            |
| Real-time notifications     | API (Webhooks) |
| Access to all folders       | API            |
| Bulk operations             | API            |


# Using Custom Domains

> A step-by-step guide to configuring your custom domain with AgentMail for enhanced branding and trust.

## Why Use a Custom Domain?

When you're deploying AI agents that send email at scale, deliverability and trust are paramount. While the default `@agentmail.to` domain is great for getting started, using your own custom domains is essential for production applications. It gives you control over your sending reputation and enables advanced strategies for high-volume outreach.

<CardGroup>
  <Card title="Improved Deliverability" icon="fa-solid fa-envelope-circle-check">
    Each domain builds its own sending reputation. By using your own domain, you
    control this reputation, which is the single most important factor in
    reaching the inbox.
  </Card>

  <Card title="Scale with Multiple Domains" icon="fa-solid fa-network-wired">
    For high-volume sending, register multiple domains (e.g., `mercor.com`,
    `usemercor.com`, `mercorapp.com`). Spreading email volume across them is a
    key strategy to maximize deliverability.
  </Card>
</CardGroup>

## Setting Up Your Custom Domain

Configuring your domain is a three-step process: add the domain via API, copy the provided records into your DNS provider, and wait for verification.

<Steps>
  <Step title="1. Create Domain & Get DNS Records">
    Choose your preferred method to create a domain and get the required DNS records. AgentMail will register your domain and immediately return the full set of DNS records required for verification.

    <Tabs>
      <Tab title="Console">
        Navigate to the [AgentMail Console](https://console.agentmail.to) and follow these steps:

        1. **Go to Domains Section**: Click on "Domains" in the left sidebar
        2. **Add New Domain**: Click "Add Domain" or "Create Domain" button
        3. **Enter Domain Name**: Type your domain name (e.g., `your-domain.com`)
        4. **Create Domain**: Click "Create" to register the domain
      </Tab>

      <Tab title="SDK">
        <CodeBlocks>
          ```bash title="cURL"
          curl -X POST https://api.agentmail.to/domains/your-domain.com \
            -H "Authorization: Bearer YOUR_API_KEY" \
            -H "Content-Type: application/json"
          ```

          ```python title="Python"
          from agentmail import AgentMail

          client = AgentMail(api_key="YOUR_API_KEY")

          # Create domain with default settings
          domain = client.domains.create("your-domain.com")

          # Or with custom feedback forwarding
          domain = client.domains.create(
            "your-domain.com",
            feedback_enabled=False
          )

          print("Domain created:", domain)
          print("DNS Records:", domain.records)
          ```

          ```typescript title="TypeScript"
          import { AgentMailClient } from "agentmail";

          const client = new AgentMailClient({
            apiKey: "YOUR_API_KEY",
          });

          // Create domain with default settings
          const domain = await client.domains.create("your-domain.com");

          // Or with custom feedback forwarding
          const domain = await client.domains.create("your-domain.com", {
            feedback_enabled: false
          });

          console.log("Domain created:", domain);
          console.log("DNS Records:", domain.records);
          ```
        </CodeBlocks>

        <Callout type="info" title="Idempotent Requests">
          You can make these requests idempotent by including a `client_id`
          attribute in the request so we dont serve an error if you try and create a
          domain that has already been registered with us.
        </Callout>

        <Callout type="info" title="Feedback Forwarding">
          By default, bounce and complaint notifications are sent to your domain. You
          can disable this by setting `feedback_enabled` to `false` in your request. If
          not specified it is default set to `true`
        </Callout>

        The API response includes a `records` array. Each object in this array contains the precise `name`, `type`, `value`, and `priority` you'll need to add to your DNS provider.

        The initial `status` of the domain will be `pending`. It will change as you configure your domain and we verify it on our end.
      </Tab>
    </Tabs>
  </Step>

  <Step title="2. Add Records to Your DNS Provider">
    The process for adding records varies slightly between providers. The examples below assume you are configuring records in the apex `domain.com` hosted zone. If you are using a subdomain make sure it is in the apex domain hosted zone.

    ### Option A: Upload BIND Zone File (Easiest)

    A BIND zone file is a text file that contains DNS resource records in a standardized format. This approach allows you to bulk upload our records to your DNS provider without you needing to go down one by one.

    **How to use the BIND zone file:**

    **Step 1: Download the BIND zone file**

    After creating your domain in the AgentMail Console, click the "Download BIND Zone File" button to get the complete zone file.

    <Frame caption="Downloading BIND zone file from AgentMail Console">
      <img src="https://files.buildwithfern.com/https://agentmail-production.docs.buildwithfern.com/faac7775a4d3462c040390f8427b67a3d0ab59a811489e773739e6c973418123/assets/download-zone-file.png" alt="Download BIND Zone File from Console" />
    </Frame>

    <Tabs>
      <Tab title="Cloudflare">
        **Step 2: Import to Cloudflare**

        1. Go to your Cloudflare dashboard and select your domain
        2. Navigate to **DNS > Records**

        <Frame caption="This is what the page looks like">
          <img src="https://files.buildwithfern.com/https://agentmail-production.docs.buildwithfern.com/96c7605681eb665155d04a7df0a8cd58830fe147270cabdec3b05797cb993899/assets/cloudflare-dns.png" alt="Cloudflare BIND Import" />
        </Frame>

        3. Click **"Import and Export"**

        <Frame caption="You should be able to just drop the file in">
          <img src="https://files.buildwithfern.com/https://agentmail-production.docs.buildwithfern.com/05cc3ce3579576efb2e81419b9a3f66d79c1cd5b0ec684d070b55762ffade22a/assets/cloudflare-import-export.png" alt="Cloudflare BIND Import" />
        </Frame>

        4. Upload the downloaded BIND zone file as is
      </Tab>

      <Tab title="AWS Route 53">
        **Step 2: Import to Route 53**

        1. Go to your Route 53 hosted zone for your domain
        2. Click **"Import zone file"** in the top right corner

        <Frame caption="Importing BIND zone file in AWS Route 53">
          <img src="https://files.buildwithfern.com/https://agentmail-production.docs.buildwithfern.com/036c4079abf5da1f8f4bb3aaa5b444b59f0be8077b4f2c3e718746aff5c06751/assets/aws-bind-import.png" alt="AWS Route 53 BIND Import" />
        </Frame>

        3. Paste the CONTENTS of downloaded BIND zone file

        <Frame caption="Open the file with text editor and paste the contents. It should look similar to what we have in this image.">
          <img src="https://files.buildwithfern.com/https://agentmail-production.docs.buildwithfern.com/0ddc3eaa3744f03f776a832f09d236312b33a0c8f40d1804a84e70c75a3b5896/assets/aws-paste.png" alt="AWS Route 53 BIND Import" />
        </Frame>

        4. Review the records and click **"Import"**

        <Warning title="CRITICAL: Route 53 TXT Record 255 Character Limit">
          **AWS Route 53 has a 255 character maximum per string.** It will get angry at the DKIM record since it is longer than 255 chars (we use more secure encryption key so we get better deliverability with Gmail!)

          **When entering TXT values in the Route 53 UI, you MUST do the following.**

          1. Split the value into two quoted strings.
             a. e.g.: "abcd" -> "ab""cd"
          2. Ensure there is NO SPACE between the quoted strings. This will make or break validation.

          **Correct:** `"first-part-of-value""second-part-of-value"`

          **Wrong:** `"first-part-of-value" "second-part-of-value"` (space between strings)

          If you accidentally include a space or click enter, Route 53 will create **two separate TXT records** instead of one concatenated record. This will cause email authentication to fail, and providers like **Gmail will reject your emails**.
        </Warning>
      </Tab>

      <Tab title="Porkbun">
        **Step 2: Import to Porkbun**

        1. Go to your Porkbun profile and click domain management
        2. Navigate to the **DNS** subtab of the domain you want to send from

        <Frame caption="Click on this button!">
          <img src="https://files.buildwithfern.com/https://agentmail-production.docs.buildwithfern.com/e4ed50d2d850209bc7eaba74f70e49de1e236816cf9a8b0ee1a244c76dee2714/assets/porkbun-dns.png" alt="Porkbun DNS Management" />
        </Frame>

        3. Scroll down to the quick upload section

        <Frame caption="Upload your BIND zone file here">
          <img src="https://files.buildwithfern.com/https://agentmail-production.docs.buildwithfern.com/139296cc33927d5d3c4e6e493ed61545914dec905b620a0d6a5408f3010f8e95/assets/porkbun-import.png" alt="Porkbun Zone File Import" />
        </Frame>

        4. Upload the downloaded BIND zone file as is

        {" "}

        <Warning type="warning" title="Important: Review Before Importing">
          Uploading a BIND zone file in Porkbun REPLACES the existing records you have.
          This is fine if this is a fresh domain you bought for the sake of sending
          email but if this is a domain that has other important records configured,
          consider adding [additional records
          manually](#option-b-add-individual-records).
        </Warning>
      </Tab>
    </Tabs>

    <Callout type="info" title="BIND Zone File Format">
      Check that all records (TXT, MX) have been correctly imported in the
      console(the console will show in real time if we can find the records,
      typically within seconds).
    </Callout>

    ### Option B: Add Individual Records

    Below are detailed instructions for AWS Route53, CloudFlare, and Namecheap. The instructions vary depending on whether you're using the AgentMail Console or the API directly.

    <Tabs>
      <Tab title="Via Console">
        If you created your domain through the [AgentMail Console](https://console.agentmail.to), the DNS records are displayed in a simplified format that's ready for copy-paste into your DNS provider.

        <Tabs>
          <Tab title="Cloudflare">
            In the dashboard (**DNS > Records**), click **"Add record"**.

            * **TXT (DMARC/SPF/DKIM):**
              * **Name:** Copy the **Name** value directly from the console.
              * **Content:** Copy the **Value** from the console.

            * **MX:**
              * **Name:** Enter `@` to apply the record to the root domain.
              * **Mail server:** Copy the **Value** from the console.
              * **Priority:** Use the priority shown in the console.
          </Tab>

          <Tab title="AWS Route 53">
            In your hosted zone, click **"Create record"**.

            * **TXT (DMARC/SPF):**
              * **Record name:** Copy the **Name** value directly from the console (e.g., `_dmarc` or `mail` or `agentmail._domainkey`).
              * **Value:** Copy the **Value** from the console, ensuring it is enclosed in quotes.

            <Warning title="CRITICAL: Route 53 TXT Record 255 Character Limit">
              **AWS Route 53 has a 255 character maximum per string.** It will get angry at the DKIM record since it is longer than 255 chars (we use more secure encryption key so we get better deliverability with Gmail!)

              **When entering TXT values in the Route 53 UI, you MUST do the following.**

              1. Split the value into two quoted strings.
                 a. e.g.: "abcd" -> "ab""cd"
              2. Ensure there is NO SPACE between the quoted strings. This will make or break validation.

              **Correct:** `"first-part-of-value""second-part-of-value"`

              **Wrong:** `"first-part-of-value" "second-part-of-value"` (space between strings)

              If you accidentally include a space or click enter, Route 53 will create **two separate TXT records** instead of one concatenated record. This will cause email authentication to fail, and providers like **Gmail will reject your emails**.
            </Warning>

            * **MX:**
              * **Record name:** Enter the value exactly as we return it, whether its `@` or the subdomain.
              * **Value:** Copy the **Value** from the console (e.g., `inbound-smtp.us-east-1.amazonaws.com`).
              * **Priority:** Use the priority shown in the console (typically `10`).
          </Tab>
        </Tabs>

        <Callout type="info" title="Console Advantage">
          The console automatically formats DNS record names to be relative hostnames (without the full domain), making them ready for direct copy-paste into your DNS provider. No manual parsing required!
        </Callout>
      </Tab>

      <Tab title="Via API">
        If you're using the API directly, the DNS records are returned as fully qualified domain names (FQDNs) that require some manual parsing.

        <Tabs>
          <Tab title="Cloudflare">
            In the dashboard (**DNS > Records**), click **"Add record"**.

            * **TXT (DMARC/SPF/DKIM):**
              * **Name:** Enter the part of the `name` before your root domain (e.g. `_dmarc`).
              * **Content:** Copy paste the `value` from the API response.

            * **MX:**
              * **Name:** Enter the part of the name before your root domain
              * **Mail server:** Enter the `value` from the API.
              * **Priority:** Enter the `priority` from the API.
          </Tab>

          <Tab title="AWS Route 53">
            In your hosted zone, click **"Create record"**.

            * **TXT (DMARC/SPF/DKIM):**
              * **Record name:** Enter the part of the `name` before your root domain (e.g., `_dmarc` for a `name` of `_dmarc.domain.com`, or `mail` for a `name` of `mail.domain.com`, or `agentmail._domainkey` for a `name` of agentmail.\_domainkey.agents.com).
              * **Value:** Can copy paste the`value` from the API, ensuring it is enclosed in quotes.

            <Warning title="CRITICAL: Route 53 TXT Record 255 Character Limit">
              **AWS Route 53 has a 255 character maximum per string.** It will get angry at the DKIM record since it is longer than 255 chars (we use more secure encryption key so we get better deliverability with Gmail!)

              **When entering TXT values in the Route 53 UI, you MUST do the following.**

              1. Split the value into two quoted strings.
                 a. e.g.: "abcd" -> "ab""cd"
              2. Ensure there is NO SPACE between the quoted strings. This will make or break validation.

              **Correct:** `"first-part-of-value""second-part-of-value"`

              **Wrong:** `"first-part-of-value" "second-part-of-value"` (space between strings)

              If you accidentally include a space or click enter, Route 53 will create **two separate TXT records** instead of one concatenated record. This will cause email authentication to fail, and providers like **Gmail will reject your emails**.
            </Warning>

            * **MX:**
              * **Record name:** Leave this field blank to apply the record to the root domain.
              * **Value:** This is critical. You must combine the `priority` and `value` from the API into a single string, separated by a space. For example: `10 inbound-smtp.us-east-1.amazonaws.com`.
          </Tab>
        </Tabs>
      </Tab>
    </Tabs>
  </Step>

  <Step title="3. Verify Your Domain">
    Once you've added the records, AgentMail automatically begins to check them. This can take anywhere from a few minutes to 48 hours for your DNS changes to propagate across the internet.

    Check your domain verification status in the [AgentMail Console](https://console.agentmail.to/dashboard/domains):

    1. **Navigate to Domains**: Go to the "Domains" section in the left sidebar
    2. **View Domain Status**: Find your domain in the list and check its status
    3. **Monitor Progress**: The status will update automatically as verification progresses
    4. **View Details**: Click on your domain to see detailed information about which records are verified

    The status indicators will show you exactly where you are in the process:

    * **`Not Started`**: You need to click the Verify Domain button to kick start the process
    * **`Pending`**: You still need to add or fix your DNS records
    * **`Invalid`**: Some of your records are misconfigured. Please verify you inputted them correctly.
    * **`Failed`**: Your records are correct, but our servers need a bump. Please click the verify domain button in the console.
    * **`Verifying`**: DNS records are correct, and we're authorizing the domain
    * **`Verified`**: Domain is fully verified and ready for sending
  </Step>
</Steps>

Here are instructions for some common DNS providers. This list is not exhaustive, so please consult your provider's documentation if you don't see it here.

| DNS/Hosting Provider | Documentation Link                                                                                                                                                                                                                                                                                                                                                                       |
| :------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **GoDaddy**          | [MX: Add an MX record](https://www.godaddy.com/help/add-an-mx-record-19234) <br /> [TXT: Add a TXT record](https://www.godaddy.com/help/add-a-txt-record-19232)                                                                                                                                                                                                                          |
| **DreamHost**        | [How do I add custom DNS records?](https://help.dreamhost.com/hc/en-us/articles/215414867-How-do-I-add-custom-DNS-records)                                                                                                                                                                                                                                                               |
| **Cloudflare**       | [MX: How do I add or edit mail or MX records?](https://support.cloudflare.com/hc/en-us/articles/200168806-Managing-DNS-records-in-Cloudflare) <br /> [TXT: Managing DNS records in Cloudflare](https://support.cloudflare.com/hc/en-us/articles/200168806-Managing-DNS-records-in-Cloudflare)                                                                                            |
| **HostGator**        | [Manage DNS Records with HostGator/eNom](https://www.hostgator.com/help/article/manage-dns-records-with-hostgator-enom)                                                                                                                                                                                                                                                                  |
| **Namecheap**        | [MX: How can I set up MX records required for mail service?](https://www.namecheap.com/support/knowledgebase/article.aspx/434/2237/how-can-i-set-up-mx-records-required-for-mail-service) <br /> [TXT: How do I add TXT/SPF/DKIM/DMARC records for my domain?](https://www.namecheap.com/support/knowledgebase/article.aspx/317/2237/how-do-i-add-txtspfdkimdmarc-records-for-my-domain) |
| **Names.co.uk**      | [Changing your domain's DNS settings](https://www.names.co.uk/support/articles/changing-your-domains-dns-settings/)                                                                                                                                                                                                                                                                      |
| **Wix**              | [MX: Adding or Updating MX Records in Your Wix Account](https://support.wix.com/en/article/adding-or-updating-mx-records-in-your-wix-account) <br /> [TXT: Adding or Updating TXT Records in Your Wix Account](https://support.wix.com/en/article/adding-or-updating-txt-records-in-your-wix-account)                                                                                    |

<Callout type="success" title="Ready to Go!" icon="fa-solid fa-rocket">
  Once your domain status is `ready`, you can start creating `Inboxes` with your
  custom domain and building your agents!
</Callout>

## Troubleshooting Common DNS Issues

DNS can be tricky. Here are some common issues and how to resolve them.

<AccordionGroup>
  <Accordion title="My DNS changes aren't showing up instantly">
    DNS propagation can take up to 48 hours, though it's often much faster. If
    it's been a while, click the verify domain button in the console which will trigger a reverification manually(DNS propagation can get stuck at times).
  </Accordion>

  <Accordion title="I'm seeing 'Too many SPF records' errors">
    A domain must have only **one** SPF record. If you're using other services that send email on your behalf (like a CRM), you need to merge their SPF policies with AgentMail's into a single record.

    An SPF record is a single line of text. It starts with `v=spf1` and ends with a mechanism like `~all` or `-all`. All your permitted senders go in the middle.

    **How to Merge:**

    1. **Find your existing SPF record.** It will look something like this: `v=spf1 include:_spf.other-domain.com ~all`
    2. **Find AgentMail's SPF include.** This is `include:spf.agentmail.to`.
    3. **Combine them.** Copy the `include` from AgentMail and place it into your existing record, right before the `~all` or `-all` part.

    <CodeBlocks>
      ```text title="Example: Merging SPF records"
      # Before
      v=spf1 include:_spf.other-domain.com ~all

      # After
      v=spf1 include:_spf.other-domain.com include:spf.agentmail.to ~all
      ```
    </CodeBlocks>

    Just keep adding `include:` mechanisms for each service you use. Remember to only have one `v=spf1` at the beginning and one `~all` or `-all` at the end.
  </Accordion>
</AccordionGroup>

{/* The user will write this section themselves. */}

## Best Practices for Domain Management

Check out our guide on [Email Deliverability](/email-deliverability) for tips on warming up your new domain and maintaining a healthy sender reputation.


# Managing Your Domains

> Learn how to manage your custom domains effectively using AgentMail's API for enhanced deliverability and reputation management.

## From Setup to Strategy

You've successfully set up your first custom domain—now what?

## Core Domain Operations via API

Your domains are resources that can be fully managed through the API. Here are the core operations you'll use.

<AccordionGroup>
  <Accordion title="List All Your Domains">
    To get a complete overview of all the domains registered in your organization, use the `GET /domains` endpoint. This is useful for auditing your assets and programmatic checks.

    <EndpointRequestSnippet endpoint="GET /domains" title="List All Domains" />
  </Accordion>

  <Accordion title="Check Domain Health">
    DNS records can sometimes be accidentally changed or deleted, impacting your ability to send or receive email. You should periodically monitor the health of your domains by polling the `GET /domains/{domain}` endpoint.

    Pay close attention to the `status` field for both the domain and its individual records. If a record's status changes from `verified` to `missing`, it needs immediate attention.

    <EndpointRequestSnippet endpoint="GET /domains/{domain}" title="Check a Specific Domain" />
  </Accordion>

  <Accordion title="Delete a Domain">
    If you no longer need a domain, you can remove it using the `DELETE /domains/{domain}` endpoint.

    <Callout type="danger">
      **This action is permanent and cannot be undone.** Deleting a domain will immediately prevent any inboxes associated with it from sending or receiving email. BUT you will still have access to the data in these inboxes.
    </Callout>

    <EndpointRequestSnippet endpoint="DELETE /domains/{domain}" title="Delete a Domain" />
  </Accordion>
</AccordionGroup>

## Advanced Strategies for Agent Fleets

As you scale, your domain strategy must evolve beyond a single domain. A sophisticated approach is crucial for deliverability, security, and resilience.

### Strategy 1: Isolate Reputations with Subdomains

Different agents have different sending patterns and risk profiles. A transactional agent sending receipts is low-risk, while a cold outreach agent is high-risk. Mixing their traffic on the same domain means the high-risk agent can damage the reputation of the critical transactional one.

**The Solution:** Segment agents onto different subdomains to isolate their sending reputations.

* **`billing.your-company.com`**: For critical transactional agents (receipts, invoices).
* **`outreach.your-company.com`**: For high-volume sales or marketing agents.
* **`support.your-company.com`**: For customer service and support agents.

### Strategy 2: Scale Deliverability with Domain Pooling

When sending at a very high scale, even a perfectly warmed-up domain has a daily sending limit before providers start throttling. The professional-grade solution is "domain pooling."

Instead of relying on one domain, you build a pool of multiple root domains (e.g., `company.com`, `company.net`, `get-company.com`).

**The Solution:** Programmatically spread your email volume across this pool.

* Maintain an array of your sending domains in your application.
* When sending a large batch of emails, rotate through the array to assign the sending inbox.
* This diversification significantly improves inbox placement at scale and makes your system more resilient if one domain's reputation is temporarily impacted.

## Leveraging DMARC for Security

By default, AgentMail configures your domain with a strict DMARC policy (`p=reject`). This is the best possible setting for security, as it tells receiving mail servers to block any email that fails authentication.

However, this is obviously up to your discretion if you want to impose a more relaxed DMARC policy, whether its `p=none` where it doesn't do anything if both SPF and DMARC fail, or its `p=quarantine`, where it puts the mail in spam/junk. Feel free to do more research at your own discretion. You can do this by changing the value in the TXT record in your DNS configuration where the name starts with `_dmarc`.


# Integrate LiveKit Agents

> A step-by-step guide to integrate with the LiveKit Agents SDK.

## Overview

This guide walks you through building a voice assistant with real time email capabilites. We use the LiveKit Agents SDK to build the voice functionality.

## Prequisites

Follow the [LiveKit voice AI quickstart](https://docs.livekit.io/agents/start/voice-ai/) to build a simple voice assistant. In this guide we will extend the functionality to this assistant to email.

You should have a file named `agent.py` which we will modify.

## Setup

Install python packages

```shell
pip install agentmail agentmail-toolkit
```

Set environment variables

```env
AGENTMAIL_API_KEY=<Your AgentMail API key>
AGENTMAIL_USERNAME=<Choose a username for your agent's inbox>
```

## Code

To the `agent.py` file add the following imports

```python
import os
import asyncio

from agentmail import AgentMail, AsyncAgentMail, Subscribe, MessageReceivedEvent
from agentmail_toolkit.livekit import AgentMailToolkit
```

Then add the `EmailAssistant` class

```python
class EmailAssistant(Agent):
    inbox_id: str
    ws_task: asyncio.Task | None = None

    def __init__(self) -> None:
        client = AgentMail()

        # By setting the client_id the inbox is created only once.
        username = os.getenv("AGENTMAIL_USERNAME")
        inbox = client.inboxes.create(username=username, client_id=f"{username}-inbox")

        self.inbox_id = inbox.inbox_id

        super().__init__(
            instructions=f"""
            You are a helpful voice and email AI assistant. Your name is AgentMail. You can receive emails at {self.inbox_id}. You can also send and reply to emails.
            When using email tools, use "{self.inbox_id}" as the inbox_id parameter. When writing emails, include "AgentMail" in the signature.
            Always speak in English.
            IMPORTANT: {self.inbox_id} is your inbox, not the user's inbox.
            """,
            # The AgentMail Toolkit has ready-to-go tools for LiveKit agents.
            tools=AgentMailToolkit(client=client).get_tools(
                [
                    "list_threads",
                    "get_thread",
                    "get_attachment",
                    "send_message",
                    "reply_to_message",
                ]
            ),
        )

    async def _websocket_task(self):
        # Open a websocket connection to AgentMail.
        async with AsyncAgentMail().websockets.connect() as socket:
            # Subscribe to events from the inbox.
            await socket.send_subscribe(Subscribe(inbox_ids=[self.inbox_id]))

            while True:
                data = await socket.recv()

                # If a message is received by the inbox, interrupt the current conversation and generate a reply.
                if isinstance(data, MessageReceived):
                    self.session.interrupt()

                    await self.session.generate_reply(
                        instructions=f"""Say "I've received an email" and then read the email.""",
                        user_input=data.message.model_dump_json(),
                    )

    # Open the websocket connection and generate a greeting when the agent enters the call.
    async def on_enter(self):
        self.ws_task = asyncio.create_task(self._websocket_task())

        await self.session.generate_reply(
            instructions=f"""In English, greet the user, introduce yourself as AgentMail, inform them that you can "receive emails" at {self.inbox_id}, and offer your assistance.""",
            allow_interruptions=False,
        )

    # Close the websocket connection when the agent exits the call.
    async def on_exit(self):
        if self.ws_task:
            self.ws_task.cancel()
```

Finally update the `entrypoint` function

```python
await session.start(
    room=ctx.room,
    agent=EmailAssistant(),  # Replace Assistant with EmailAssistant.
    room_input_options=RoomInputOptions(
        noise_cancellation=noise_cancellation.BVC()
    ),
)
```

## That's It

Run your agent inside the terminal and send it an email

```shell
python agent.py console
```


# Webhooks Overview

> Learn how to use Webhooks to build responsive, event-driven email agents with AgentMail.

Webhooks are the best way to get real-time information about what's happening with your emails. Instead of constantly asking the AgentMail API if there's a new email (a process called polling), you can register a URL, and we will send you a `POST` request with the details as soon as an event happens.

This event-driven approach is more efficient and allows you to build fast, responsive agents that can react instantly to incoming messages.

## Why Use Webhooks?

* **Real-Time Speed:** Build conversational agents that can reply to incoming emails in seconds.
* **Efficiency:** Eliminates the need for constant polling, which saves you computational resources and simplifies your application logic.

## The Webhook Workflow

The process is straightforward:

<Steps>
  <Step title="1. Create a Webhook Endpoint">
    This is a public URL on your server that can accept `POST` requests. For local development, a tool like `ngrok` is perfect for creating a secure, public URL that tunnels to your local machine. Your endpoint should immediately return a `200 OK` response to acknowledge receipt and process the payload in the background to avoid timeouts.
  </Step>

  <Step title="2. Register the Endpoint with AgentMail">
    You can register your URL using the AgentMail API. When you create a webhook, you'll specify your endpoint's URL as well as event types you want to receive.

    <CodeBlocks>
      ```python
      client.webhooks.create(
          url="https://<your-ngrok-url>.ngrok-free.app/webhooks"
      )
      ```

      ```typescript
      await client.webhooks.create({
          url: "https://<your-ngrok-url>.ngrok-free.app/webhooks",
      });
      ```
    </CodeBlocks>
  </Step>

  <Step title="3. AgentMail Sends Events">
    When a new message is received in one of your inboxes, AgentMail will immediately send a `POST` request with a JSON payload to your registered URL.
  </Step>
</Steps>

## Payload Structure

When AgentMail sends a webhook, the payload will have the following structure.

```json Webhook Payload
{
  "event_type": "message.received",
  "event_id": "evt_123abc...",
  "message": {
    "from_": ["sender@example.com"],
    "organization_id": "org_abc123...",
    "inbox_id": "inbox_def456...",
    "thread_id": "thd_ghi789...",
    "message_id": "msg_jkl012...",
    "labels": ["received"],
    "timestamp": "2023-10-27T10:00:00Z",
    "reply_to": ["reply-to@example.com"],
    "to": ["recipient@example.com"],
    "cc": ["cc-recipient@example.com"],
    "bcc": ["bcc-recipient@example.com"],
    "subject": "Email Subject",
    "preview": "A short preview of the email text...",
    "text": "The full text body of the email.",
    "html": "<html>...</html>",
    "attachments": [
      {
        "attachment_id": "att_pqr678...",
        "filename": "document.pdf",
        "content_type": "application/pdf",
        "size": 123456,
        "inline": false
      }
    ],
    "in_reply_to": "msg_parent456...",
    "references": ["msg_ref1...", "msg_ref2..."],
    "sort_key": "some-sort-key",
    "updated_at": "2023-10-27T10:00:05Z",
    "created_at": "2023-10-27T10:00:00Z"
  }
}
```

### Field Descriptions

* **`event_type`** (`string`): The name of the event. Currently, this will always be `message.received`.
* **`event_id`** (`string`): A unique identifier for this specific event delivery.
* **`message`** (`object`): A dictionary containing the full details of the received email message.
  * **`from_`** (`array<string>`): The sender's email address. Note the trailing underscore to avoid conflict with the Python keyword.
  * **`organization_id`** (`string`): The ID of your organization.
  * **`inbox_id`** (`string`): The ID of the inbox that received the message.
  * **`thread_id`** (`string`): The ID of the conversation thread.
  * **`message_id`** (`string`): The unique ID of this specific message.
  * **`labels`** (`array<string>`): Labels associated with the message (e.g., `received`, `sent`).
  * **`subject`** (`string`): The subject line of the email.
  * **`preview`** (`string`): A short plain-text preview of the email body.
  * **`text`** (`string`): The full plain-text body of the email.
  * **`html`** (`string`): The full HTML body of the email, if present.
  * **`attachments`** (`array<object>`): A list of attachments, each with its own `attachment_id`, `filename`, `content_type`, `size`, and `inline` status.
  * **`in_reply_to`** (`string`): The `message_id` of the email this message is a reply to, if applicable.

## Next Steps

<CardGroup>
  <Card title="Webhook Events" href="/events">
    Explore the full list of available event types and their data payloads.
  </Card>

  <Card title="Verifying Webhooks" href="/webhook-verification">
    Learn how to verify webhook signatures to secure your endpoints.
  </Card>

  <Card title="Example: Event-Driven Agent" href="/github-star-agent">
    Build a fully deployable, event-driven agent that can respond to emails in
    real time.
  </Card>
</CardGroup>


# Webhook Events

As mentioned in the overview, webhooks allow us to create event-driven applications.

AgentMail supports multiple event types that allow you to build comprehensive, event-driven workflows for your email agents.

All webhook payloads follow the same basic structure:

```json
{
  "type": "event",
  "event_type": "event.name",
  "event_id": "evt_123abc..."
  // ... event-specific data object
}
```

## Message Events

### `message.received`

* **Description:** Triggered whenever a new email is successfully received and processed in one of your `Inboxes`. This is the most common trigger to kick off agent workflows.
* **Example use-case:** Kick off a internal workflow when a customer complaint email hits the support inbox

<Callout>
  Something here to notice is message.received is the only webhook event that
  includes both the metadata on the `Thread` and the `Message` in the payload.
  Other event types send only metadata on the event. Let us know if you need
  metadata on other event types by emailing `support@agentmail.cc`
</Callout>

<CodeGroup>
  ```json
  {
    "type": "event",
    "event_type": "message.received",
    "event_id": "evt_123abc",
    "message": {
      "inbox_id": "inbox_456def",
      "thread_id": "thd_789ghi",
      "message_id": "msg_123abc",
      "labels": ["received"],
      "timestamp": "2023-10-27T10:00:00Z",
      "from": [
        {
          "name": "Jane Doe",
          "email": "jane@example.com"
        }
      ],
      "to": [
        {
          "name": "Support Agent",
          "email": "support@agentmail.to"
        }
      ],
      "subject": "Question about my account",
      "preview": "A short preview of the email text...",
      "text": "The full text body of the email.",
      "html": "<html>...</html>",
      "created_at": "2023-10-27T10:00:00Z"
    },
    "thread": {
      // ... thread properties
    }
  }
  ```
</CodeGroup>

### `message.sent`

* **Description:** Triggered when a message is successfully sent from one of your `Inboxes`.
* **Use Case:** Track outgoing messages, update your database, or trigger follow-up workflows after sending.

<CodeGroup>
  ```json
  {
    "type": "event",
    "event_type": "message.sent",
    "event_id": "evt_456def",
    "send": {
      "inbox_id": "inbox_456def",
      "thread_id": "thd_789ghi",
      "message_id": "msg_123abc",
      "timestamp": "2023-10-27T10:05:00Z",
      "recipients": [
        "recipient@example.com"
      ]
    }
  }
  ```
</CodeGroup>

### `message.delivered`

* **Description:** Triggered when a sent message is successfully delivered to the recipient's mail server.
* **Use Case:** Confirm successful delivery, update message status, or trigger delivery confirmation workflows.

<CodeGroup>
  ```json
  {
    "type": "event",
    "event_type": "message.delivered",
    "event_id": "evt_789ghi",
    "delivery": {
      "inbox_id": "inbox_456def",
      "thread_id": "thd_789ghi",
      "message_id": "msg_123abc",
      "timestamp": "2023-10-27T10:06:00Z",
      "recipients": [
        "recipient@example.com"
      ]
    }
  }
  ```
</CodeGroup>

<AccordionGroup>
  <Accordion title="What is the difference between `message.sent` and `message.delivered?`" defaultOpen={true}>
    `message.sent` means the message has successfully left our servers and is out
    to travel the network. This typically happens before `message.delivered`
    where `message.delivered` means the receiving email server (whether it's Gmail
    or Outlook) gives us the `200 OK` saying the email has been received. What
    they do with the email after is unknown.
  </Accordion>

  <Accordion title="Does `message.delivered` mean I landed in their inbox?">
    Nope. As mentioned `message.delivered` means the receiving email server,
    whether it's Gmail or Outlook tells us "Hey AgentMail, we got your email,
    we'll take it from here!". They typically have their own proprietary
    algorithms to determine whether the email is going to end up in the inbox or
    spam, but rest assured we handle everything needed for providers like Gmail
    to deem the emails primary inbox worthy
  </Accordion>
</AccordionGroup>

### `message.bounced`

* **Description:** Triggered when a sent message fails to deliver and bounces back. Includes bounce type and sub-type information.
* **Use Case:** Handle bounced emails, update recipient status, or trigger bounce handling workflows.

<CodeGroup>
  ```json
  {
    "type": "event",
    "event_type": "message.bounced",
    "event_id": "evt_012jkl",
    "bounce": {
      "inbox_id": "inbox_456def",
      "thread_id": "thd_789ghi",
      "message_id": "msg_123abc",
      "timestamp": "2023-10-27T10:07:00Z",
      "type": "Permanent",
      "sub_type": "General",
      "recipients": [
        {
          "address": "invalid@example.com",
          "status": "bounced"
        }
      ]
    }
  }
  ```
</CodeGroup>

### `message.complained`

* **Description:** Triggered when a recipient marks your message as spam or files a complaint.
* **Use Case:** Handle spam complaints, update sender reputation, or trigger complaint handling workflows.

<CodeGroup>
  ```json
  {
    "type": "event",
    "event_type": "message.complained",
    "event_id": "evt_345mno",
    "complaint": {
      "inbox_id": "inbox_456def",
      "thread_id": "thd_789ghi",
      "message_id": "msg_123abc",
      "timestamp": "2023-10-27T10:08:00Z",
      "type": "abuse",
      "sub_type": "spam",
      "recipients": [
        "complainer@example.com"
      ]
    }
  }
  ```
</CodeGroup>

### `message.rejected`

* **Description:** Triggered when a message is rejected before being sent, typically due to validation errors or policy violations.
* **Use Case:** Handle rejected messages, log rejection reasons, or trigger validation workflows.

<CodeGroup>
  ```json
  {
    "type": "event",
    "event_type": "message.rejected",
    "event_id": "evt_678pqr",
    "reject": {
      "inbox_id": "inbox_456def",
      "thread_id": "thd_789ghi",
      "message_id": "msg_123abc",
      "timestamp": "2023-10-27T10:09:00Z",
      "reason": "Invalid recipient address"
    }
  }
  ```
</CodeGroup>

<Warning>
  If you send an email to a `bounced` address, `rejected` address, or
  `complained` address we prevent you from sending to this email address ever
  again to keep bounce rates low. Make sure to keep your account bounce rate
  under 4%, otherwise we will put your account under review.
</Warning>

## Domain Events

### `domain.verified`

* **Description:** Triggered when a domain is successfully verified and ready to use for sending emails.
* **Use Case:** Automatically enable domain-specific features, update domain status, or trigger post-verification workflows.

<CodeGroup>
  ```json
  {
    "type": "event",
    "event_type": "domain.verified",
    "event_id": "evt_901stu",
    "domain": {
      "domain_id": "dom_123abc",
      "status": "verified",
      "feedback_enabled": true,
      "records": [
        // ... DNS verification records
      ],
      "created_at": "2023-10-27T09:00:00Z",
      "updated_at": "2023-10-27T10:00:00Z"
    }
  }
  ```
</CodeGroup>

## Event Filtering

When creating a webhook, you can specify which events to subscribe to. This allows you to:

* Reduce webhook traffic by only subscribing to events you need
* Create specialized webhooks for specific workflows

For example, if you only need to trigger workflows on incoming messages, you can subscribe to just `message.received`. If you're building a delivery tracking system, you might subscribe to `message.sent`, `message.delivered`, and `message.bounced`.

If you have any specific webhook notifications you would like, please ping us in the `#feature-requests` channel in the [Discord](https://discord.gg/hTYatWYWBc)


# Webhook Setup Guide

> A comprehensive guide to setting up webhooks with ngrok and AgentMail, including account creation, inbox setup, and code examples.

This guide walks you through the complete process of setting up webhooks to receive real-time notifications from AgentMail. You'll learn how to create an ngrok account, set up an inbox, configure webhooks, and write a simple webhook receiver.

## Prerequisites

Before you start, make sure you have:

* Python 3.8 or higher installed
* An [AgentMail API Key](https://docs.agentmail.to/quickstart#step-3-create-an-api-key)
* `pip` package manager
* Basic familiarity with Python and terminal commands

## Installation

First, install the required Python packages:

```bash
pip install agentmail flask ngrok
```

## Step 1: Setting up account on Ngrok

Ngrok creates a secure tunnel from a public URL to your local development server, allowing AgentMail to send webhooks to your machine during development.

### 1.1 Create an ngrok account

Visit [ngrok.com](https://ngrok.com/) and click "Sign up" to create a free account.

<img src="https://files.buildwithfern.com/https://agentmail-production.docs.buildwithfern.com/2d257d7065229b8ebd74abd4f96802eb8eb4f5b04041bbf28a5015a9d171a4ab/assets/webhook-ngrok.png" alt="Ngrok homepage" />

### 1.2 Choose your platform and install

After logging in, ngrok will guide you through the setup process. Select your operating system and follow the installation instructions.

<img src="https://files.buildwithfern.com/https://agentmail-production.docs.buildwithfern.com/f1ecdd69a4ef981c9e2f04c4118cad618f81b7dde98cb6de3c6f4f9a69311c79/assets/webhook-system.png" alt="Ngrok setup instructions" />

For macOS, you can install ngrok via Homebrew:

```bash
brew install ngrok
```

After installation, authenticate ngrok with your authtoken (found in your ngrok dashboard):

```bash
ngrok config add-authtoken YOUR_AUTHTOKEN
```

## Step 2: Creating the inbox on AgentMail

Before you can receive webhooks, you need an inbox to receive messages. Create one using the AgentMail API:

```python
from agentmail import AgentMail

client = AgentMail()

# Create an inbox for your webhook agent
inbox = client.inboxes.create(
    username="webhook-demo",
    client_id="webhook-demo-inbox"  # Ensures idempotency
)

print(f"Inbox created: {inbox.inbox_id}")
```

The `client_id` parameter ensures that running this code multiple times won't create duplicate inboxes. If the inbox already exists, it will return the existing one.

## Step 3: Configuring webhook on AgentMail

### 3.1 Start ngrok tunnel

In your terminal, start an ngrok tunnel to expose your local server (we'll use port 3000):

```bash
ngrok http 3000
```

You should see output similar to this:

<img src="https://files.buildwithfern.com/https://agentmail-production.docs.buildwithfern.com/c0d9867ce68c17edeea7a4e7bc2204c38c2cb9a3a819fe68199c542d28293dd1/assets/webhook-console.png" alt="Ngrok terminal output" />

Copy the **Forwarding URL** (e.g., `https://your-subdomain.ngrok-free.app`). This is the public URL that AgentMail will use to send webhooks.

<Callout intent="info" title="Use localhost for testing">
  When viewing your webhook receiver in the browser, use the `http://127.0.0.1:3000` URL shown in the "Web Interface" line, not the ngrok URL. The ngrok URL is only for external services like AgentMail.

  **Why localhost?** Safari is stricter than Chrome/Firefox when viewing development servers through HTTPS ngrok tunnels. Safari blocks local WebSockets and some dev-only scripts, which causes the page to show a loading spinner indefinitely due to Hot Module Replacement (HMR). This is expected development behavior and not a documentation issue. Using localhost or static builds avoids this problem.
</Callout>

### 3.2 Register webhook with AgentMail

Now register your webhook endpoint with AgentMail:

```python
# Using the ngrok URL you copied
webhook_url = "https://your-subdomain.ngrok-free.app/webhooks"

webhook = client.webhooks.create(
    url=webhook_url,
    client_id="webhook-demo-webhook"  # Ensures idempotency
)

print(f"Webhook created: {webhook.webhook_id}")
```

## Step 4: Code example for receiving webhooks

Create a file named `webhook_receiver.py` with the following code:

```python
from flask import Flask, request, Response

app = Flask(__name__)

@app.route('/')
def home():
    """Status page to verify server is running"""
    return """
    <html>
    <body style="font-family: sans-serif; max-width: 800px; margin: 50px auto; padding: 20px;">
        <h1>AgentMail Webhook Receiver</h1>
        <div style="background: #4CAF50; color: white; padding: 10px 20px;
                    border-radius: 4px; display: inline-block; margin: 20px 0;">
            Server is running
        </div>
        <div style="background: #e3f2fd; padding: 15px; border-radius: 4px;
                    border-left: 4px solid #2196F3;">
            <h3>Webhook Endpoint Ready</h3>
            <p>Your webhook endpoint is listening at: <code>POST /webhooks</code></p>
        </div>
        <h3>How to use:</h3>
        <ul>
            <li>Start ngrok: <code>ngrok http 3000</code></li>
            <li>Register your webhook with AgentMail using the ngrok URL</li>
            <li>Send a test email to your AgentMail inbox</li>
            <li>Watch the console for incoming webhook events</li>
        </ul>
    </body>
    </html>
    """

@app.route('/webhooks', methods=['POST'])
def receive_webhook():
    """Receives webhook events from AgentMail"""
    payload = request.json

    event_type = payload.get('event_type')
    message = payload.get('message', {})

    print(f"\nWebhook received: {event_type}")
    print(f"From: {message.get('from_')}")
    print(f"Subject: {message.get('subject')}\n")

    return Response(status=200)

if __name__ == '__main__':
    print("Starting webhook receiver on http://127.0.0.1:3000")
    app.run(port=3000)
```

### Running your webhook receiver

1. Make sure ngrok is running in one terminal window
2. In another terminal, run your webhook receiver:

```bash
python webhook_receiver.py
```

3. Send a test email to your AgentMail inbox
4. Watch the console output for incoming webhook events

### Viewing the result

Open your browser and visit `http://127.0.0.1:3000` to see the status page confirming your webhook receiver is running:

<img src="https://files.buildwithfern.com/https://agentmail-production.docs.buildwithfern.com/d7c7b41d1738e174e482ce9531f4a706e0d4da350a9ec7545215789633fb09ae/assets/webhook-result.png" alt="Webhook receiver status page" />

## Testing Your Setup

To test your webhook setup:

1. Send an email to your inbox address (e.g., `webhook-demo@agentmail.to`)
2. Check your webhook receiver's console output
3. You should see the webhook event details printed immediately

<Callout intent="success" title="Next Steps">
  Now that your webhook is working, you can extend the `receive_webhook()` function to:

  * Automatically reply to messages
  * Process attachments
  * Route emails to different handlers based on content
  * Integrate with your AI agent workflows

  Check out the [Event-Driven Agent Example](/webhook-agent) for a more advanced implementation.
</Callout>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Webhook not receiving events">
    * Verify ngrok is running and the forwarding URL matches your webhook registration
    * Check that your Flask app is running on the correct port (3000)
    * Ensure your webhook URL ends with `/webhooks`
    * Look for errors in both the Flask console and ngrok web interface
  </Accordion>

  <Accordion title="Ngrok tunnel disconnects">
    Free ngrok accounts have 2-hour session limits. The tunnel will disconnect and you'll need to restart ngrok and update your webhook URL with AgentMail.
  </Accordion>

  <Accordion title="Port already in use">
    If port 3000 is already in use, choose a different port:

    * Change the port in `app.run(port=XXXX)`
    * Update the ngrok command: `ngrok http XXXX`
  </Accordion>
</AccordionGroup>

## Production Considerations

For production deployments:

* **Use a dedicated server**: Deploy your webhook receiver to a cloud service (AWS, GCP, Heroku, etc.) instead of using ngrok
* **Implement webhook verification**: [Validate incoming requests](/webhook-verification) are authentically from AgentMail
* **Add error handling**: Implement retry logic and error reporting
* **Use async processing**: Return 200 immediately and process webhooks in background jobs
* **Monitor webhook health**: Set up logging and alerting for failed webhook deliveries

<CardGroup>
  <Card title="Verifying Webhooks" href="/webhook-verification">
    Learn how to verify webhook signatures for secure endpoints.
  </Card>

  <Card title="Webhooks Overview" href="/overview">
    Learn more about how webhooks work and their payload structure.
  </Card>

  <Card title="Webhook Events" href="/events">
    Explore the full list of webhook event types.
  </Card>
</CardGroup>


# Verifying Webhooks

> Learn how to verify webhook signatures to secure your webhook endpoints and prevent spoofed requests.

When building webhook receivers, it's critical to verify that incoming requests actually originate from AgentMail and haven't been tampered with. AgentMail uses [Svix](https://www.svix.com/) to deliver webhooks, which provides cryptographic signature verification.

## Why Verify Webhooks?

Without verification, anyone who discovers your webhook URL could send fake requests to your endpoint, potentially causing:

* **Data manipulation:** Malicious actors could trigger actions based on fake events
* **Security breaches:** Spoofed messages could inject harmful data into your systems
* **Resource exhaustion:** Attackers could flood your endpoint with fake requests

Always verify webhook signatures in production environments.

## Getting Your Signing Secret

Each webhook endpoint has a unique signing secret that you'll use to verify requests. You can find this secret in the AgentMail console when you create your webhook or by fetching your webhook details:

<CodeBlocks>
  ```python
  from agentmail import AgentMail

  client = AgentMail()

  # Get webhook details including the signing secret
  webhook = client.webhooks.get(webhook_id="ep_xxx")

  # The secret starts with "whsec_"
  signing_secret = webhook.secret
  print(f"Signing secret: {signing_secret}")
  ```

  ```typescript
  import AgentMail from "agentmail";

  const client = new AgentMail();

  // Get webhook details including the signing secret
  const webhook = await client.webhooks.get("ep_xxx");

  // The secret starts with "whsec_"
  const signingSecret = webhook.secret;
  console.log(`Signing secret: ${signingSecret}`);
  ```
</CodeBlocks>

<Callout intent="warning" title="Keep your secret safe">
  Store your signing secret securely in environment variables. Never commit it to version control or expose it in client-side code.
</Callout>

## Verification Headers

Every webhook request from AgentMail includes three headers used for verification:

| Header           | Description                                                                                   |
| ---------------- | --------------------------------------------------------------------------------------------- |
| `svix-id`        | Unique message identifier. Same ID is used for retries of the same message.                   |
| `svix-timestamp` | Unix timestamp (seconds) when the message was sent.                                           |
| `svix-signature` | Space-delimited list of signatures in the format `v1,<base64>` (e.g., `v1,abc123 v1,def456`). |

## Verifying with the Svix Library (Recommended)

The easiest way to verify webhooks is using the official Svix library, which handles all the cryptographic details for you.

<CodeBlocks>
  ```python
  import os
  from dotenv import load_dotenv
  from flask import Flask, request

  from svix.webhooks import Webhook, WebhookVerificationError

  load_dotenv()

  app = Flask(__name__)

  secret = os.environ["AGENTMAIL_WEBHOOK_SECRET"]

  @app.route('/webhooks', methods=['POST'])
  def webhook_handler():
      headers = request.headers
      payload = request.get_data()

      try:
          wh = Webhook(secret)
          msg = wh.verify(payload, headers)
      except WebhookVerificationError as e:
          return ('', 400)

      # Do something with the message...

      return ('', 204)

  if __name__ == '__main__':
      app.run(port=3000)

  ```

  ```typescript
  import "dotenv/config";
  import express, { Request, Response } from "express";
  import { Webhook } from "svix";

  const app = express();
  const port = 3000;

  const secret = process.env.AGENTMAIL_WEBHOOK_SECRET;

  if (!secret) {
    throw new Error("AGENTMAIL_WEBHOOK_SECRET environment variable is required");
  }

  app.post(
    "/webhooks",
    express.raw({ type: "application/json" }),
    (req: Request, res: Response) => {
      const payload = req.body;
      const headers = req.headers as Record<string, string>;

      try {
        const wh = new Webhook(secret);
        const msg = wh.verify(payload, headers);

        // Do something with the message...
        console.log("Webhook verified:", msg);

        res.status(204).send();
      } catch (err) {
        console.error("Webhook verification failed:", err);
        res.status(400).send();
      }
    }
  );

  app.listen(port, () => {
    console.log(`Webhook server listening on port ${port}`);
  });
  ```
</CodeBlocks>

<Callout intent="info" title="Raw body required">
  Signature verification requires the exact request body. If you're using body-parsing middleware (like `express.json()`), make sure to capture the raw body before parsing, or use `express.raw()` for your webhook endpoint.
</Callout>

## Testing Locally with ngrok

During development, you'll need a way for AgentMail to reach your local server. [ngrok](https://ngrok.com/) creates a public URL that tunnels to your local machine.

### Step 1: Save Your Webhook Server

Create a webhook server file:

<CodeBlocks>
  ```python title="webhook_server.py"
  import os
  from dotenv import load_dotenv
  from flask import Flask, request

  from svix.webhooks import Webhook, WebhookVerificationError

  load_dotenv()

  app = Flask(__name__)

  secret = os.environ.get("AGENTMAIL_WEBHOOK_SECRET")

  @app.route('/webhooks', methods=['POST'])
  def webhook_handler():
      headers = request.headers
      payload = request.get_data()

      try:
          wh = Webhook(secret)
          msg = wh.verify(payload, headers)
          print(f"Received event: {msg}")
      except WebhookVerificationError as e:
          print(f"Verification failed: {e}")
          return ('', 400)

      # Do something with the message...

      return ('', 204)

  if __name__ == '__main__':
      app.run(port=3000)
  ```

  ```typescript title="webhook_server.ts"
  import "dotenv/config";
  import express, { Request, Response } from "express";
  import { Webhook } from "svix";

  const app = express();
  const port = 3000;

  const secret = process.env.AGENTMAIL_WEBHOOK_SECRET;

  if (!secret) {
    throw new Error("AGENTMAIL_WEBHOOK_SECRET environment variable is required");
  }

  app.post(
    "/webhooks",
    express.raw({ type: "application/json" }),
    (req: Request, res: Response) => {
      const payload = req.body;
      const headers = req.headers as Record<string, string>;

      try {
        const wh = new Webhook(secret);
        const msg = wh.verify(payload, headers);

        // Do something with the message...
        console.log("Webhook verified:", msg);

        res.status(204).send();
      } catch (err) {
        console.error("Webhook verification failed:", err);
        res.status(400).send();
      }
    }
  );

  app.listen(port, () => {
    console.log(`Webhook server listening on port ${port}`);
  });
  ```
</CodeBlocks>

### Step 2: Install Dependencies and Run the Server

<CodeBlocks>
  ```bash title="Python"
  pip install flask python-dotenv svix
  python webhook_server.py
  ```

  ```bash title="TypeScript"
  npm install express svix dotenv
  npx ts-node webhook_server.ts
  ```
</CodeBlocks>

You should see output like:

<CodeBlocks>
  ```bash title="Python"
   * Serving Flask app 'webhook_server'
   * Debug mode: off
   * Running on http://127.0.0.1:3000
  Press CTRL+C to quit
  ```

  ```bash title="TypeScript"
  Webhook server listening on port 3000
  ```
</CodeBlocks>

### Step 3: Start ngrok

In a new terminal window, start ngrok to create a public tunnel to your local server:

```bash
ngrok http 3000
```

ngrok will display a forwarding URL:

```
Session Status                online
Account                       your-email@example.com (Plan: Free)
Version                       3.22.1
Region                        United States (California) (us-cal-1)
Forwarding                    https://da550b82a183.ngrok.app -> http://localhost:3000
```

Copy the `https://` forwarding URL (e.g., `https://da550b82a183.ngrok.app`).

### Step 4: Add the URL to AgentMail Console

1. Go to the [AgentMail Console](https://console.agentmail.to)
2. Navigate to **Webhooks** in the sidebar
3. Click **Create Webhook** (or edit an existing one)
4. Paste your ngrok URL with the `/webhooks` path: `https://da550b82a183.ngrok.app/webhooks`
5. Select the events you want to receive
6. Save the webhook
7. Copy the signing secret and add it to your `.env` file:

```bash
AGENTMAIL_WEBHOOK_SECRET=whsec_your_secret_here
```

### Step 5: Trigger a Test Event

Send an email to one of your AgentMail inboxes, or use the console to send a test event. You should see the webhook received in your terminal:

```
127.0.0.1 - - [19/Jan/2026 16:57:20] "POST /webhooks HTTP/1.1" 204 -
Received event: {'event_type': 'message.received', ...}
```

<Callout intent="info" title="Ready for production?">
  ngrok is great for local development, but for production you'll need to deploy your webhook server to a hosting provider. See the next section for deployment options.
</Callout>

## Deploying to Production

For production, you'll need to deploy your webhook server to a hosting provider that gives you a stable, public HTTPS URL. We recommend [Render](https://render.com/) for its simplicity and generous free tier.

<Callout intent="info" title="Other hosting options">
  You can also deploy to other platforms like [Railway](https://railway.app/), [Fly.io](https://fly.io/), [Heroku](https://heroku.com/), or any cloud provider that supports Python web applications. The key requirements are a stable public HTTPS URL and the ability to set environment variables.
</Callout>

## Best Practices

<AccordionGroup>
  <Accordion title="Always verify in production">
    While you might skip verification during local development, always enable it in production environments. A compromised webhook endpoint can be a serious security vulnerability.
  </Accordion>

  <Accordion title="Use environment variables">
    Never hardcode your signing secret. Use environment variables or a secrets manager:

    ```python
    import os
    WEBHOOK_SECRET = os.environ["AGENTMAIL_WEBHOOK_SECRET"]
    ```
  </Accordion>
</AccordionGroup>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Signature verification fails">
    * Ensure you're using the raw request body, not a parsed/modified version
    * Check that your signing secret is correct and matches the webhook endpoint
    * Verify you're extracting headers correctly (they're case-insensitive)
    * Make sure the timestamp hasn't expired (default tolerance is 5 minutes)
  </Accordion>

  <Accordion title="Missing headers">
    If headers are missing, ensure your server/framework isn't stripping them. Some reverse proxies may need configuration to pass through custom headers.
  </Accordion>

  <Accordion title="Body parsing issues">
    If you're using body-parsing middleware, make sure to access the raw body for verification. In Express, use `express.raw()` for your webhook route.
  </Accordion>
</AccordionGroup>

<CardGroup>
  <Card title="Webhook Setup" href="/webhook-setup">
    Complete guide to setting up webhooks with ngrok.
  </Card>

  <Card title="Webhook Events" href="/events">
    Explore all available webhook event types.
  </Card>
</CardGroup>


# WebSockets

> Learn how to use WebSockets for instant email notifications without webhooks or polling.

WebSockets provide a persistent, bidirectional connection to AgentMail for receiving email events in real-time. Unlike webhooks, WebSockets don't require a public URL or external tools like ngrok.

## Why Use WebSockets?

| Feature    | Webhook                     | WebSocket                |
| ---------- | --------------------------- | ------------------------ |
| Setup      | Requires public URL + ngrok | No external tools needed |
| Connection | HTTP request per event      | Persistent connection    |
| Direction  | AgentMail → Your server     | Bidirectional            |
| Firewall   | Must expose port            | Outbound only            |
| Latency    | HTTP round-trip             | Instant streaming        |

***

## Python SDK

The Python SDK provides both synchronous and asynchronous WebSocket clients.

### Async Usage

```python
import asyncio
from agentmail import AsyncAgentMail, Subscribe, Subscribed, MessageReceivedEvent

client = AsyncAgentMail(api_key="YOUR_API_KEY")

async def main():
    async with client.websockets.connect() as socket:
        # Subscribe to inboxes
        await socket.send_subscribe(Subscribe(inbox_ids=["agent@agentmail.to"]))

        # Process events as they arrive
        async for event in socket:
            if isinstance(event, Subscribed):
                print(f"Subscribed to: {event.inbox_ids}")
            elif isinstance(event, MessageReceivedEvent):
                print(f"New email from: {event.message.from_}")
                print(f"Subject: {event.message.subject}")

asyncio.run(main())
```

### Sync Usage

```python
from agentmail import AgentMail, Subscribe, Subscribed, MessageReceivedEvent

client = AgentMail(api_key="YOUR_API_KEY")

with client.websockets.connect() as socket:
    # Subscribe to inboxes
    socket.send_subscribe(Subscribe(inbox_ids=["agent@agentmail.to"]))

    # Process events as they arrive
    for event in socket:
        if isinstance(event, Subscribed):
            print(f"Subscribed to: {event.inbox_ids}")
        elif isinstance(event, MessageReceivedEvent):
            print(f"New email from: {event.message.from_}")
            print(f"Subject: {event.message.subject}")
```

### Event Handler Pattern

You can also use event handlers instead of iterating:

```python
import asyncio
from agentmail import AsyncAgentMail, Subscribe, EventType

client = AsyncAgentMail(api_key="YOUR_API_KEY")

async def main():
    async with client.websockets.connect() as socket:
        # Register event handlers
        socket.on(EventType.OPEN, lambda _: print("Connected"))
        socket.on(EventType.MESSAGE, lambda msg: print("Received:", msg))
        socket.on(EventType.CLOSE, lambda _: print("Disconnected"))
        socket.on(EventType.ERROR, lambda err: print("Error:", err))

        # Subscribe and start listening
        await socket.send_subscribe(Subscribe(inbox_ids=["agent@agentmail.to"]))
        await socket.start_listening()

asyncio.run(main())
```

For sync usage with event handlers, run the listener in a background thread:

```python
import threading
from agentmail import AgentMail, Subscribe, EventType

client = AgentMail(api_key="YOUR_API_KEY")

with client.websockets.connect() as socket:
    socket.on(EventType.OPEN, lambda _: print("Connected"))
    socket.on(EventType.MESSAGE, lambda msg: print("Received:", msg))
    socket.on(EventType.CLOSE, lambda _: print("Disconnected"))
    socket.on(EventType.ERROR, lambda err: print("Error:", err))

    socket.send_subscribe(Subscribe(inbox_ids=["agent@agentmail.to"]))

    # Start listening in background thread
    listener = threading.Thread(target=socket.start_listening, daemon=True)
    listener.start()
    listener.join()
```

***

## TypeScript SDK

The TypeScript SDK provides a WebSocket client with automatic reconnection.

### Basic Usage

```typescript
import { AgentMailClient, AgentMail } from "agentmail";

const client = new AgentMailClient({
  apiKey: process.env.AGENTMAIL_API_KEY,
});

async function main() {
  const socket = await client.websockets.connect();

  // Handle events
  socket.on("open", () => {
    console.log("Connected");

    // Subscribe to inboxes after connection is open
    socket.sendSubscribe({
      type: "subscribe",
      inboxIds: ["agent@agentmail.to"],
    });
  });

  socket.on("message", (event: AgentMail.Subscribed | AgentMail.MessageReceivedEvent) => {
    if (event.type === "subscribed") {
      console.log("Subscribed to:", event.inboxIds);
    } else if (event.type === "message_received") {
      console.log("New email from:", event.message.from_);
      console.log("Subject:", event.message.subject);
    }
  });

  socket.on("close", (event) => {
    console.log("Disconnected:", event.code, event.reason);
  });

  socket.on("error", (error) => {
    console.error("Error:", error);
  });
}

main();
```

### React/Next.js Usage

Using the SDK with React:

```typescript
import { useEffect, useState } from "react";
import { AgentMailClient, AgentMail } from "agentmail";

function useAgentMailWebSocket(apiKey: string, inboxIds: string[]) {
  const [lastMessage, setLastMessage] = useState<AgentMail.MessageReceivedEvent | null>(null);
  const [isConnected, setIsConnected] = useState(false);

  useEffect(() => {
    const client = new AgentMailClient({ apiKey });

    let socket: Awaited<ReturnType<typeof client.websockets.connect>>;

    async function connect() {
      socket = await client.websockets.connect();

      socket.on("open", () => {
        setIsConnected(true);
        socket.sendSubscribe({
          type: "subscribe",
          inboxIds,
        });
      });

      socket.on("message", (event) => {
        if (event.type === "message_received") {
          setLastMessage(event);
        }
      });

      socket.on("close", () => setIsConnected(false));
    }

    connect();
    return () => socket?.close();
  }, [apiKey, inboxIds.join(",")]);

  return { lastMessage, isConnected };
}
```

***

## Subscribe Options

When subscribing to events, you can filter by inbox, pod, or event type:

**Python:**

```python
from agentmail import Subscribe

# Subscribe to specific inboxes
Subscribe(inbox_ids=["inbox1@agentmail.to", "inbox2@agentmail.to"])

# Subscribe to pods
Subscribe(pod_ids=["pod-id-1", "pod-id-2"])

# Subscribe to specific event types
Subscribe(
    inbox_ids=["agent@agentmail.to"],
    event_types=["message.received", "message.sent"]
)
```

**TypeScript:**

```typescript
// Subscribe to specific inboxes
socket.sendSubscribe({
  type: "subscribe",
  inboxIds: ["inbox1@agentmail.to", "inbox2@agentmail.to"],
});

// Subscribe to pods
socket.sendSubscribe({
  type: "subscribe",
  podIds: ["pod-id-1", "pod-id-2"],
});

// Subscribe to specific event types
socket.sendSubscribe({
  type: "subscribe",
  inboxIds: ["agent@agentmail.to"],
  eventTypes: ["message.received", "message.sent"],
});
```

***

## Event Types

### Connection Events

| Event        | Python       | TypeScript             | Description            |
| ------------ | ------------ | ---------------------- | ---------------------- |
| `subscribed` | `Subscribed` | `AgentMail.Subscribed` | Subscription confirmed |

### Message Events

| Event                | Python                   | TypeScript                         | Description          |
| -------------------- | ------------------------ | ---------------------------------- | -------------------- |
| `message_received`   | `MessageReceivedEvent`   | `AgentMail.MessageReceivedEvent`   | New email received   |
| `message_sent`       | `MessageSentEvent`       | `AgentMail.MessageSentEvent`       | Email was sent       |
| `message_delivered`  | `MessageDeliveredEvent`  | `AgentMail.MessageDeliveredEvent`  | Email was delivered  |
| `message_bounced`    | `MessageBouncedEvent`    | `AgentMail.MessageBouncedEvent`    | Email bounced        |
| `message_complained` | `MessageComplainedEvent` | `AgentMail.MessageComplainedEvent` | Email marked as spam |
| `message_rejected`   | `MessageRejectedEvent`   | `AgentMail.MessageRejectedEvent`   | Email was rejected   |

### Domain Events

| Event             | Python                | TypeScript                      | Description                   |
| ----------------- | --------------------- | ------------------------------- | ----------------------------- |
| `domain_verified` | `DomainVerifiedEvent` | `AgentMail.DomainVerifiedEvent` | Domain verification completed |

***

## Message Properties

The `event.message` object contains:

| Python        | TypeScript    | Description                   |
| ------------- | ------------- | ----------------------------- |
| `inbox_id`    | `inboxId`     | Inbox that received the email |
| `message_id`  | `messageId`   | Unique message ID             |
| `thread_id`   | `threadId`    | Conversation thread ID        |
| `from_`       | `from_`       | Sender email address          |
| `to`          | `to`          | Recipients list               |
| `subject`     | `subject`     | Subject line                  |
| `text`        | `text`        | Plain text body               |
| `html`        | `html`        | HTML body (if present)        |
| `attachments` | `attachments` | List of attachments           |

***

## Error Handling

**Python:**

```python
from agentmail import AsyncAgentMail, Subscribe, MessageReceivedEvent
from agentmail.core.api_error import ApiError

client = AsyncAgentMail(api_key="YOUR_API_KEY")

async def main():
    try:
        async with client.websockets.connect() as socket:
            await socket.send_subscribe(Subscribe(inbox_ids=["agent@agentmail.to"]))

            async for event in socket:
                if isinstance(event, MessageReceivedEvent):
                    await process_email(event.message)

    except ApiError as e:
        print(f"API error: {e.status_code} - {e.body}")
    except Exception as e:
        print(f"Connection error: {e}")
```

**TypeScript:**

```typescript
import { AgentMailClient, AgentMail, AgentMailError } from "agentmail";

const client = new AgentMailClient({
  apiKey: process.env.AGENTMAIL_API_KEY,
});

async function main() {
  try {
    const socket = await client.websockets.connect();

    socket.on("open", () => {
      socket.sendSubscribe({
        type: "subscribe",
        inboxIds: ["agent@agentmail.to"],
      });
    });

    socket.on("message", (event: AgentMail.MessageReceivedEvent) => {
      if (event.type === "message_received") {
        processEmail(event.message);
      }
    });

    socket.on("error", (error) => {
      console.error("WebSocket error:", error);
    });

    socket.on("close", (event) => {
      console.log("Disconnected:", event.code, event.reason);
    });
  } catch (err) {
    if (err instanceof AgentMailError) {
      console.error(`API error: ${err.statusCode} - ${err.message}`);
    } else {
      console.error("Connection error:", err);
    }
  }
}

main();
```

***


# Email Deliverability

> Learn the strategies and best practices for maximizing your email deliverability with AgentMail.

## What is Email Deliverability?

Email deliverability is the art and science of getting your emails into your recipients' inboxes. It's not just about hitting "send"; it's about building a good reputation with email providers like Gmail and Outlook so they trust that you're sending valuable content, not spam.

High deliverability is the key to successful email automation. This guide will walk you through the best practices for both your sending strategy and your email content.

### The Technical Foundation: SPF, DKIM, DMARC

Before you send your first email, it's important to have the right technical foundation in place. SPF, DKIM, and DMARC are DNS records that act as a digital signature, proving to email providers that you are who you say you are.

<Tip>
  We take care of all of this for you guys, so no need to worry about these.
  Just something to know about(or google).
</Tip>

For maximum control and the best deliverability, we strongly recommend using your own custom domains. Setting these records up correctly on your own domain is the single most important step you can take.

<CardGroup>
  <Card title="Guide: Managing Custom Domains" icon="fa-solid fa-shield-alt" href="/custom-domains">
    Learn how to add your own domain and configure SPF, DKIM, and DMARC records.
  </Card>
</CardGroup>

## High-Volume Sending Strategy

How you send your emails is just as important as what you send. If you're sending a large volume of emails, follow these steps to build and maintain a strong sender reputation.

<Steps>
  <Step title="Warm-Up Your Inboxes">
    Don't go from zero to one thousand emails overnight. Email providers get
    suspicious of new inboxes that immediately send a high volume. Start slow
    and gradually increase your sending volume over several days or weeks. This
    "warm-up" process signals that you're a legitimate sender.

    <Callout intent="info">
      **Example Warm-Up Schedule:**
      <br /> - Day 1: 10 emails/inbox
      <br /> - Day 2: 20 emails/inbox
      <br /> - Day 3: 40 emails/inbox
      <br /> - ...and so on.
    </Callout>
  </Step>

  <Step title="Diversify Your Sending Inboxes">
    Instead of sending 10,000 emails from a single inbox, it's far better to
    send 100 emails from 100 different inboxes. This distributes your sending
    volume, reduces the risk of any single inbox getting flagged, and looks much
    more natural to email providers. AgentMail's ability to create inboxes at
    scale makes this strategy easy to implement.

    <img src="https://files.buildwithfern.com/https://agentmail-production.docs.buildwithfern.com/718d953f857886e2d6c6e554184b6800f3c62fcbd340c506764c5d0669151940/assets/inbox-diversification.png" alt="Diagram comparing one inbox sending 1000 emails vs. five inboxes sending 200 each." />
  </Step>

  <Step title="Protect Your Reputation with Multiple Domains">
    An email domain's reputation is its most valuable asset. To protect it, use
    multiple custom domains for your outreach campaigns. If one domain's
    reputation is inadvertently damaged, you can cycle it out without impacting
    the deliverability of your other domains.
  </Step>
</Steps>

## High-Impact Content Strategy

The content of your email plays a huge role in whether it's seen as a valuable message or as spam.

<Steps>
  <Step title="Personalize Everything">
    Address your recipients by name in the subject line and email body. Use
    other data points you have to make the email feel like a one-to-one
    conversation, not a mass blast. Generic emails are a major red flag for spam
    filters.
  </Step>

  <Step title="Write Like a Human, Not a Marketer">
    Avoid "spammy" keywords (e.g., "free," "buy now," "limited time offer"),
    excessive exclamation points, and using all caps. Write in a natural,
    conversational tone. The goal is to start a conversation, not to close a
    sale in the first email.
  </Step>

  <Step title="Be Strategic with images">
    Any type of image that isn't an attachment but included in the message body
    actually sets off the spam alarms. Don't do it. Also get rid of your
    open-tracker while you're at it because how EVERY service checks if the
    recipient of your email opened your message is by encoding a small image
    into the body. Hurts deliverability!!
  </Step>

  <Step title="CTA Selection">
    Email providers are wary of emails links, especially in the first message of
    a conversation. A great strategy is to send your initial outreach with no
    links or images. Wait for the recipient to reply, and *then* send your
    call-to-action (CTA) link. This behavior is viewed far more favorably, as
    it's now viewd as a "conversation."
  </Step>

  <Step title="HTML + Text">
    Email providers oftentimes flag emails that only include HTML as spam.
    Providing a plain text alternative demonstrates the legitimacy of your
    message to providers like Gmail and increases the chances of it reaching the
    recipient's inbox.
  </Step>
</Steps>


# Idempotent Requests

> A guide to using the client_id parameter in AgentMail to prevent duplicate resources and safely retry API requests.

## What is Idempotency?

In the context of an API, idempotency is the concept that making the same API request multiple times produces the same result as making it just once. If an idempotent `POST` request to create a resource is sent five times, it only creates the resource on the first call. The next four calls do nothing but return the result of that first successful call.

This is a critical feature for building robust, fault-tolerant systems. Network errors, timeouts, and client-side retries are inevitable. Without idempotency, these events could lead to unwanted duplicate resources, like creating multiple identical inboxes or webhooks.

## How AgentMail Handles Idempotency

AgentMail supports idempotency for all `create` operations via an optional `client_id` parameter.

When you provide a `client_id` with a `create` request, AgentMail checks if a request with that same `client_id` has already been successfully completed.

* **If it's the first time** we've seen this `client_id`, we process the request as normal, create the resource, and store the resulting resource `id` against your `client_id`.
* **If we have seen this `client_id` before**, we do *not* re-process the request. Instead, we immediately return a `200 OK` response with the data from the *original*, successfully completed request.

This allows you to safely retry requests without the risk of creating duplicate data.

```python
# The first time this code is run, it creates a new inbox.
inbox = client.inboxes.create(
    username="idempotent-test",
    client_id="user-123-inbox-primary"
)
print(f"Created inbox: {inbox.id}")

# If you run this exact same code again, it will NOT create a second
# inbox. It will return the same inbox object from the first call.
inbox_again = client.inboxes.create(
    username="idempotent-test",
    client_id="user-123-inbox-primary"
)
print(f"Retrieved same inbox: {inbox_again.id}")
# The inbox.id will be identical in both calls.
```

## Best Practices for `client_id`

To use idempotency effectively, the `client_id` you generate must be unique and deterministic.

* **Deterministic:** The same logical resource on your end should always generate the same `client_id`. For example, a `client_id` for a user's primary inbox could be `inbox-for-user-{{USER_ID}}`.
* **Unique:** Do not reuse a `client_id` for creating different resources. A `client_id` used to create an inbox should not be used to create a webhook.

A common and highly effective pattern is to generate a UUID (like a `UUID v4`) on your client side for a resource you are about to create, save that UUID in your own database, and then use it as the `client_id` in the API call. This gives you a reliable key to use for any retries.


# Example: Event-Driven Agent

> A step-by-step guide to building a sophisticated agent that performs proactive outreach and uses webhooks for inbound message processing.

This tutorial walks you through building a sophisticated, dual-mode agent. It will:

1. **Proactively monitor** a GitHub repository and send an outreach email when it detects a new "star".
2. **Reactively process** and reply to incoming emails in real-time using AgentMail Webhooks.

We will use Flask to create a simple web server and `ngrok` to expose it to the internet so AgentMail can send it events.

## Prerequisites

Before you start, make sure you have the following:

* Python 3.8+
* An [AgentMail API Key](https://console.agentmail.to/dashboard/api-keys).
* An [OpenAI account](https://openai.com/) and API key.
* An [ngrok account](https://ngrok.com/) and authtoken.

## Step 1: Project Setup

First, let's set up your project directory and install the necessary dependencies.

1. **Create a project folder** and navigate into it.

2. **Create a `requirements.txt` file** with the following content:

   ```txt
   agentmail
   agentmail-toolkit
   openai
   openai-agents
   python-dotenv
   flask
   ngrok
   ```

3. **Install the packages:**
   ```bash
   pip install -r requirements.txt
   ```

4. **Create a `.env` file** to store your secret keys and configuration.

   ```env
   AGENTMAIL_API_KEY="your_agentmail_api_key"
   OPENAI_API_KEY="your_openai_api_key"

   NGROK_AUTHTOKEN="your_ngrok_authtoken"
   INBOX_USERNAME="github-star-agent"
   WEBHOOK_DOMAIN="your-ngrok-subdomain.ngrok-free.app"
   DEMO_TARGET_EMAIL="your-email@example.com"
   TARGET_GITHUB_REPO="YourGitHub/YourRepo"
   ```

   * Replace the placeholder values with your actual keys.
   * `WEBHOOK_DOMAIN` is your custom domain from your ngrok dashboard.
   * `INBOX_USERNAME` will be the email address for your agent (e.g., `github-star-agent@agentmail.to`).

## Step 2: The Agent Code (`main.py`)

Create a file named `main.py` and add the full code example you provided. This script contains all the logic for our agent, including the new logic to idempotently create the inbox it needs.

<CodeBlocks>
  ````python
  # main.py
  from dotenv import load_dotenv
  load_dotenv()

  import os
  import asyncio
  from threading import Thread
  import time

  import ngrok
  from flask import Flask, request, Response

  from agentmail import AgentMail
  from agentmail_toolkit.openai import AgentMailToolkit
  from agents import WebSearchTool, Agent, Runner

  port = 8080
  domain = os.getenv("WEBHOOK_DOMAIN")
  inbox_username = os.getenv("INBOX_USERNAME")
  inbox = f"{inbox_username}@agentmail.to"

  target_github_repo = os.getenv("TARGET_GITHUB_REPO")
  if not target_github_repo:
  print("\nWARNING: The TARGET_GITHUB_REPO environment variable is not set.")
  print("The agent will not have a specific GitHub repository to focus on.")
  print("Please set it in your .env file (e.g., TARGET_GITHUB_REPO='owner/repository_name')\n")

  demo_target_email = os.getenv("DEMO_TARGET_EMAIL")
  if not demo_target_email:
  print("\nWARNING: The DEMO_TARGET_EMAIL environment variable is not set.")
  print("The agent will not have a specific email to send the 'top starrer' outreach to.")
  print("Please set it in your .env file (e.g., DEMO_TARGET_EMAIL='your.email@example.com')\n")

  # Determine the target email, with a fallback if the environment variable is not set.

  # The fallback is less ideal for a real demo but prevents the agent from having no target.

  actual_demo_target_email = demo_target_email if demo_target_email else "fallback.email@example.com"

  # Use a fallback for target_github_repo as well for the instructions string construction

  actual_target_github_repo = target_github_repo if target_github_repo else "example/repo"

  # --- AgentMail and Web Server Setup ---

  # 1. Initialize the AgentMail client

  client = AgentMail()

  # 2. Idempotently create the inbox for the agent

  # Using a deterministic client_id ensures we don't create duplicate inboxes

  # if the script is run multiple times.

  inbox_client_id = f"inbox-for-{inbox_username}"
  print(f"Attempting to create or retrieve inbox '{inbox}' with client_id: {inbox_client_id}")
  try:
  client.inboxes.create(
  username=inbox_username,
  client_id=inbox_client_id
  )
  print("Inbox creation/retrieval successful.")
  except Exception as e:
  print(f"Error creating/retrieving inbox: {e}") # Depending on the desired behavior, you might want to exit here # if the inbox is critical for the agent's function.

  # 3. Start the ngrok tunnel to get a public URL

  print("Starting ngrok tunnel...")
  listener = ngrok.forward(port, domain=domain, authtoken_from_env=True)
  print(f"ngrok tunnel started: {listener.url()}")

  # 4. Idempotently create the webhook pointing to our new public URL

  webhook_url = f"{listener.url()}/webhooks"
  webhook_client_id = f"webhook-for-{inbox_username}"
  print(f"Attempting to create or retrieve webhook for URL: {webhook_url}")
  try:
  client.webhooks.create(
  url=webhook_url,
  client_id=webhook_client_id,
  )
  print("Webhook creation/retrieval successful.")
  except Exception as e:
  print(f"Error creating/retrieving webhook: {e}")

  # 5. Initialize the Flask App

  app = Flask(**name**)

  instructions = f"""
  You are a GitHub Repository Evangelist Agent. Your name is AgentMail. Your email address is {inbox}.
  Your primary focus is the GitHub repository: '{actual_target_github_repo}'.
  Your goal is to engage the user at {actual_demo_target_email} about the potential of '{actual_target_github_repo}' for building AI agents, using rich HTML emails.

  **You operate in two main scenarios:**

  **Scenario 1: Proactive Outreach (Triggered by internal monitor for '{actual_target_github_repo}')**

  - You will receive a direct instruction when a new (simulated) star is detected for '{actual_target_github_repo}'.
  - This instruction will explicitly ask you to:
    1.  Use the WebSearchTool to find fresh, compelling information or talking points about '{actual_target_github_repo}' (e.g., new features, use cases for agent development, benefits). You should synthesize this information, not just copy it.
    2.  Use the 'send_message' tool to send a NEW email to {actual_demo_target_email}.
        - The email should start by mentioning something like: "Hello! We noticed you recently showed interest in (or starred) our repository, '{actual_target_github_repo}'! We're excited to share some insights..."
        - You must craft an engaging 'subject' for this email.
        - You must craft an informative 'html' (body) for this email in HTML format, based on your synthesized web search findings. **Do NOT include raw URLs or direct links from your web search in the email body.** Instead, discuss the concepts or information you found.
        - The email must end with a clear call to action inviting the user to ask you (the agent) questions. For example: "I'm an AI assistant for '{actual_target_github_repo}', ready to answer any questions you might have. Feel free to reply to this email with your thoughts or queries!"
  - Your final output for THIS SCENARIO (after the send_message tool call) should be a brief confirmation message (e.g., "Proactive HTML email about new star sent to {actual_demo_target_email}."). Do NOT output the email content itself as your final response here, as the tool handles sending it.

  **Scenario 2: Replying to Emails (Triggered by webhook when an email arrives at {inbox})**

  - You will receive the content of an incoming email (From, Subject, Body).
  - **If the email is FROM '{actual_demo_target_email}':**
    - This is a reply from your primary contact. Your goal is to continue the conversation naturally and persuasively. **Your entire output for this interaction MUST be a single, well-formed HTML string for the email body. It must start directly with an HTML tag (e.g., `<p>`) and end with a closing HTML tag. Do NOT include any other text, labels, comments, or markdown-style code fences (like `html ... ` or '''html: ...''') before or after the HTML content itself.**
    - Use the WebSearchTool to find relevant new information about '{actual_target_github_repo}' to answer their questions, address their points, or further highlight the repository's value for agent development.
    - **Strict Conciseness for Guides/Steps:** If the user asks for instructions, a guide, or steps (e.g., "how to install", "integration guide", "how to use X feature"), your reply MUST be **extremely concise (max 2-3 sentences summarizing the core idea)** and provide **ONE primary HTML hyperlink** to the most relevant page in the official documentation (e.g., `https://docs.agentstack.sh`). **Absolutely do NOT list multiple steps, commands, or code snippets in the email for these types of requests.** Your goal is to direct them to the documentation for details.
    - **HTML Formatting for All Replies:**
      - Use `<p>` tags for paragraphs. Avoid empty `<p></p>` tags or excessive `<br />` tags to prevent unwanted spacing.
      - For emphasis, use `<strong>` or `<em>`.
      - If, for a question _not_ about general guides/steps, a short code snippet is essential for a direct answer, you MUST wrap it in `<pre><code>...code...</code></pre>` tags. But avoid this for guide-type questions.
      - All URLs you intend to be clickable MUST be formatted as HTML hyperlinks: `<a href="URL\">Clickable Link Text</a>`. Do not output raw URLs or markdown-style links.
      - For example, a reply to "how to install" MUST be similar to: `<p>You can install AgentStack using package managers like Homebrew or pipx. For the detailed commands and options, please consult our official <a href='https://docs.agentstack.sh/installation'>Installation Guide</a>.</p><p>Is there anything else specific I can help you find in the docs or a different question perhaps?</p>`
    - The webhook handler will use your **raw string output** directly as the HTML body of the reply.
  - **If the email is FROM ANY OTHER ADDRESS:**
    - This is unexpected. Politely state (in simple HTML, using one or two `<p>` tags, **and no surrounding fences or labels**) that you are an automated agent focused on discussing '{actual_target_github_repo}' with {actual_demo_target_email} and cannot assist with other requests at this time.
    - Your output for this interaction should be ONLY this polite, **raw HTML email body.**

  **General Guidelines for HTML Emails to {actual_demo_target_email}:**
  _ Always be enthusiastic and informative about '{actual_target_github_repo}'.
  _ Tailor your points based on information you find with the WebSearchTool. For initial outreach, synthesize information. **For replies asking for guides/steps, BE EXTREMELY CONCISE, summarize in 2-3 sentences, and provide a single link to the main documentation.**
  _ Initial outreach: concise (5-6 sentences). Replies answering specific, non-guide questions: aim for 7-10 sentences. **Replies to guide/installation/integration questions: MAX 4 sentences, including the link.**
  _ Structure ALL content with appropriate HTML tags: `<p>`, `<br />` (sparingly), `<strong>`, `<em>`, `<u>`, `<ul>`, `<ol>`, `<li>` (if not a guide question), `<pre><code>` (if not a guide question and essential), and **`<a href="URL">link text</a>` for ALL clickable links.** NO MARKDOWN-STYLE LINKS.

  - \*\*IMPORTANT: Your output for replies (Scenario 2, when email is from {actual*demo_target_email}) MUST be \_only* the HTML content itself. Do not wrap it in markdown code fences (like ```html), or any other prefix/suffix text.** Start directly with `<p>` or another HTML tag.
  - Encourage interaction. The initial email must end with an invitation to reply with questions. \* Maintain conversation context.

  Remember, your primary contact for ongoing conversation is '{actual_demo_target_email}', and your primary topic is always '{actual_target_github_repo}'.
  """

  agent = Agent(
  name="GitHub Agent",
  instructions=instructions,
  tools=AgentMailToolkit(client).get_tools() + [WebSearchTool()],
  )

  messages = []

  # --- GitHub Polling Logic ---

  simulated_stargazer_count = 0
  MAX_SIMULATED_STARS = 1 # single star even
  stars_found_so_far = 0

  def poll_github_stargazers():
  global simulated_stargazer_count, stars_found_so_far
  print(f"GitHub polling thread started for top 20 repositories related to AI agents...")

      # Give the Flask app a moment to start up if run concurrently
      time.sleep(3)

      while stars_found_so_far < MAX_SIMULATED_STARS:
          time.sleep(13) # Poll every 30 seconds for the demo

          # Simulate a new star appearing
          new_star_detected = False
          # For demo, let's just add a star each time for the first few polls
          if stars_found_so_far < MAX_SIMULATED_STARS: # Check again inside loop
              simulated_stargazer_count += 1
              stars_found_so_far += 1
              new_star_detected = True
              print(f"[POLLER] New star! Total: {simulated_stargazer_count}")

          if new_star_detected and actual_target_github_repo != "example/repo" and actual_demo_target_email != "fallback.email@example.com":
              prompt_for_agent = f"""\
              URGENT TASK: A new star has been detected for the repository '{actual_target_github_repo}' (simulated count: {simulated_stargazer_count}).
              Your goal is to use the 'send_message' tool to notify {actual_demo_target_email} with an HTML email that does not contain direct web links in its body and has a specific call to action.

              Thought: I need to perform two steps: first, gather information using WebSearchTool, and second, synthesize this information into an HTML email and send it using the send_message tool.

              Step 1: Gather Information.
              Use the WebSearchTool to find ONE fresh, compelling piece of information or talking point about '{actual_target_github_repo}' relevant to AI agent development.
              Your output for this step should be an action call to WebSearchTool. For example:
              Action: WebSearchTool("key features of {actual_target_github_repo} for AI agents")

              (After you receive the observation from WebSearchTool, you will proceed to Step 2 in your next turn)

              Step 2: Formulate and Send HTML Email.
              Based on the information from WebSearchTool, you MUST call the 'send_message' tool.
              The email should start by acknowledging the user's interest, e.g., "<p>Hello! We noticed you recently showed interest in (or starred) our repository, <strong>{actual_target_github_repo}</strong>! We're excited to share some insights...</p>"
              The email body should discuss the information you found but **MUST NOT include any raw URLs or direct hyperlinks from the web search results.** Synthesize the information.
              The email MUST end with a call to action like: "<p>I'm an AI assistant for '{actual_target_github_repo}', and I'm here to help answer any questions you might have. Feel free to reply to this email with your thoughts or if there's anything specific you'd like to know!</p>"

              The parameters for the 'send_message' tool call should be:
                  - 'to': ['{actual_demo_target_email}']
                  - 'inbox_id': '{inbox}'
                  - 'subject': An engaging subject based on the web search findings (e.g., "Insights on {actual_target_github_repo} for Your AI Projects!").
                  - 'html': An email body in HTML format, adhering to all the above content and formatting rules (mention star, no direct links, specific CTA).

              Your output for this step MUST be an action call to 'send_message' with the tool input formatted as a valid JSON string, ensuring you use the 'html' field for the body. For example:
              Action: send_message(```
              {{
                "inbox_id": "{inbox}",
                "to": ["{actual_demo_target_email}"],
                "subject": "Following Up on Your Interest in {actual_target_github_repo}!",
                "html": "<p>Hello! We noticed you recently showed interest in <strong>{actual_target_github_repo}</strong>!</p><p>We've been developing some exciting capabilities within it, particularly around [synthesized information from web search, e.g., its new modular design for agent development]. This allows for more flexible integration of AI components.</p><p>I'm an AI assistant for \'{actual_target_github_repo}\', and I\'m here to help answer any questions you might have. Feel free to reply to this email with your thoughts or if there\'s anything specific you\'d like to know!</p>"
              }}
              ```)

              If you cannot find information with WebSearchTool in Step 1, for Step 2 you should still attempt to call send_message. The HTML email should still acknowledge the star and provide the specified CTA, but state that fresh specific updates couldn't be retrieved at this moment, while still highlighting the general value of '{actual_target_github_repo}'.
              Your final conversational output after the 'send_message' action is executed by the system should be a simple confirmation like "Email dispatch initiated to {actual_demo_target_email}."
              """
              print(f"[POLLER] Triggering agent for new star on {actual_target_github_repo} to notify {actual_demo_target_email}")
              # We run the agent in a blocking way here for simplicity in the polling thread.
              # The 'messages' history is intentionally kept separate from the webhook's conversation history for this proactive outreach.
              try:
                  response = asyncio.run(Runner.run(agent, [{"role": "user", "content": prompt_for_agent}]))
                  print(f"[POLLER] Agent response to new star prompt: {response.final_output}")
                  # You could add a more specific check here if the agent is supposed to return a structured success/failure
                  if "email dispatch initiated" not in response.final_output.lower():
                      print(f"[POLLER_WARNING] Agent response did not explicitly confirm email sending according to expected pattern: {response.final_output}")
              except Exception as e:
                  print(f"[POLLER_ERROR] An error occurred while the agent was processing the new star prompt: {e}")
                  import traceback # Import traceback here to use it
                  print(f"[POLLER_ERROR] Traceback: {traceback.format_exc()}")
          elif new_star_detected:
              print("[POLLER] Simulated new star, but TARGET_GITHUB_REPO or DEMO_TARGET_EMAIL is not properly set. Skipping agent trigger.")

  @app.route("/webhooks", methods=["POST"])
  def receive_webhook():
  print(f"\n[/webhooks] Received webhook. Payload keys: {list(request.json.keys()) if request.is_json else 'Not JSON or empty'}")
  Thread(target=process_webhook, args=(request.json,)).start()
  return Response(status=200)

  def process_webhook(payload):
  global messages

      email = payload["message"]
      print(f"[process_webhook] Processing email from: {email.get('from')}, subject: {email.get('subject')}, id: {email.get('message_id')}")

      prompt = f"""
              From: {email["from"]}
              Subject: {email["subject"]}
              Body:\n{email["text"]}
              """
      print("Prompt:\n\n", prompt, "\n")

      response = asyncio.run(Runner.run(agent, messages + [{"role": "user", "content": prompt}]))
      print("Response:\n\n", response.final_output, "\n")

      print(f"[process_webhook] Attempting to send reply to message_id: {email['message_id']} via inbox: {inbox}")
      client.inboxes.messages.reply(inbox_id=inbox, message_id=email["message_id"], html=response.final_output)
      print(f"[process_webhook] Reply call made for message_id: {email['message_id']}.")

      messages = response.to_input_list()
      print(f"[process_webhook] Updated message history. New length: {len(messages)}\n")

  if **name** == "**main**":
  print(f"Inbox: {inbox}\n")
  if not target_github_repo or target_github_repo == "example/repo":
  print("WARNING: TARGET_GITHUB_REPO not set or is default. Poller will not be effective.")
  if not demo_target_email:
  print("WARNING: DEMO_TARGET_EMAIL not set or is default. Poller will not be effective.")

      polling_thread = Thread(target=poll_github_stargazers)
      polling_thread.daemon = True # So it exits when the main thread exits
      polling_thread.start()

      print(f"ngrok tunnel started: {listener.url()}")

      app.run(port=port)

  ````
</CodeBlocks>

### Understanding the Code

<AccordionGroup>
  <Accordion title="Idempotency with `client_id`">
    Notice that the script now handles its own setup. Before the agent starts, the code calls `client.inboxes.create` with a `client_id` parameter. This makes the operation **idempotent**.

    The first time you run the script, it creates the inbox. Every subsequent time, the AgentMail API will recognize the `client_id`, see that the inbox already exists, and simply return the existing inbox's data instead of creating a duplicate. This makes your script robust and safe to run multiple times. The same principle is used when creating the webhook.
  </Accordion>

  <Accordion title="Agent Persona and Instructions">
    The `instructions` variable defines the agent's entire personality, goals, and operational logic. It's a comprehensive prompt that tells the agent how to behave in two distinct scenarios: proactive outreach for new GitHub stars and reactive replies to incoming emails. It includes strict rules on HTML formatting and how to handle different types of user queries.
  </Accordion>

  <Accordion title="Proactive Polling (`poll_github_stargazers`)">
    This function runs in a separate background thread. For this demo, it *simulates* finding a new star on your target repository every 13 seconds. When it "finds" one, it constructs a detailed prompt and calls the agent to begin the outreach workflow (search for info, then send an email).

    <Callout type="info" title="This is a Simulation">
      To keep the example focused, this code does not actually connect to the GitHub API. It simulates finding a new star to trigger the agent. In a real-world application, you would replace the simulation logic inside this function with actual API calls to GitHub to get real data.
    </Callout>
  </Accordion>

  <Accordion title="Webhook Server (`Flask` and `ngrok`)">
    * `app = Flask(__name__)` creates our web server.
    * `@app.route("/webhooks", methods=["POST"])` defines the specific URL that will listen for `POST` requests from AgentMail.
    * `listener = ngrok.forward(...)` tells `ngrok` to create a public URL (using your `WEBHOOK_DOMAIN`) and securely forward all traffic to our local Flask server on port `8080`.
  </Accordion>

  <Accordion title="Webhook Processing (`process_webhook`)">
    When a request hits our `/webhooks` endpoint, the `receive_webhook` function immediately starts the `process_webhook` function in a new thread. This is a crucial best practice: it allows us to return a `200 OK` status to AgentMail instantly while the heavy lifting happens in the background.

    Inside `process_webhook`, the function parses the JSON payload, constructs a prompt from the email's content, runs the agent, and then uses `client.messages.reply()` to send the agent's HTML output as a reply.
  </Accordion>
</AccordionGroup>

## Step 3: Run the Agent

Now, let's bring your agent to life. The script is now fully self-contained. When you run it, it will automatically:

1. Create the agent's inbox.
2. Start an `ngrok` tunnel to get a public URL.
3. Use that URL to create the AgentMail webhook.
4. Start the web server to listen for events.
5. Start the background process to monitor GitHub.

Open your terminal in the project directory and run the command:

```bash
python main.py
```

You should see a series of logs confirming that all setup steps have been completed. Keep this terminal window running.

## Step 4: Test Your Agent

### Test Scenario 1: Proactive Outreach

You don't have to do anything for this one! The `poll_github_stargazers` function is already running. Within about 15 seconds, you should see logs in your terminal indicating that a new star was detected and the agent is being triggered. A few moments later, an email should arrive in the inbox you specified for `DEMO_TARGET_EMAIL`.

### Test Scenario 2: Reactive Reply

1. Find the email your agent just sent you.
2. Reply to it with a question, like "This is cool! How do I install it?"
3. Check your running `main.py` terminal. You should see new logs indicating a webhook was received and is being processed.
4. Shortly after, you should receive an HTML-formatted email reply from your agent in your inbox.

You now have a fully event-driven agent that can both initiate conversations and respond to them in real time!

```
```


# Auto-Reply Email Agent

> Build a simple agent that automatically responds to incoming emails with personalized messages

## Overview

Learn how to build an email auto-reply agent that automatically responds to incoming emails. This beginner-friendly example demonstrates the core concepts of building with AgentMail: receiving webhooks, processing email events, and sending automated replies.

## What You'll Build

By the end of this guide, you'll have a working auto-reply agent that:

1. **Receives incoming emails** to a dedicated AgentMail inbox
2. **Processes webhook events** in real-time
3. **Extracts sender information** (name and email)
4. **Generates personalized replies** using a template
5. **Sends automated responses** back to the sender

Here's what the user experience looks like:

```
User sends email → Agentmail inbox receives → Agent processes it → User gets reply
                         ↓
              "Hi John, thank you for your email!
               I've received your message and will
               get back to you within 24 hours..."
```

## Prerequisites

Before you begin, make sure you have:

<Callout intent="info">
  **Required:**

  * Python 3.8 or higher installed
  * An [AgentMail account](https://agentmail.to) and API key
  * An [ngrok account](https://ngrok.com) (free tier works)
</Callout>

## Project Setup

### Step 1: Create Project Directory

Create a new directory for your agent:

```bash
mkdir auto-reply-agent
cd auto-reply-agent
```

### Step 2: Create the Agent Code

Create a file named `agent.py` and paste the following code:

<Accordion title="Click to view full agent.py code">
  ```python
  """
  Auto-Reply Email Agent

  A simple example showing how to build an email auto-reply bot with AgentMail.
  This agent automatically responds to incoming emails with personalized messages.
  """

  import os
  from dotenv import load_dotenv

  # Load environment variables before importing AgentMail
  load_dotenv()

  from flask import Flask, request, Response
  import ngrok
  from agentmail import AgentMail
  import threading

  # Configuration
  PORT = 8080
  INBOX_USERNAME = os.getenv("INBOX_USERNAME", "auto-reply")
  WEBHOOK_DOMAIN = os.getenv("WEBHOOK_DOMAIN")

  # Initialize Flask app and AgentMail client
  app = Flask(__name__)
  client = AgentMail()
  processed_messages = set()  # Track processed message IDs to prevent duplicates


  def setup_agentmail():
      """Create inbox and webhook with idempotency."""
      print("Setting up AgentMail infrastructure...")

      # Create inbox (or get existing one)
      try:
          inbox = client.inboxes.create(
              username=INBOX_USERNAME,
              client_id=f"{INBOX_USERNAME}-inbox"
          )
          print(f"✓ Inbox created: {inbox.inbox_id}")
      except Exception as e:
          if "already exists" in str(e).lower():
              inbox_id = f"{INBOX_USERNAME}@agentmail.to"
              class SimpleInbox:
                  def __init__(self, inbox_id):
                      self.inbox_id = inbox_id
              inbox = SimpleInbox(inbox_id)
              print(f"✓ Using existing inbox: {inbox.inbox_id}")
          else:
              raise

      # Start ngrok tunnel
      listener = ngrok.forward(PORT, domain=WEBHOOK_DOMAIN, authtoken_from_env=True)

      # Create webhook (or get existing one)
      try:
          webhook = client.webhooks.create(
              url=f"{listener.url()}/webhook/agentmail",
              event_types=["message.received"],
              inbox_ids=[inbox.inbox_id],
              client_id=f"{INBOX_USERNAME}-webhook"
          )
          print(f"✓ Webhook created")
      except Exception as e:
          if "already exists" in str(e).lower():
              print(f"Webhook already exists")
          else:
              raise

      print(f"\n✓ Setup complete!")
      print(f"Inbox: {inbox.inbox_id}")
      print(f"Webhook: {listener.url()}/webhook/agentmail\n")

      return inbox, listener


  def generate_reply(sender_name, subject):
      """Generate auto-reply message using a template."""
      return (
          f"Hi {sender_name},\n\n"
          f"Thank you for your email! I've received your message and will get back to you within 24 hours.\n\n"
          f"If your matter is urgent, please reply with \"URGENT\" in the subject line.\n\n"
          f"Best regards,\n"
          f"Auto-Reply Agent"
      )


  def process_and_reply(message_id, inbox_id, from_field, subject, message):
      """Process incoming message and send reply in background."""
      # Extract sender email and name
      if '<' in from_field and '>' in from_field:
          sender_email = from_field.split('<')[1].split('>')[0].strip()
          sender_name = from_field.split('<')[0].strip()
          if not sender_name or ',' in sender_name:
              sender_name = sender_email.split('@')[0].title()
      else:
          sender_email = from_field.strip()
          sender_name = sender_email.split('@')[0].title() if '@' in sender_email else 'Friend'

      # Log incoming email
      print(f"Processing email from {sender_email}: {subject}")

      # Generate and send auto-reply
      try:
          reply_text = generate_reply(sender_name, subject)
          client.inboxes.messages.reply(
              inbox_id=inbox_id,
              message_id=message_id,
              to=[sender_email],
              text=reply_text
          )
          print(f"Auto-reply sent to {sender_email}\n")
      except Exception as e:
          print(f"Error: {e}\n")


  @app.route('/webhook/agentmail', methods=['POST'])
  def receive_webhook():
      """Webhook endpoint to receive incoming email notifications."""
      payload = request.json
      event_type = payload.get('type') or payload.get('event_type')

      # Ignore outgoing messages
      if event_type == 'message.sent':
          return Response(status=200)

      message = payload.get('message', {})
      message_id = message.get('message_id')
      inbox_id = message.get('inbox_id')
      from_field = message.get('from_', '') or message.get('from', '')

      # Validate required fields
      if not message_id or not inbox_id or not from_field:
          return Response(status=200)

      # prevent duplicate
      if message_id in processed_messages:
          return Response(status=200)
      processed_messages.add(message_id)

      subject = message.get('subject', '(no subject)')

      # Process in background thread and return immediately
      thread = threading.Thread(
          target=process_and_reply,
          args=(message_id, inbox_id, from_field, subject, message)
      )
      thread.daemon = True
      thread.start()

      return Response(status=200)


  if __name__ == '__main__':
      print("\n" + "="*60)
      print("AUTO-REPLY EMAIL AGENT")
      print("="*60 + "\n")

      inbox, listener = setup_agentmail()

      print(f"Agent is ready!")
      print(f"Send emails to: {inbox.inbox_id}")
      print(f"\nWaiting for incoming emails...\n")

      app.run(port=PORT)
  ```
</Accordion>

### Step 3: Create Requirements File

Create a file named `requirements.txt`:

```txt
agentmail
flask>=3.0.0
ngrok>=1.0.0
python-dotenv>=1.0.0
```

### Step 4: Install Dependencies

Install the required Python packages:

```bash
pip install -r requirements.txt
```

### Step 5: Configure Environment Variables

Create a `.env` file with your credentials:

```env
# AgentMail Configuration
AGENTMAIL_API_KEY=your_agentmail_api_key_here

# Ngrok Configuration
NGROK_AUTHTOKEN=your_ngrok_authtoken_here
WEBHOOK_DOMAIN=your-name.ngrok-free.app

# Inbox Settings
INBOX_USERNAME=auto-reply
```

## Code Walkthrough

Let's understand how the agent works by breaking down the key components.

### Architecture Overview

```
┌─────────────┐
│  Someone    │
│  sends      │ ──────► ┌──────────────┐
│  email      │         │  AgentMail   │
└─────────────┘         │   Inbox      │
                        └──────┬───────┘
                               │ Webhook
                               ▼
                        ┌──────────────┐
                        │   Ngrok      │
                        │   Tunnel     │
                        └──────┬───────┘
                               │
                               ▼
                        ┌──────────────┐
                        │  Your Flask  │
                        │    Server    │
                        └──────┬───────┘
                               │
                               ▼
                        ┌──────────────┐
                        │   Generate   │
                        │   & Send     │
                        │   Reply      │
                        └──────────────┘
```

### 1. Initialization

```python
import os
from dotenv import load_dotenv

# Load environment variables FIRST
load_dotenv()

from flask import Flask, request, Response
import ngrok
from agentmail import AgentMail

# Initialize the AgentMail client
client = AgentMail()  # Reads AGENTMAIL_API_KEY from environment
app = Flask(__name__)
```

**Key points:**

* Load `.env` variables before importing AgentMail
* AgentMail SDK automatically reads `AGENTMAIL_API_KEY` from environment
* Flask creates the web server for receiving webhooks

### 2. Setting Up Infrastructure

The `setup_agentmail()` function creates your inbox and webhook:

```python
def setup_agentmail():
    """Create inbox and webhook with idempotency."""

    # Create inbox (or get existing one)
    try:
        inbox = client.inboxes.create(
            username=INBOX_USERNAME,
            client_id=f"{INBOX_USERNAME}-inbox"  # ← Idempotency key
        )
        print(f"✓ Inbox created: {inbox.inbox_id}")
    except Exception as e:
        if "already exists" in str(e).lower():
            # Inbox already exists, that's fine!
            inbox_id = f"{INBOX_USERNAME}@agentmail.to"
            inbox = SimpleInbox(inbox_id)
```

**Why `client_id`?**

The `client_id` parameter makes this operation **idempotent** - you can run it multiple times without creating duplicates. If the inbox already exists, AgentMail returns the existing one.

```python
    # Start ngrok tunnel
    listener = ngrok.forward(PORT, domain=WEBHOOK_DOMAIN, authtoken_from_env=True)

    # Create webhook
    webhook = client.webhooks.create(
        url=f"{listener.url()}/webhook/agentmail",
        event_types=["message.received"],  # ← Only subscribe to incoming emails
        client_id=f"{INBOX_USERNAME}-webhook"  # ← Idempotency
    )
```

**What's happening:**

1. Ngrok creates a public URL that forwards to `localhost:8080`
2. We register a webhook with AgentMail
3. AgentMail will POST to this URL when emails arrive

### 3. Processing Webhooks

The webhook endpoint receives incoming email notifications:

```python
@app.route('/webhook/agentmail', methods=['POST'])
def receive_webhook():
    """Webhook endpoint to receive incoming email notifications."""
    payload = request.json
    event_type = payload.get('type') or payload.get('event_type')

    # Ignore outgoing messages (prevents infinite loops!)
    if event_type == 'message.sent':
        return Response(status=200)
```

<Callout intent="info">
  **Why ignore `message.sent`?**

  When your agent sends a reply, AgentMail triggers a `message.sent` webhook. If we don't filter this out, the agent would treat its own replies as new emails and respond to itself infinitely!

  By returning `200`, we tell AgentMail "I received this webhook successfully, but I'm choosing not to process it."
</Callout>

### 4. Extracting Email Data

```python
    message = payload.get('message', {})
    message_id = message.get('message_id')
    inbox_id = message.get('inbox_id')
    from_field = message.get('from_', '') or message.get('from', '')

    # Validate required fields
    if not message_id or not inbox_id or not from_field:
        return Response(status=200)  # Gracefully skip incomplete data
```

**Webhook payload structure:**

```json
{
  "type": "message.received",
  "message": {
    "message_id": "abc123...",
    "inbox_id": "auto-reply@agentmail.to",
    "from_": "John Doe <john@example.com>",
    "subject": "Hello",
    "text": "Email body content..."
  }
}
```

### 5. Parsing Sender Information

Email addresses can come in different formats. We handle both:

```python
# Extract sender email and name
if '<' in from_field and '>' in from_field:
    # Format: "John Doe <john@example.com>"
    sender_email = from_field.split('<')[1].split('>')[0].strip()
    sender_name = from_field.split('<')[0].strip()
    if not sender_name or ',' in sender_name:
        # Name is empty or has comma, use email username
        sender_name = sender_email.split('@')[0].title()
else:
    # Format: "john@example.com"
    sender_email = from_field.strip()
    sender_name = sender_email.split('@')[0].title()
```

**Examples:**

* `"John Doe <john@example.com>"` → name: "John Doe", email: "[john@example.com](mailto:john@example.com)"
* `"john@example.com"` → name: "John", email: "[john@example.com](mailto:john@example.com)"
* `"Last, First <name@example.com>"` → name: "Name", email: "[name@example.com](mailto:name@example.com)"

### 6. Generating the Reply

```python
def generate_reply(sender_name, subject):
    """Generate auto-reply message using a template."""
    return (
        f"Hi {sender_name},\n\n"
        f"Thank you for your email! I've received your message and will get back to you within 24 hours.\n\n"
        f"If your matter is urgent, please reply with \"URGENT\" in the subject line.\n\n"
        f"Best regards,\n"
        f"Auto-Reply Agent"
    )
```

This simple template-based approach requires no AI or external APIs. The reply is personalized with the sender's name.

### 7. Sending the Reply

```python
try:
    reply_text = generate_reply(sender_name, subject)
    client.inboxes.messages.reply(
        inbox_id=inbox_id,
        message_id=message_id,
        to=[sender_email],  # ← Must be a list!
        text=reply_text
    )
    print(f"Auto-reply sent to {sender_email}\n")
except Exception as e:
    print(f"Error: {e}\n")

return Response(status=200)  # Always return 200 to acknowledge webhook
```

**Important details:**

* `to` parameter must be a **list** of email addresses
* `message_id` links the reply to the original email (threading)
* Always return `200` status to acknowledge the webhook
* Errors are logged but don't crash the server

<Callout intent="info">
  **Why always return 200?**

  Even if sending the reply fails, we return `200` to AgentMail. This tells AgentMail "I received and processed this webhook." If we returned an error status, AgentMail would retry sending the webhook multiple times, which isn't helpful for application errors.
</Callout>

## Running the Agent

Start the agent:

```bash
python agent.py
```

You should see output like this:

```
============================================================
AUTO-REPLY EMAIL AGENT
============================================================

Setting up AgentMail infrastructure...
✓ Inbox created: auto-reply@agentmail.to
✓ Webhook created

✓ Setup complete!
  Inbox: auto-reply@agentmail.to
  Webhook: https://your-name.ngrok-free.app/webhook/agentmail

Agent is ready!
Send emails to: auto-reply@agentmail.to
Reply mode: Template-based

Waiting for incoming emails...

 * Running on http://127.0.0.1:8080
```

<Callout intent="success">
  **Success!** Your agent is now running and ready to receive emails.

  Leave this terminal window open - closing it will stop the agent.
</Callout>

## Testing Your Agent

Let's verify everything works by sending a test email.

### Send a Test Email

1. **Open your personal email** (Gmail, Outlook, etc.)

2. **Compose a new email:**
   ```
   To: auto-reply@agentmail.to
   Subject: Testing my auto-reply agent
   Body: Hi there! This is a test message.
   ```

3. **Send the email**

### Watch the Magic Happen

In your terminal, you should see:

```
Email from youremail@gmail.com: Testing my auto-reply agent
Auto-reply sent to youremail@gmail.com
```

### Check Your Inbox

Within seconds, you should receive an automated reply:

```
Hi Youremail,

Thank you for your email! I've received your message and will get back to you within 24 hours.

If your matter is urgent, please reply with "URGENT" in the subject line.

Best regards,
Auto-Reply Agent
```

<Callout intent="success">
  **It works!** You just built and tested your first AgentMail agent.

  The agent extracted your name, personalized the message, and sent an instant reply.
</Callout>

## Customization

You can customize the auto-reply message by editing the `generate_reply()` function in `agent.py`.

The function has access to:

* `sender_name` - The sender's name extracted from their email
* `subject` - The subject line of the email

Simply modify the text in the return statement to change what your agent replies with.

## Troubleshooting

### Common Issues

<Accordion title="ModuleNotFoundError: No module named 'agentmail'">
  **Problem:** Python dependencies not installed.

  **Solution:**

  ```bash
  pip install -r requirements.txt
  ```

  If using a virtual environment, make sure it's activated first:

  ```bash
  source venv/bin/activate  # macOS/Linux
  venv\Scripts\activate     # Windows
  ```
</Accordion>

<Accordion title="AgentMail API Error: Unauthorized">
  **Problem:** Invalid or missing API key.

  **Solutions:**

  1. Check your `.env` file has the correct `AGENTMAIL_API_KEY`
  2. Verify the API key is valid in your [AgentMail Dashboard](https://agentmail.to)
  3. Make sure there are no extra spaces or quotes around the key
  4. Ensure `.env` is in the same directory as `agent.py`

  Test your API key:

  ```python
  from agentmail import AgentMail
  client = AgentMail()
  print(client.inboxes.list())  # Should succeed
  ```
</Accordion>

<Accordion title="Ngrok authentication failed">
  **Problem:** Invalid or missing ngrok auth token.

  **Solutions:**

  1. Get your auth token from [ngrok dashboard](https://dashboard.ngrok.com/get-started/your-authtoken)
  2. Update `NGROK_AUTHTOKEN` in `.env`
  3. Verify the token has no extra spaces

  Alternatively, configure ngrok globally:

  ```bash
  ngrok config add-authtoken YOUR_TOKEN
  ```
</Accordion>

<Accordion title="Webhook not receiving emails">
  **Checklist:**

  * Is the agent running? (`python agent.py` should show "Waiting for incoming emails...")
  * Is ngrok tunnel active? (Check console output for webhook URL)
  * Did you send email to the correct inbox? (Check console for inbox address)
  * Is the webhook URL accessible? Test with: `curl https://your-domain.ngrok-free.app/webhook/agentmail`

  **Debug steps:**

  1. Add logging to see webhook payloads:

  ```python
  @app.route('/webhook/agentmail', methods=['POST'])
  def receive_webhook():
      payload = request.json
      print(f"📨 Received webhook: {json.dumps(payload, indent=2)}")
      # ... rest of code ...
  ```

  2. Check ngrok dashboard for webhook requests:
     * Visit [ngrok dashboard](https://dashboard.ngrok.com)
     * View request logs to see if webhooks are arriving

  3. Verify webhook is registered:

  ```python
  client = AgentMail()
  webhooks = client.webhooks.list()
  print(webhooks)
  ```
</Accordion>

<Accordion title="Port 8080 already in use">
  **Problem:** Another process is using port 8080.

  **Solution 1:** Kill the process using the port

  ```bash
  # macOS/Linux
  lsof -ti:8080 | xargs kill -9

  # Windows
  netstat -ano | findstr :8080
  taskkill /PID <PID> /F
  ```

  **Solution 2:** Use a different port

  ```python
  PORT = 8081  # Change in agent.py
  ```
</Accordion>

<Accordion title="Reply not being sent">
  **Problem:** Webhook received but no reply sent.

  **Debug steps:**

  1. Check console for error messages
  2. Verify the reply API parameters:

  ```python
  print(f"Sending to: {sender_email}")
  print(f"From inbox: {inbox_id}")
  print(f"Reply text: {reply_text[:50]}...")
  ```

  3. Test the reply API directly:

  ```python
  client.inboxes.messages.reply(
      inbox_id="your-inbox@agentmail.to",
      message_id="test-message-id",
      to=["test@example.com"],
      text="Test reply"
  )
  ```

  4. Ensure `to` is a list (common mistake):

  ```python
  #  Wrong
  to=sender_email

  #  Correct
  to=[sender_email]
  ```
</Accordion>

Congratulations! You've built your first AgentMail agent.

### Advanced Feature: AI-Powered Replies

Want to upgrade your agent with intelligent, context-aware responses? You can add AI-powered replies using OpenAI.

**Step 1: Install OpenAI**

```bash
pip install openai
```

**Step 2: Add your OpenAI API key to `.env`**

```env
# AI Configuration
USE_AI_REPLY=true
OPENAI_API_KEY=sk-your_actual_openai_api_key_here
```

**Step 3: Add thread history and AI reply functions to `agent.py`**

After the `generate_reply()` function, add:

```python
def get_thread_history(thread_id):
    """Fetch conversation history for the thread."""
    try:
        thread = client.threads.get(thread_id=thread_id)
        return thread.messages if hasattr(thread, 'messages') else []
    except Exception as e:
        print(f"Failed to fetch thread history: {e}")
        return []


def format_thread_for_ai(messages):
    """Format thread messages into conversation history for AI."""
    conversation = []

    for msg in messages:
        if hasattr(msg, 'from_'):
            sender = msg.from_
            text = msg.text or msg.html or ""
        else:
            sender = msg.get('from_', '') or msg.get('from', '')
            text = msg.get('text', '') or msg.get('html', '') or msg.get('body', '')

        if '<' in sender and '>' in sender:
            sender = sender.split('<')[1].split('>')[0].strip()

        if text:
            conversation.append(f"From: {sender}\n{text}")

    return "\n\n---\n\n".join(reversed(conversation))


def generate_ai_reply(sender_name, email_body, subject, thread_history=""):
    """Generate AI-powered reply using OpenAI with thread context."""
    try:
        context = f"Email thread history:\n\n{thread_history}\n\n---\n\nLatest message from {sender_name}:\nSubject: {subject}\n{email_body}" if thread_history else f"Subject: {subject}\nFrom: {sender_name}\n{email_body}"

        response = openai_client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {
                    "role": "system",
                    "content": "You are an intelligent email assistant. Read the email thread and respond in a helpful, contextual way. If this is a follow-up in a conversation, acknowledge what was previously discussed. If you can provide helpful information based on the context, do so. If the question requires detailed research or expertise you don't have, acknowledge receipt and set expectations. Be conversational, professional, and concise."
                },
                {
                    "role": "user",
                    "content": f"{context}\n\nGenerate a helpful reply that considers the conversation history. Keep it concise (2-4 sentences) but be actually helpful if you can address their question or continue the conversation meaningfully."
                }
            ],
            max_tokens=250,
            temperature=0.7
        )
        return response.choices[0].message.content
    except Exception as e:
        print(f"AI generation failed, using template: {e}")
        return generate_reply(sender_name, subject)
```

**Step 4: Update the webhook handler**

In the `receive_webhook()` function, add thread\_id extraction and replace the reply generation section:

```python
    subject = message.get('subject', '(no subject)')
    thread_id = message.get('thread_id', '')  # Add this line

    # Log incoming email
    print(f"Email from {sender_email}: {subject}")

    # Generate and send auto-reply
    try:
        if USE_AI_REPLY:
            email_body = message.get('text', '') or message.get('body', '')

            # Fetch thread history for context
            thread_history = ""
            if thread_id:
                print(f"Fetching thread history for: {thread_id[:20]}...")
                messages = get_thread_history(thread_id)
                if messages:
                    thread_history = format_thread_for_ai(messages)
                    print(f"Found {len(messages)} messages in thread")

            reply_text = generate_ai_reply(sender_name, email_body, subject, thread_history)
            print("Using AI-generated reply with thread context")
        else:
            reply_text = generate_reply(sender_name, subject)
            print("Using template reply")

        client.inboxes.messages.reply(
            inbox_id=inbox_id,
            message_id=message_id,
            to=[sender_email],
            text=reply_text
        )
        print(f"Auto-reply sent to {sender_email}\n")
    except Exception as e:
        print(f"Error: {e}\n")
```

**How it works:**

* Agent fetches entire email thread using `client.threads.get(thread_id)`
* Thread history is formatted and passed to OpenAI for context-aware replies
* AI can reference previous messages and provide more intelligent responses
* If OpenAI API fails, keep trying for three times

**Result:**

Your agent now has conversation memory. When replying to follow-up emails, the AI sees the entire conversation history and can provide contextual, intelligent responses that reference previous exchanges instead of generic auto-replies.

***

If you build something cool with AgentMail, we'd love to hear about it. Share in our [Discord community](https://discord.gg/hTYatWYWBc)!


# Smart Email Labeling Agent

> Build an AI-powered agent that automatically classifies and labels incoming emails across multiple dimensions

## Overview

Learn how to build an intelligent email classification agent that uses AI to automatically analyze and label incoming emails. This intermediate example showcases AgentMail's powerful labeling feature combined with OpenAI's GPT-4o-mini to create a sophisticated inbox automation system.

## What You'll Build

By the end of this guide, you'll have a working smart labeling agent that:

1. **Receives incoming emails** to a dedicated AgentMail inbox
2. **Analyzes each email with AI** across 4 dimensions:
   * **Sentiment**: positive, neutral, or negative
   * **Category**: question, complaint, feature-request, bug-report, or praise
   * **Priority**: urgent, high, normal, or low
   * **Department**: sales, support, billing, or technical
3. **Automatically applies labels** to each email for easy filtering
4. **Handles failures gracefully** with retry logic and validation

Here's what happens when an email arrives:

```
Email: "Your product crashed! I need help ASAP!"
         ↓
   AI Analysis
         ↓
   Applied Labels:
   • negative
   • complaint
   • urgent
   • support
```

## Prerequisites

Before you begin, make sure you have:

<Callout intent="info">
  **Required:**

  * Python 3.8 or higher installed
  * An [AgentMail account](https://agentmail.to) and API key
  * An [OpenAI API key](https://platform.openai.com/api-keys) (for AI classification)
  * An [ngrok account](https://ngrok.com)
</Callout>

## Project Setup

### Step 1: Create Project Directory

Create a new directory for your agent:

```bash
mkdir smart-labeling-agent
cd smart-labeling-agent
```

### Step 2: Create the Agent Code

Create a file named `agent.py` and paste the following code:

<Accordion title="Click to view full agent.py code">
  ```python
  """
  Smart Email Labeling Agent

  An AI-powered email classification agent that automatically analyzes incoming
  emails across multiple dimensions and applies appropriate labels.
  """

  import os
  import json
  import time
  from dotenv import load_dotenv

  load_dotenv()

  from flask import Flask, request, Response
  import ngrok
  from agentmail import AgentMail
  from openai import OpenAI

  # Configuration
  PORT = int(os.getenv("PORT", "8080"))
  INBOX_USERNAME = os.getenv("INBOX_USERNAME", "smart-labels")
  WEBHOOK_DOMAIN = os.getenv("WEBHOOK_DOMAIN")

  # Initialize
  app = Flask(__name__)
  client = AgentMail()
  openai_client = OpenAI()


  def setup_agentmail():
      """Create inbox and webhook with idempotency."""
      # Create inbox
      try:
          inbox = client.inboxes.create(
              username=INBOX_USERNAME,
              client_id=f"{INBOX_USERNAME}-inbox"
          )
      except Exception as e:
          if "already exists" in str(e).lower():
              inbox_id = f"{INBOX_USERNAME}@agentmail.to"
              class SimpleInbox:
                  def __init__(self, inbox_id):
                      self.inbox_id = inbox_id
              inbox = SimpleInbox(inbox_id)
          else:
              raise

      # Start ngrok
      listener = ngrok.forward(PORT, domain=WEBHOOK_DOMAIN, authtoken_from_env=True)

      # Create webhook
      try:
          client.webhooks.create(
              url=f"{listener.url()}/webhook/agentmail",
              event_types=["message.received"],
              client_id=f"{INBOX_USERNAME}-webhook"
          )
      except Exception as e:
          if "already exists" not in str(e).lower():
              raise

      print(f"Ready: {inbox.inbox_id}\n")
      return inbox, listener


  def analyze_email(subject, content):
      """Use AI to classify email across multiple dimensions with retry logic."""
      valid_values = {
          "sentiment": {"positive", "neutral", "negative"},
          "category": {"question", "complaint", "feature-request", "bug-report", "praise"},
          "priority": {"urgent", "high", "normal", "low"},
          "department": {"sales", "support", "billing", "technical"}
      }

      for attempt in range(1, 4):
          try:
              if attempt > 1:
                  time.sleep(1)

              response = openai_client.chat.completions.create(
                  model="gpt-4o-mini",
                  messages=[
                      {
                          "role": "system",
                          "content": "You are an expert email classifier. Analyze emails and return structured classifications."
                      },
                      {
                          "role": "user",
                          "content": f"""Analyze this email across 4 dimensions:

                          Subject: {subject}
                          Content: {content}

                          Classify into:
                          1. sentiment: positive | neutral | negative
                          2. category: question | complaint | feature-request | bug-report | praise
                          3. priority: urgent | high | normal | low
                          4. department: sales | support | billing | technical

                          Consider:
                          - Sentiment: Overall tone and emotion
                          - Category: Primary intent of the email
                          - Priority: Urgency indicators (ASAP, urgent, immediately, deadline mentions, emergency)
                          - Department: Best team to handle this

                          Return ONLY valid JSON with these exact keys: sentiment, category, priority, department.
                          Example: {{"sentiment": "positive", "category": "question", "priority": "normal", "department": "sales"}}
                          """
                      }
                  ],
                  response_format={"type": "json_object"},
                  temperature=0.3
              )

              # Parse and validate
              result = json.loads(response.choices[0].message.content)

              required_keys = ["sentiment", "category", "priority", "department"]
              missing_keys = [key for key in required_keys if key not in result]
              if missing_keys:
                  raise ValueError(f"Missing keys: {missing_keys}")

              invalid_values = []
              for dimension, value in result.items():
                  if dimension in valid_values and value not in valid_values[dimension]:
                      invalid_values.append(f"{dimension}={value}")

              if invalid_values:
                  raise ValueError(f"Invalid values: {', '.join(invalid_values)}")

              return result

          except Exception as e:
              if attempt == 3:
                  raise Exception(f"AI classification failed: {e}")


  def apply_labels(inbox_id, message_id, classifications):
      """Apply labels based on classification results."""
      labels = [
          f"{classifications['sentiment']}",
          f"{classifications['category']}",
          f"{classifications['priority']}",
          f"{classifications['department']}"
      ]

      # Try batch first
      try:
          client.inboxes.messages.update(
              inbox_id=inbox_id,
              message_id=message_id,
              add_labels=labels
          )
          for label in labels:
              print(f"  ✓ {label}")
          return
      except Exception:
          pass

      # Try individually
      successful = []
      for label in labels:
          try:
              client.inboxes.messages.update(
                  inbox_id=inbox_id,
                  message_id=message_id,
                  add_labels=[label]
              )
              successful.append(label)
              print(f"  ✓ {label}")
          except Exception:
              print(f"  ✗ {label}")

      if not successful:
          raise Exception("Failed to apply labels")


  @app.route('/webhook/agentmail', methods=['POST'])
  def receive_webhook():
      """Webhook endpoint to receive incoming email notifications."""
      try:
          payload = request.json
          event_type = payload.get('type') or payload.get('event_type')

          # Ignore outgoing messages
          if event_type == 'message.sent':
              return Response(status=200)

          message = payload.get('message', {})
          message_id = message.get('message_id')
          inbox_id = message.get('inbox_id')
          from_field = message.get('from_', '') or message.get('from', '')

          # Validate required fields
          if not message_id or not inbox_id or not from_field:
              return Response(status=200)

          # Extract sender email
          if '<' in from_field and '>' in from_field:
              sender_email = from_field.split('<')[1].split('>')[0].strip()
          else:
              sender_email = from_field.strip()

          subject = message.get('subject', '(no subject)')
          email_body = message.get('text', '') or message.get('body', '') or message.get('html', '')

          # Log
          print(f"\n📧 {sender_email}: {subject}")

          # Analyze
          classifications = analyze_email(subject, email_body)

          print(f"  Sentiment: {classifications['sentiment']}")
          print(f"  Category: {classifications['category']}")
          print(f"  Priority: {classifications['priority']}")
          print(f"  Department: {classifications['department']}")

          # Apply labels
          apply_labels(inbox_id, message_id, classifications)
          print("Done\n")

      except Exception as e:
          print(f"Error: {e}\n")

      return Response(status=200)


  if __name__ == '__main__':
      print("SMART EMAIL LABELING AGENT\n")
      inbox, listener = setup_agentmail()
      print("Waiting for emails...\n")
      app.run(port=PORT)
  ```
</Accordion>

### Step 3: Create Requirements File

Create a file named `requirements.txt`:

```txt
agentmail
flask>=3.0.0
ngrok>=1.0.0
python-dotenv>=1.0.0
openai>=1.0.0
```

### Step 4: Install Dependencies

Install the required Python packages:

```bash
pip install -r requirements.txt
```

### Step 5: Configure Environment Variables

Create a `.env` file with your credentials:

```env
# AgentMail Configuration
AGENTMAIL_API_KEY=your_agentmail_api_key_here

# OpenAI Configuration
OPENAI_API_KEY=your_openai_api_key_here

# Ngrok Configuration
NGROK_AUTHTOKEN=your_ngrok_authtoken_here
WEBHOOK_DOMAIN=your-domain.ngrok-free.app

# Agent Settings
INBOX_USERNAME=smart-labels
PORT=8080
```

## Code Walkthrough

Let's understand how the agent works by breaking down the key components.

### Architecture Overview

```
Email arrives → AgentMail → Webhook → ngrok → Flask → AI Analysis → Apply Labels
```

### 1. Initialization

```python
# Load environment variables first
load_dotenv()

# Initialize three clients
app = Flask(__name__)           # Web server for webhooks
client = AgentMail()            # AgentMail SDK
openai_client = OpenAI()        # OpenAI for AI classification
```

### 2. Setting Up Infrastructure

The `setup_agentmail()` function creates your inbox and webhook:

```python
# Create inbox with idempotency
inbox = client.inboxes.create(
    username=INBOX_USERNAME,
    client_id=f"{INBOX_USERNAME}-inbox"  # Prevents duplicates
)

# Start ngrok tunnel (localhost → public URL)
listener = ngrok.forward(PORT, domain=WEBHOOK_DOMAIN)

# Register webhook with AgentMail
client.webhooks.create(
    url=f"{listener.url()}/webhook/agentmail",
    event_types=["message.received"],
    client_id=f"{INBOX_USERNAME}-webhook"
)
```

**Idempotency with `client_id`:**

Using `client_id` ensures you can safely restart the agent without creating duplicate inboxes or webhooks. If a resource already exists, AgentMail returns the existing one.

### 3. AI-Powered Email Analysis

The `analyze_email()` function is the core of the agent:

```python
def analyze_email(subject, content):
    # Define valid classification values
    valid_values = {
        "sentiment": {"positive", "neutral", "negative"},
        "category": {"question", "complaint", "feature-request", ...},
        "priority": {"urgent", "high", "normal", "low"},
        "department": {"sales", "support", "billing", "technical"}
    }

    # Retry up to 3 times
    for attempt in range(1, 4):
        try:
            # Call OpenAI API
            response = openai_client.chat.completions.create(...)

            # Parse JSON response
            result = json.loads(response.choices[0].message.content)

            # Validate keys and values
            # ... validation logic ...

            return result
        except Exception as e:
            if attempt == 3:
                raise
```

**Key features:**

1. **Structured prompt**: Clearly defines the 4 classification dimensions
2. **JSON mode**: Forces OpenAI to return valid JSON
3. **Retry logic**: Automatically retries up to 3 times on failures
4. **Strict validation**: Ensures classifications match expected values
5. **Low temperature (0.3)**: Consistent, predictable classifications

**Example OpenAI prompt:**

```
Analyze this email across 4 dimensions:

Subject: Product keeps crashing!
Content: Your software is terrible. Fix it ASAP!

Classify into:
1. sentiment: positive | neutral | negative
2. category: question | complaint | feature-request | bug-report | praise
3. priority: urgent | high | normal | low
4. department: sales | support | billing | technical

Return ONLY valid JSON...
```

**AI Response:**

```json
{
  "sentiment": "negative",
  "category": "complaint",
  "priority": "urgent",
  "department": "support"
}
```

### 4. Applying Labels

The `apply_labels()` function applies labels with a two-tier strategy:

```python
# Create labels from classification values
labels = [
    "negative",
    "complaint",
    "urgent",
    "support"
]

# Try batch application first (most efficient)
try:
    client.inboxes.messages.update(
        inbox_id=inbox_id,
        message_id=message_id,
        add_labels=labels  # Apply all at once
    )
    return
except Exception:
    pass  # If batch fails, try individually

# Apply labels one by one
for label in labels:
    try:
        client.inboxes.messages.update(
            inbox_id=inbox_id,
            message_id=message_id,
            add_labels=[label]  # One at a time
        )
    except Exception:
        pass  # Log failure but continue
```

**Why two tiers?**

1. **Batch first**: Fastest approach (1 API call for all labels)
2. **Individual fallback**: If batch fails, try each label separately to save what we can
3. **Resilient**: Won't fail completely if one label has an issue

### 5. Processing Webhooks

The `receive_webhook()` function orchestrates everything:

```python
@app.route('/webhook/agentmail', methods=['POST'])
def receive_webhook():
    payload = request.json

    # Ignore outgoing messages (prevents infinite loops)
    if event_type == 'message.sent':
        return Response(status=200)

    # Extract email data
    message_id = message.get('message_id')
    inbox_id = message.get('inbox_id')
    sender_email = extract_email(from_field)
    subject = message.get('subject')
    email_body = message.get('text')

    # Classify with AI
    classifications = analyze_email(subject, email_body)

    # Apply labels
    apply_labels(inbox_id, message_id, classifications)

    # Always return 200 (tells AgentMail we received it)
    return Response(status=200)
```

**Why always return 200?**

Even if classification or labeling fails, we return `200` to tell AgentMail: "I received this webhook." If we returned an error (400/500), AgentMail would retry sending the webhook, which doesn't help with application errors.

## Running the Agent

Start the agent:

```bash
python agent.py
```

You should see output like this:

```
SMART EMAIL LABELING AGENT

Ready: smart-labels@agentmail.to

Waiting for emails...

 * Running on http://127.0.0.1:8080
```

<Callout intent="success">
  **Success!** Your agent is now running and ready to classify emails.

  Leave this terminal window open - closing it will stop the agent.
</Callout>

## Testing Your Agent

Let's test the agent with different types of emails to see how it classifies them.

### Example 1: Urgent Complaint

**Send this email:**

```
To: smart-labels@agentmail.to
Subject: Product crashed - need immediate help!
Body: Your product is TERRIBLE! It crashed 3 times today and I lost all my work.
      I need this fixed IMMEDIATELY or I want a full refund!
```

**Console Output:**

```
you@example.com: Product crashed - need immediate help!
  Sentiment: negative
  Category: complaint
  Priority: urgent
  Department: support
  ✓ negative
  ✓ complaint
  ✓ urgent
  ✓ support
Done
```

**Why this classification?**

* **Sentiment**: negative (words: "terrible", "lost work")
* **Category**: complaint (expressing dissatisfaction)
* **Priority**: urgent (keywords: "IMMEDIATELY", "crashed 3 times")
* **Department**: support (product issue)

### Example 2: Feature Request

**Send this email:**

```
To: smart-labels@agentmail.to
Subject: Dark mode would be amazing!
Body: Hi! I absolutely love your product. I use it every day.
      One feature that would make it even better is dark mode support.
      Keep up the great work!
```

**Console Output:**

```
you@example.com: Dark mode would be amazing!
  Sentiment: positive
  Category: feature-request
  Priority: normal
  Department: technical
  ✓ positive
  ✓ feature-request
  ✓ normal
  ✓ technical
Done
```

**Why this classification?**

* **Sentiment**: positive (words: "love", "amazing", "great work")
* **Category**: feature-request (suggesting new functionality)
* **Priority**: normal (no urgency indicators)
* **Department**: technical (feature implementation)

## What Happens Next?

### View in Dashboard

Go to your AgentMail inbox and filter by labels to organize your emails:

<img src="https://files.buildwithfern.com/https://agentmail-production.docs.buildwithfern.com/58630b8f4fda508ac0e6baf8df2c5a3abb992f27f0c0ab1f0642bb8d76f355a7/assets/label-example.png" alt="Test image" />

**Filter by sentiment:**

* Search `negative` to see all unhappy customers
* Search `positive` to find praise and testimonials
* Search `neutral` to review informational emails

**Filter by priority, by department...**

**Combine filters for powerful queries:**

* `urgent` + `negative` → Critical customer issues
* `sales` + `high` → Hot leads requiring fast response
* `technical` + `bug-report` → Engineering backlog

<Callout intent="success">
  **Pro tip:** You can use AgentMail's API to programmatically fetch emails by labels and build custom workflows, dashboards, and analytics.
</Callout>

## Building on Labels

Once your emails are automatically labeled, you can build powerful automation on top:

### Example 1: Priority Notifications

**Scenario**: Alert your team instantly when urgent issues arrive.

When an email is labeled `urgent` + `negative`, automatically send a Slack notification to your support channel. Include the sender's email and subject line so your team can respond immediately. This ensures critical customer issues never slip through the cracks.

### Example 2: Sentiment Escalation

**Scenario**: Escalate negative sentiment to management.

Track all emails labeled `negative` and automatically notify customer success managers when sentiment trends downward. If a single customer sends 3+ negative emails in a week, trigger a personal outreach from leadership to address their concerns proactively.

### Example 3: Department Routing

**Scenario**: Auto-forward emails to the right team.

Create rules that automatically forward emails based on department labels:

* `sales` → Forward to [sales@yourcompany.com](mailto:sales@yourcompany.com)
* `billing` → Create a ticket in your billing system
* `technical` → Post to #engineering Slack channel
* `support` → Add to support queue with appropriate SLA

### Example 4: Smart Auto-Reply

**Scenario**: Send contextual automated responses.

Instead of generic auto-replies, craft responses based on classification:

* `question` → "Thanks for your question! We'll respond within 24 hours."
* `bug-report` → "Thanks for reporting this. Our engineering team has been notified."
* `complaint` → "We're sorry to hear that. A senior support agent will contact you within 4 hours."
* `feature-request` → "Great idea! We've added this to our product roadmap."

### Example 5: Analytics Dashboard

**Scenario**: Track email metrics and trends.

Build a dashboard that queries emails by labels to analyze:

* **Sentiment trends**: Are customers getting happier or more frustrated?
* **Volume by department**: Which team is handling the most emails?
* **Response times by priority**: Are you meeting SLAs for urgent issues?
* **Common categories**: What are customers asking about most?

Use this data to identify bottlenecks, improve processes, and make data-driven decisions about staffing and product priorities.

***

Congratulations! You've built an AI-powered email classification system. This agent showcases how AgentMail's labeling feature can power sophisticated inbox automation and analytics.


# Sales Agent with WebSocket

> A step-by-step guide to building an AI-powered sales agent that uses WebSocket for real-time email processing without polling or webhooks.

## Overview

Learn how to build a real-time sales agent that processes emails instantly using WebSocket connections. Unlike webhook-based agents that require ngrok and public URLs, this WebSocket approach connects directly to AgentMail for true real-time processing with minimal setup.

This agent demonstrates a practical sales workflow: a manager delegates customer outreach to the agent, which then handles the entire conversation autonomously while keeping the manager informed of key signals.

## What You'll Build

By the end of this guide, you'll have a working sales agent that:

1. **Connects via WebSocket** for instant, real-time email processing
2. **Handles manager emails** by extracting customer info and sending personalized outreach
3. **Processes customer replies** with AI-powered, context-aware responses
4. **Notifies the manager** when customers show strong buying signals

Here's the workflow:

```
Manager sends email with customer info
         ↓
    Agent extracts customer email
         ↓
    Agent generates AI sales pitch → Sends to customer
         ↓
    Agent confirms to manager
         ↓
    [Customer replies]
         ↓
    Agent detects intent + generates AI response
         ↓
    If interested → Notifies manager
```

## WebSocket vs Webhook: Why WebSocket?

| Feature      | Webhook Approach            | WebSocket Approach       |
| ------------ | --------------------------- | ------------------------ |
| Setup        | Requires ngrok + public URL | No external tools needed |
| Architecture | Flask server + HTTP         | Pure async Python        |
| Latency      | HTTP round-trip             | Instant streaming        |
| Firewall     | Must expose port            | Outbound only            |

For more details, see the [WebSocket API Reference](/api-reference/websockets) and the [Python SDK WebSocket documentation](https://github.com/agentmail-to/agentmail-python?tab=readme-ov-file#websockets).

## Prerequisites

Before you begin, make sure you have:

<Callout intent="info">
  **Required:**

  * Python 3.11 or higher installed
  * An [AgentMail account](https://console.agentmail.to) and API key
  * An [OpenAI account](https://platform.openai.com) and API key
</Callout>

## Project Setup

### Step 1: Create Project Directory

Create a new directory for your agent:

```bash
mkdir sales-agent-websocket
cd sales-agent-websocket
```

### Step 2: Create the Agent Code

Create a file named `main.py` and paste the following code:

<Accordion title="Click to view full main.py code">
  ```python
  """
  Sales Agent using AgentMail WebSocket

  This is a simple example showing how to:
  - Connect to AgentMail via WebSocket for real-time email processing
  - Use OpenAI to handle sales conversations
  - Send emails to customers and respond to replies
  """

  import asyncio
  import os
  import re
  from dotenv import load_dotenv
  from agentmail import AsyncAgentMail, Subscribe, Subscribed, MessageReceivedEvent
  from openai import AsyncOpenAI

  # Load environment variables
  load_dotenv()

  # Initialize clients
  agentmail = AsyncAgentMail(api_key=os.getenv("AGENTMAIL_API_KEY"))
  openai = AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY"))

  # Simple conversation history (thread_id -> messages)
  conversations = {}

  # Store manager email for notifications
  manager_email = None


  def extract_email(from_field):
      """Extract email address from 'Name <email@example.com>' format"""
      match = re.search(r'<(.+?)>', from_field)
      return match.group(1) if match else from_field


  def is_from_manager(email_body):
      """Simple check if email is from sales manager (contains customer info)"""
      keywords = ['customer', 'lead', 'contact', 'reach out', 'email']
      return any(keyword in email_body.lower() for keyword in keywords)


  def extract_customer_info(email_body):
      """Extract customer email from manager's message"""
      email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
      emails = re.findall(email_pattern, email_body)

      # Return the first email found (should be the customer's email in the message body)
      if emails:
          return emails[0]
      return None


  async def get_ai_response(messages, system_prompt):
      """Get response from OpenAI"""
      try:
          response = await openai.chat.completions.create(
              model="gpt-4o-mini",
              messages=[
                  {"role": "system", "content": system_prompt},
                  *messages
              ],
              temperature=0.7,
          )
          return response.choices[0].message.content
      except Exception as e:
          print(f"Error getting AI response: {e}")
          return "I apologize, but I encountered an error. Please try again."


  async def send_email(inbox_id, to_email, subject, body):
      """Send a new email"""
      try:
          await agentmail.inboxes.messages.send(
              inbox_id=inbox_id,
              to=[to_email],
              subject=subject,
              text=body
          )
          print(f"✓ Sent email to {to_email}")
      except Exception as e:
          print(f"Error sending email: {e}")


  async def reply_to_email(inbox_id, message_id, to_email, body):
      """Reply to an email"""
      try:
          await agentmail.inboxes.messages.reply(
              inbox_id=inbox_id,
              message_id=message_id,
              to=[to_email],  # Required parameter for replies
              text=body
          )
          print(f"✓ Sent reply to {to_email}")
      except Exception as e:
          print(f"Error replying: {e}")


  async def handle_manager_email(inbox_id, message_id, from_email, subject, body):
      """Handle email from sales manager - extract customer and send sales pitch"""
      global manager_email
      manager_email = from_email  # Remember manager for future notifications

      print(f"\n📧 Email from MANAGER: {from_email}")

      # Extract customer email
      customer_email = extract_customer_info(body)
      print(f"→ Extracted customer email: {customer_email}")

      if not customer_email:
          await reply_to_email(
              inbox_id,
              message_id,
              from_email,  # Reply back to the manager
              "I couldn't find a customer email address. Please include it in your message."
          )
          return

      # Generate sales pitch using AI
      system_prompt = """You are a helpful sales agent. Generate a brief, professional sales email
      based on the manager's request. Keep it under 150 words. Be friendly and professional."""

      messages = [{"role": "user", "content": f"Create a sales email based on this: {body}"}]
      sales_pitch = await get_ai_response(messages, system_prompt)

      # Send email to customer
      await send_email(
          inbox_id,
          customer_email,
          f"Introduction: {subject}" if subject else "Quick Introduction",
          sales_pitch
      )

      # Confirm to manager
      await reply_to_email(
          inbox_id,
          message_id,
          from_email,  # Reply back to the manager
          f"✓ I've sent an introduction email to {customer_email}.\n\nHere's what I sent:\n\n{sales_pitch}"
      )


  async def handle_customer_email(inbox_id, message_id, thread_id, from_email, subject, body):
      """Handle email from customer - track conversation, detect intent, and notify manager"""
      print(f"\n📧 Email from CUSTOMER: {from_email}")

      # Track conversation history
      if thread_id not in conversations:
          conversations[thread_id] = []
      conversations[thread_id].append({"role": "user", "content": body})

      # Detect customer intent
      intent_keywords = {
          'interested': ['interested', 'demo', 'meeting', 'tell me more', 'sounds good'],
          'not_interested': ['not interested', 'no thank', 'not right now', 'maybe later'],
          'question': ['?', 'how', 'what', 'when', 'why', 'can you']
      }

      body_lower = body.lower()
      intent = 'question'  # default
      for key, keywords in intent_keywords.items():
          if any(keyword in body_lower for keyword in keywords):
              intent = key
              break

      # Generate AI response
      system_prompt = """You are a helpful sales agent. Answer customer questions professionally
      and helpfully. Keep responses brief (under 100 words). Be friendly but professional."""

      response = await get_ai_response(conversations[thread_id], system_prompt)

      # Reply to customer
      await reply_to_email(inbox_id, message_id, from_email, response)

      # Notify manager if strong intent signal
      if manager_email and intent in ['interested', 'not_interested']:
          status = "showing interest" if intent == 'interested' else "not interested at this time"
          await send_email(
              inbox_id,
              manager_email,
              f"Update: {from_email}",
              f"Customer {from_email} is {status}.\n\nTheir message:\n{body}\n\nMy response:\n{response}"
          )
          print(f"→ Notified manager about customer's {intent}")

      # Update conversation history
      conversations[thread_id].append({"role": "assistant", "content": response})


  async def handle_new_email(message):
      """Process incoming email from WebSocket"""
      try:
          # Extract message data using object attributes
          inbox_id = message.inbox_id
          message_id = message.message_id
          thread_id = message.thread_id
          from_field = message.from_ or ""  # SDK uses from_
          from_email = extract_email(from_field)
          subject = message.subject or ""
          body = message.text or ""  # SDK uses text for the body

          print(f"\n{'='*60}")
          print(f"New email from: {from_email}")
          print(f"Subject: {subject}")
          print(f"{'='*60}")

          # Determine if from manager or customer
          if is_from_manager(body):
              await handle_manager_email(inbox_id, message_id, from_email, subject, body)
          else:
              await handle_customer_email(inbox_id, message_id, thread_id, from_email, subject, body)

      except Exception as e:
          print(f"Error handling email: {e}")


  async def main():
      """Main WebSocket loop"""
      inbox_username = os.getenv("INBOX_USERNAME", "sales-agent")
      inbox_id = f"{inbox_username}@agentmail.to"

      print(f"\nSales Agent starting...")
      print(f"Inbox: {inbox_id}")
      print(f"✓ Connecting to AgentMail WebSocket...")

      # Connect to WebSocket
      try:
          async with agentmail.websockets.connect() as socket:
              print(f"✓ Connected! Listening for emails...\n")

              # Subscribe to inbox
              await socket.send_subscribe(Subscribe(inbox_ids=[inbox_id]))

              # Listen for events
              async for event in socket:
                  if isinstance(event, Subscribed):
                      print(f"✓ Subscribed to: {event.inbox_ids}\n")

                  elif isinstance(event, MessageReceivedEvent):
                      print(f"📨 New email received!")
                      await handle_new_email(event.message)

      except (KeyboardInterrupt, asyncio.CancelledError):
          print("\n\nShutting down gracefully...")
      except Exception as e:
          print(f"\nError: {e}")


  def run():
      """Run the main function"""
      try:
          asyncio.run(main())
      except KeyboardInterrupt:
          print("\n✓ Shutdown complete")


  if __name__ == "__main__":
      run()
  ```
</Accordion>

### Step 3: Create Requirements File

Create a file named `requirements.txt`:

```txt
agentmail>=0.0.19
openai>=1.0.0
python-dotenv>=1.0.0
```

### Step 4: Install Dependencies

Install the required Python packages:

```bash
pip install -r requirements.txt
# or with pyproject.toml
pip install .
```

### Step 5: Configure Environment Variables

Create a `.env` file with your credentials:

```env
# AgentMail Configuration
AGENTMAIL_API_KEY=your_agentmail_api_key_here

# OpenAI Configuration
OPENAI_API_KEY=your_openai_api_key_here

# Inbox Settings
INBOX_USERNAME=sales-agent
```

<Callout intent="info">
  **Note:** Unlike webhook-based agents, you don't need ngrok or a public URL. The WebSocket connection is outbound only, so it works behind firewalls without any port forwarding.
</Callout>

## Code Walkthrough

Let's understand how the agent works by breaking down the key components.

### Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                      Your Python Script                      │
│                                                              │
│  ┌──────────────┐     ┌──────────────┐     ┌─────────────┐  │
│  │ AsyncAgent   │────▶│ WebSocket    │────▶│ Event       │  │
│  │ Mail Client  │     │ Connection   │     │ Handler     │  │
│  └──────────────┘     └──────────────┘     └─────────────┘  │
│         │                    ▲                    │          │
│         │                    │                    ▼          │
│         │              Real-time            ┌─────────────┐  │
│         │              Events               │ OpenAI      │  │
│         │                                   │ Integration │  │
│         ▼                                   └─────────────┘  │
│  ┌──────────────┐                                           │
│  │ Send/Reply   │◀──────────────────────────────────────────│
│  │ Emails       │                                           │
│  └──────────────┘                                           │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌──────────────────┐
                    │   AgentMail      │
                    │   Cloud          │
                    └──────────────────┘
```

### 1. WebSocket Connection Setup

The core of this agent is the WebSocket connection:

```python
from agentmail import AsyncAgentMail, Subscribe, Subscribed, MessageReceivedEvent

# Initialize the async client
agentmail = AsyncAgentMail(api_key=os.getenv("AGENTMAIL_API_KEY"))

# Connect and subscribe
async with agentmail.websockets.connect() as socket:
    await socket.send_subscribe(Subscribe(inbox_ids=[inbox_id]))
```

**Key points:**

* `AsyncAgentMail` is the async version of the client
* `agentmail.websockets.connect()` creates the WebSocket connection
* `Subscribe` specifies which inboxes to monitor

### 2. Event Handling Loop

The agent uses an async iterator pattern to process events:

```python
async for event in socket:
    if isinstance(event, Subscribed):
        print(f"✓ Subscribed to: {event.inbox_ids}")

    elif isinstance(event, MessageReceivedEvent):
        await handle_new_email(event.message)
```

**Event types:**

* `Subscribed` - Confirmation that subscription was successful
* `MessageReceivedEvent` - A new email arrived in the inbox

### 3. Email Processing Flow

The agent routes emails based on content:

```python
async def handle_new_email(message):
    # Extract fields from the message object
    inbox_id = message.inbox_id
    message_id = message.message_id
    thread_id = message.thread_id
    from_field = message.from_ or ""  # Note: SDK uses from_
    from_email = extract_email(from_field)
    subject = message.subject or ""
    body = message.text or ""

    # Route based on email content
    if is_from_manager(body):
        await handle_manager_email(inbox_id, message_id, from_email, subject, body)
    else:
        await handle_customer_email(inbox_id, message_id, thread_id, from_email, subject, body)
```

**Email extraction helper:**

```python
def extract_email(from_field):
    """Extract email from 'Name <email@example.com>' format"""
    match = re.search(r'<(.+?)>', from_field)
    return match.group(1) if match else from_field
```

### 4. Manager Email Handler

When the manager sends an email with customer info:

```python
async def handle_manager_email(inbox_id, message_id, from_email, subject, body):
    global manager_email
    manager_email = from_email  # Remember for notifications

    # Extract customer email using regex
    customer_email = extract_customer_info(body)

    if not customer_email:
        await reply_to_email(inbox_id, message_id, from_email,
            "I couldn't find a customer email. Please include it.")
        return

    # Generate AI sales pitch
    sales_pitch = await get_ai_response(
        [{"role": "user", "content": f"Create a sales email based on: {body}"}],
        "You are a helpful sales agent. Generate a brief, professional email..."
    )

    # Send to customer
    await send_email(inbox_id, customer_email, f"Introduction: {subject}", sales_pitch)

    # Confirm to manager
    await reply_to_email(inbox_id, message_id, from_email,
        f"✓ Sent email to {customer_email}.\n\nContent:\n{sales_pitch}")
```

### 5. Customer Email Handler with Intent Detection

The agent tracks conversations and detects customer intent:

```python
async def handle_customer_email(inbox_id, message_id, thread_id, from_email, subject, body):
    # Track conversation history per thread
    if thread_id not in conversations:
        conversations[thread_id] = []
    conversations[thread_id].append({"role": "user", "content": body})

    # Detect intent with keyword matching
    intent_keywords = {
        'interested': ['interested', 'demo', 'meeting', 'tell me more'],
        'not_interested': ['not interested', 'no thank', 'maybe later'],
        'question': ['?', 'how', 'what', 'when', 'why']
    }

    intent = 'question'  # default
    for key, keywords in intent_keywords.items():
        if any(kw in body.lower() for kw in keywords):
            intent = key
            break

    # Generate contextual AI response using conversation history
    response = await get_ai_response(conversations[thread_id], system_prompt)

    # Reply to customer
    await reply_to_email(inbox_id, message_id, from_email, response)

    # Notify manager of strong signals
    if manager_email and intent in ['interested', 'not_interested']:
        await send_email(inbox_id, manager_email, f"Update: {from_email}",
            f"Customer is {intent}.\n\nTheir message:\n{body}")
```

### 6. AI Response Generation

The agent uses OpenAI for generating responses:

```python
async def get_ai_response(messages, system_prompt):
    try:
        response = await openai.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": system_prompt},
                *messages  # Include conversation history
            ],
            temperature=0.7,
        )
        return response.choices[0].message.content
    except Exception as e:
        print(f"Error: {e}")
        return "I apologize, but I encountered an error."
```

**Key points:**

* Includes full conversation history for context
* Graceful error handling with fallback message

## Running the Agent

Start the agent:

```bash
python main.py
```

You should see output like this:

```
Sales Agent starting...
Inbox: sales-agent@agentmail.to
✓ Connecting to AgentMail WebSocket...
✓ Connected! Listening for emails...

✓ Subscribed to: ['sales-agent@agentmail.to']
```

<Callout intent="success">
  **Success!** Your agent is now running and listening for emails in real-time.

  Leave this terminal window open - closing it will stop the agent.
</Callout>

## Testing Your Agent

Let's verify everything works with some test scenarios.

### Test Scenario: Manager Outreach Request

**Send this email from your personal email:**

```
To: sales-agent@agentmail.to
Subject: New lead - AI startup
Body: Please reach out to this customer: customer-email@gmail.com
      They're interested in our API platform.
```

**Expected console output:**

```
============================================================
New email from: your-email@gmail.com
Subject: New lead - AI startup
============================================================

📧 Email from MANAGER: your-email@gmail.com
→ Extracted customer email: customer-email@gmail.com
✓ Sent email to customer-email@gmail.com
✓ Sent reply to your-email@gmail.com
```

**You'll receive:** A confirmation email with the sales pitch that was sent.

<Callout intent="success">
  **It works!** The agent processed emails in real-time, generated AI responses, and notified you about the interested customer.
</Callout>

## Customization

### Modifying Intent Detection

Update the `intent_keywords` dictionary in `handle_customer_email()`:

```python
intent_keywords = {
    'interested': ['interested', 'demo', 'meeting', 'pricing', 'sign up'],
    'not_interested': ['not interested', 'unsubscribe', 'remove me'],
    'question': ['?', 'how', 'what', 'when', 'can you'],
    'urgent': ['urgent', 'asap', 'immediately']  # Add new intent
}
```

### Adding More Inbox Subscriptions

Subscribe to multiple inboxes:

```python
await socket.send_subscribe(Subscribe(inbox_ids=[
    "sales-agent@agentmail.to",
    "support-agent@agentmail.to",
    "info@yourdomain.com"
]))
```

## Troubleshooting

### Common Issues

<Accordion title="WebSocket connection refused or timeout">
  **Problem:** Cannot connect to AgentMail WebSocket.

  **Solutions:**

  1. Verify your API key is correct:

  ```python
  client = AsyncAgentMail(api_key="your-key")
  print(await client.inboxes.list())  # Should succeed
  ```

  2. Check your internet connection and firewall settings
  3. Ensure you're using `agentmail>=0.0.19` which includes WebSocket support:

  ```bash
  pip show agentmail
  ```
</Accordion>

<Accordion title="Emails not being received">
  **Problem:** Agent is running but not receiving emails.

  **Checklist:**

  1. Verify the inbox exists:

  ```python
  client = AsyncAgentMail()
  print(await client.inboxes.get("sales-agent@agentmail.to"))
  ```

  2. Check subscription confirmation in console output
  3. Send test email to the correct inbox address
  4. Verify the email isn't being filtered as spam
</Accordion>

<Accordion title="Agent crashes with asyncio errors">
  **Problem:** Async-related exceptions.

  **Solutions:**

  1. Ensure Python 3.11+ is installed:

  ```bash
  python --version
  ```

  2. Don't mix sync and async code improperly
  3. Use `asyncio.run(main())` as the entry point
</Accordion>

***

If you build something cool with AgentMail, we'd love to hear about it. Share in our [Discord community](https://discord.gg/hTYatWYWBc)!


# Live AgentMail Examples

# Live Email Agents

We have several deployed agents running in production that demonstrate the power of AgentMail. These agents showcase different use cases and capabilities of our platform.

<Steps>
  <Step title="Connector Agent: connect@agentmail.to">
    <p>
      Our Connector Agent specializes in building relationships and networking through email.
      It can analyze email content, identify key contacts, and automatically follow up with
      personalized messages to strengthen professional connections.
    </p>

    <div>
      <iframe src="https://www.linkedin.com/embed/feed/update/urn:li:ugcPost:7356006982559936512?compact=1" height="399" width="504" frameborder="0" allowfullscreen="" title="Embedded post" />
    </div>
  </Step>

  <Step title="Hiring Agent: hiring@agentmail.to">
    <p>
      The Hiring Agent streamlines recruitment processes by automatically
      screening candidates, scheduling interviews, and managing communication
      throughout the hiring pipeline. It reduces manual work and ensures no
      promising candidates fall through the cracks.
    </p>

    <div>
      <iframe src="https://www.linkedin.com/embed/feed/update/urn:li:ugcPost:7361454978672070660?compact=1" height="399" width="504" frameborder="0" allowfullscreen="" title="Embedded post" />
    </div>
  </Step>
</Steps>

## Get Started

Ready to build your own intelligent email agent? Check out our [quickstart guide](/get-started/quickstart) or explore the [API reference](/api-reference) to see what's possible.

<Note>
  These agents are running in production and handling real email communications.
  Want to see them in action? [Contact us](mailto:contact@agentmail.cc) for a
  demo.
</Note>


# Frequently Asked Questions (FAQ)

> Find answers to common questions about AgentMail, from core concepts to best practices and security.

<AccordionGroup>
  <Accordion title="What is AgentMail?">
    AgentMail is an API-first email platform designed specifically for building
    AI agents that can communicate over email. While traditional email APIs are
    built for sending one-way notifications, AgentMail is built for two-way
    conversations, making it easy to create agents that can read, understand,
    and reply to emails in a thread, just like a human would.
  </Accordion>

  <Accordion title="How is AgentMail different from services like SendGrid or Mailgun?">
    The key difference is our focus on **conversational agents**. Services like
    SendGrid are excellent for transactional emails (receipts, password resets)
    and marketing campaigns. These are done via a GUI. Resend is an API that is
    great to do those transactional emails as well. BUT AgentMail is built for
    the unique challenges allowing agents to have 2-way conversation over email,
    with first-class support for concepts like `Threads`, `Inboxes`, and
    `Attachments` to manage complex, stateful conversations over email.
  </Accordion>

  <Accordion title="Can I use my own custom domain to send emails?">
    Yes, absolutely! While you can get started instantly with an `@agentmail.to`
    inbox, we highly recommend setting up your own custom domain for production
    use. This improves deliverability and ensures emails come from your brand.
    You can find a complete guide [here](/custom-domains).
  </Accordion>

  <Accordion title="What's the best way to process incoming emails?">
    For production applications, **Webhooks are the recommended method**. They
    provide real-time notifications and are far more efficient than constantly
    polling the API for new messages. You can learn how to set them up in our
    [Webhooks Overview](/overview).
  </Accordion>

  <Accordion title="How do I make sure I don't end up in spam?">
    Email deliverability is a complex topic. We go in depth in our [Email
    Deliverability best practices guide](/email-deliverability).
  </Accordion>

  <Accordion title="Do you have SDKs available?">
    Yes! We currently offer official SDKs for Node.js/TypeScript and Python to
    make integrating with AgentMail as easy as possible. You can find links and
    information in our [API reference](/api-reference).
  </Accordion>
</AccordionGroup>


# Email Reply Extraction with Talon

> Learn how to use Talon to extract new content from email replies, removing quoted text with 93.8% accuracy.

## Why Talon?

Email threads accumulate quoted replies that clutter the actual content. When processing emails programmatically, you need just the new message, not the entire conversation history.

**Talon solves this problem** by extracting clean reply content through sophisticated pattern matching and structural analysis.

### Use Cases

* **AI Email Agents**: Extract new user messages without processing entire thread history
* **Email Automation**: Parse replies to identify actionable content
* **Thread Analysis**: Build conversation flows by isolating individual contributions
* **Inbox Management**: Process only new information from replies

### Why Choose Talon?

<CardGroup cols={2}>
  <Card title="HTML Email Support" icon="fa-regular fa-file-code">
    Handles Gmail, Outlook, Apple Mail, Thunderbird HTML structures
  </Card>

  <Card title="High Accuracy" icon="fa-regular fa-bullseye">
    93.8% success rate across 64 real-world test cases
  </Card>

  <Card title="Multi-language" icon="fa-regular fa-globe">
    Supports English, Japanese, Swedish, Polish, Dutch, German
  </Card>

  <Card title="Fast Performance" icon="fa-regular fa-gauge-high">
    1.92ms average processing time, 488 emails/second
  </Card>
</CardGroup>

***

## How Talon Works

Talon uses two complementary approaches depending on email format:

### Plain Text Processing (6-Stage Pipeline)

1. **Line Classification**: Assigns markers to each line ('t'=text, 'm'=quote marker, 's'=splitter, 'e'=empty)
2. **Pattern Matching**: Applies regex to marker sequences to identify quoted blocks
3. **Content Extraction**: Removes quoted lines and returns clean text

Recognizes patterns like:

* Standard quote markers (`>`)
* Reply headers ("On \[date] \[name] wrote:")
* Forward indicators ("-----Original Message-----")

### HTML Processing (8-Stage Pipeline)

1. **Structural Removal**: Directly removes known quotation elements (Gmail divs, blockquotes, Outlook markup)
2. **Checkpoint Fallback**: For non-standard HTML, maps elements to text lines, applies text patterns, removes corresponding HTML

### Processing Systems

**Quotation Removal** (Primary)

* Removes quoted replies from thread
* No initialization required
* Rule-based pattern matching

***

## Getting Started

<Steps>
  <Step title="Install Talon">
    Install via pip with required workaround for Python 3.11+:

    <CodeBlocks>
      ```bash
      pip install talon
      ```
    </CodeBlocks>
  </Step>

  <Step title="Apply Python 3.11+ Workaround">
    Required fix for cchardet dependency:

    <CodeBlocks>
      ```python
      # Import workaround BEFORE importing talon
      import sys
      import chardet
      sys.modules['cchardet'] = chardet

      # Now safe to import talon
      import talon
      from talon import quotations
      ```
    </CodeBlocks>

    <Callout intent="warn">
      This workaround is **required** for Python 3.11+.
    </Callout>
  </Step>

  <Step title="Extract Reply Content">
    Basic usage for plain text and HTML:

    <CodeBlocks>
      ```python title="Plain Text"
      from talon import quotations

      email = """Great work on the project!

      On Mon, Apr 11, 2011 at 6:54 PM, Bob wrote:
      > Can you review the document?
      > Need feedback by Friday.
      """

      clean_reply = quotations.extract_from_plain(email)
      # Result: "Great work on the project!"
      ```

      ```python title="HTML"
      from talon import quotations

      html_email = """
      <html><body>
      <div>Thanks for the update!</div>
      <div class="gmail_quote">
        <div>On Mon, Alice wrote:</div>
        <blockquote>Original message here</blockquote>
      </div>
      </body></html>
      """

      clean_html = quotations.extract_from_html(html_email)
      # Returns: <html><body><div>Thanks for the update!</div></body></html>
      ```
    </CodeBlocks>
  </Step>
</Steps>

***

## Performance & Accuracy

Talon has been tested on 64 real-world emails from various clients and languages.

### Test Results Summary

| Metric                  | Value               |
| ----------------------- | ------------------- |
| **Total Tests**         | 64 emails           |
| **Passed**              | 60 (93.8%)          |
| **Failed**              | 4 (6.2%)            |
| **Avg Processing Time** | 1.92ms              |
| **Throughput**          | 488.6 emails/second |
| **Min/Max Time**        | 0.13ms - 21.55ms    |

### Test Coverage

* **22 HTML emails**: Gmail, Outlook, Apple Mail, Thunderbird, Mail.ru, Hotmail
* **42 plain text emails**: Various formats and reply styles
* **6+ languages**: English, Japanese, Swedish, Polish, Dutch, German
* **Mobile clients**: iPhone, Android "Sent from" signatures

### Processing Time by Complexity

| Email Type         | Avg Time  | Complexity |
| ------------------ | --------- | ---------- |
| Simple text reply  | 0.2-0.5ms | Low        |
| HTML Gmail/Outlook | 2-4ms     | Medium     |
| Complex threads    | 4-22ms    | High       |

### Speed vs Accuracy Tradeoff

| Library      | Avg Processing Time | Accuracy | Best For                                |
| ------------ | ------------------- | -------- | --------------------------------------- |
| **Talon**    | 1.92ms              | 93.8%    | Production systems needing HTML support |
| qutoequail   | 0.96ms              | \~85%    | Moderate accuracy requirements          |
| Custom regex | 0.1ms               | \~70%    | Simple plain text, speed critical       |

**Insight**: For production systems, 1.92ms average is negligible. Even at worst case (21.55ms), Talon is faster than most network requests.

***

## Known Limitations

Talon failed 4 out of 64 test cases. Here's what didn't work:

<AccordionGroup>
  <Accordion title="Failed Test Cases (4 total)">
    ### Test Case 1: Complex Email Thread with Mixed Content

    **Input**:

    ```text
    Thank you, Sonya Johnson.

    I have sent an invite for 10:30am Monday PDT (today). I
    hope you can join.

    Regards,

    Christopher Edwards


    On Mon, Jun 3, 2024 at 12:53 AM Cody Hart <omerritt@example.com> wrote:

    > Hi Christopher Edwards,
    >
    > 10.30 AM pacific is good for me.
    >
    > Thanks & Regards,
    >
    > Cody Hart
    ```

    **Expected Output**: First 5 lines only (up to `Christopher Edwards`)

    **Talon's Output**: Returns entire email including quoted text starting with "On Mon, Jun 3..." and all "> quoted text"

    **Processing Time**: 2.55ms

    **Issue**: Signature placement before quotes confuses detection logic

    ***

    ### Test Case 2: Inline Responses

    **Input**:

    ```text
    On Tue, Apr 29, 2014 at 4:22 PM, Example Dev <sugar@example.com> wrote:

    > okay. Well, here's some stuff I can write.
    >
    > And if I write a 2 second line you and maybe reply under this?
    >
    > Or if you didn't really feel like it, you could reply under this line.

    I will reply under this one

    >
    > okay?
    >

    and under this.

    >
    > -- Tim
    ```

    **Expected Output**: Just the inline responses (`I will reply under this one` and `and under this.`)

    **Talon's Output**: Returns everything including "On Tue, Apr 29..." header and all quoted lines

    **Processing Time**: 0.48ms

    **Issue**: Interleaved inline responses not recognized as the reply pattern

    ***

    ### Test Case 3: Gmail Forward HTML

    **Input**:

    ```html
    <html><head></head><body><div dir="ltr">test<div><br /></div><div>blah</div>
    <div><br /><div class="gmail_quote">---------- Forwarded message ----------<br />
    From: <b class="gmail_sendername">Foo Bar</b>
    <span dir="ltr">&lt;<a href="mailto:foo@bar.example">foo@bar.example</a>&gt;</span><br />
    Date: Thu, Mar 24, 2016 at 5:17 PM<br />
    Subject: The Subject<br />
    To: John Doe &lt;<a href="mailto:john@doe.example">john@doe.example</a>&gt;<br />
    <br /><br /><div dir="ltr">Some text<div><br /></div><div><br /></div></div>
    </div><br /></div></div></body></html>
    ```

    **Expected Output**: Just `testblah` (before the forward marker)

    **Talon's Output**: Includes "---------- Forwarded message ----------" and forwarded content

    **Processing Time**: 3.41ms

    **Issue**: HTML forward headers not removed by Gmail quote detection

    ***

    ### Test Case 4: Thunderbird Forward HTML

    **Input**:

    ```html
    <html><body bgcolor="#FFFFFF" text="#000000">
    <p><br /></p>
    <div class="moz-forward-container"><br /><br />
    -------- Forwarded Message --------
    <table class="moz-email-headers-table">
      <tbody>
        <tr><th>Subject:</th><td>Re: Example subject</td></tr>
        <tr><th>Date:</th><td>Tue, 3 May 2016 14:54:27 +0200 (CEST)</td></tr>
        <tr><th>From:</th><td>John Doe &lt;johndoe@example.com&gt;</td></tr>
      </tbody>
    </table>
    <br /><br />
    <div>Dear John,</div>
    <div><br /></div>
    <div>This is a test.</div>
    </div></body></html>
    ```

    **Expected Output**: Empty (no new content, just forward)

    **Talon's Output**: Includes "-------- Forwarded Message --------" and forwarded content

    **Processing Time**: 4.34ms

    **Issue**: Thunderbird's `moz-forward-container` class not recognized

    ***

    **Summary**: 3 of 4 failures are forwarded messages. Regular replies work with 98%+ accuracy.
  </Accordion>

  <Accordion title="Success Examples">
    ### Example 1: Simple Gmail Reply

    **Input**:

    ```text
    Awesome! I haven't had another problem with it.

    On Aug 22, 2011, at 7:37 PM, defunkt<reply@reply.github.com> wrote:




    > Loader seems to be working well.
    ```

    **Talon's Output**: `Awesome! I haven't had another problem with it.`

    **Processing Time**: 0.2ms

    **What Worked**: Standard "On \[date] \[name] wrote:" pattern detected, quote marker (>) recognized

    ***

    ### Example 2: Outlook Reply with Separator

    **Input**:

    ```text
    Outlook with a reply directly above line
    ________________________________________
    From: CRM Comments [crm-comment@example.com]
    Sent: Friday, 23 March 2012 5:08 p.m.
    To: John S. Greene
    Subject: [contact:106] John Greene

    A new comment has been added to the Contact named 'John Greene':

    I am replying to a comment.
    ```

    **Talon's Output**: `Outlook with a reply directly above line`

    **Processing Time**: 0.51ms

    **What Worked**: Outlook separator line (underscores) and "From:"/"Sent:" headers detected as splitter

    ***

    ### Example 3: HTML Outlook Reply

    **Input**:

    ```html
    <html>
      <body>
        <div>Reply</div>
        <span id="OLK_SRC_BODY_SECTION">
          <div>
            <span>From: </span>Bob &lt;<a href="mailto:bob@example.com">bob@example.com</a>&gt;<br />
            <span>Date: </span>Tue, 01 Nov 2011 18:54:39 -0700<br />
            <span>To: </span>Rob &lt;<a href="mailto:rob@example.com">rob@example.com</a>&gt;<br />
            <span>Subject: </span>Test<br />
          </div>
          <div>Hi</div>
        </span>
      </body>
    </html>
    ```

    **Talon's Output**: `Reply`

    **Processing Time**: 4.02ms

    **What Worked**: Outlook's `OLK_SRC_BODY_SECTION` span ID detected and removed structurally
  </Accordion>

  <Accordion title="Performance vs Simpler Alternatives">
    **Tradeoff**: Talon is more comprehensive but slower than plain-text-only libraries

    * Talon: 1.92ms average (with HTML support)
    * email-reply-parser: 0.03ms average (plain text only)

    For production systems, 1.92ms average is negligible. Even at worst case (21.55ms), Talon is faster than most network requests.
  </Accordion>

  <Accordion title="Forwarded Messages">
    As shown in test results, forwarded messages (especially HTML) are challenging:

    * Plain text forwards: Generally work well
    * HTML forwards: May retain forward headers
    * Workaround: Use plain text extraction or post-process to remove forward markers
  </Accordion>
</AccordionGroup>

***

### Error Handling

Always handle potential parsing failures:

```python
from talon import quotations

def safe_extract(email_body, is_html=False):
    try:
        if is_html:
            return quotations.extract_from_html(email_body)
        else:
            return quotations.extract_from_plain(email_body)
    except Exception as e:
        # Fallback to original message if extraction fails
        print(f"Talon extraction failed: {e}")
        return email_body
```

### Testing Recommendations

Always test with your specific email formats:

```python
# Create a test suite with your actual email patterns (Gmail, Outlook, Apple Mail)
test_emails = [
    "path/to/gmail_reply.html",
    "path/to/outlook_reply.txt",
    "path/to/forward.html"
]

for email_file in test_emails:
    with open(email_file) as f:
        content = f.read()
        result = quotations.extract_from(content)
        print(f"{email_file}: {len(result)} chars extracted")
```

<Tip>
  Test with real emails from your users' actual email clients. Talon's accuracy is based on diverse real-world samples, but your specific use case may have unique patterns.
</Tip>

***

## JavaScript Version

For TypeScript/JavaScript projects, use **[TalonJS](https://github.com/quentez/talonjs)** - a JavaScript port of Talon with similar functionality.

### Performance Comparison

| Solution         | Accuracy | Speed  | Best For                    |
| ---------------- | -------- | ------ | --------------------------- |
| **Python Talon** | 93.8%    | 1.92ms | Highest accuracy            |
| **TalonJS**      | 90.6%    | 1.88ms | TypeScript/Node.js projects |

TalonJS provides 90.6% accuracy with slightly faster performance (1.88ms), making it ideal for JavaScript/TypeScript environments without needing Python dependencies.

### Quick Start

<Steps>
  <Step title="Install TalonJS">
    ```bash
    npm install talonjs
    ```
  </Step>

  <Step title="Extract Replies">
    <CodeBlocks>
      ```typescript title="Plain Text"
      import * as talon from 'talonjs';

      const email = `Great work on the project!

      On Mon, Apr 11, 2011 at 6:54 PM, Bob wrote:
      > Can you review the document?
      > Need feedback by Friday.
      `;

      const result = talon.quotations.extractFromPlain(email);
      const cleanReply = result.body.trim();
      // Output: "Great work on the project!"
      ```

      ```typescript title="HTML"
      import * as talon from 'talonjs';

      const htmlEmail = `
        <div>Thanks for the update!</div>
        <div class="gmail_quote">
          On Mon, Alice wrote: <blockquote>Original</blockquote>
        </div>
      `;

      const result = talon.quotations.extractFromHtml(htmlEmail);
      const cleanReply = result.body.trim();
      // Returns: "<div>Thanks for the update!</div>"
      // Note: TalonJS returns clean HTML, not plain text
      ```
    </CodeBlocks>
  </Step>
</Steps>

<Tip>
  **When to use TalonJS vs Python Talon:**

  * Use **TalonJS** if you're building in TypeScript/JavaScript and 90.6% accuracy is sufficient
  * Use **Python Talon** if you need the highest accuracy (93.8%) or are in a Python environment
  * The 3.2% accuracy difference is acceptable for most use cases
</Tip>


# Join the AgentMail Community

> Connect with the AgentMail team and developers, share what you're building, and get support.

<CardGroup>
  <Card title="Join our Discord Server" href="https://discord.com/invite/hTYatWYWBc" icon="fa-brands fa-discord">
    The best place for real-time conversation, getting help with your code, and
    sharing what you're building with AgentMail.
  </Card>

  <Card title="Follow us on X (Twitter)" href="https://twitter.com/agentmail" icon="fa-brands fa-x-twitter">
    Stay up-to-date with the latest product announcements, community highlights,
    and tips for building better agents.
  </Card>

  <Card title="Connect on LinkedIn" href="https://linkedin.com/company/agentmailto" icon="fa-brands fa-linkedin">
    Follow our company page for official updates, industry insights, and
    professional networking with the team.
  </Card>
</CardGroup>

<Callout title="Premium Support for Customers" intent="info" icon="fa-brands fa-slack">
  For purchasing customers, we offer dedicated support channels to ensure your success. Get priority assistance, custom integration help, and a private Slack channel with our core engineering team.

  To learn more about our premium plans and dedicated support options, please visit our website [here](https://agentmail.to/pricing).
</Callout>


# Support

> Get help with AgentMail through our support channels.

## Need Help?

<Cards>
  <Card title="GitHub Issues" icon="fa-brands fa-github" href="https://github.com/agentmail-to" />

  <Card title="Discord Community" icon="fa-brands fa-discord" href="https://discord.gg/ZYN7f7KPjS" />

  <Card title="Email Support" icon="fa-solid fa-envelope" href="mailto:support@agentmail.cc" />
</Cards>


# Understanding Email Authentication (SPF, DKIM, DMARC)

> Learn why we ask for DNS records and what SPF, DKIM, and DMARC are.

When you add a custom domain to AgentMail, we ask you to add several records to your DNS settings. We understand that this can seem daunting, and we want to be completely transparent about what these records are and why they are necessary.

In short, by adding these records, you are giving AgentMail **permission** to do two things:

1. **Send emails on your behalf** that are trusted and pass spam filters.
2. **Receive emails for you** so your agents can process them.

This process is standard practice for any third-party email service, and it does **not** give us control over your website or any other part of your domain. Let's break down what each piece does.

## The Pillars of Email Authentication

To prevent spam and phishing, the modern email ecosystem relies on three core technologies: **SPF**, **DKIM**, and **DMARC**. Our goal is to handle all the complexity of these protocols for you.

Your DNS records are simply the way you tell the world that you've authorized us to do so.

### SPF: Sender Policy Framework

* **What it is:** Think of SPF as a public list of all the servers that are allowed to send email for your domain.
* **How it works:** You add a `TXT` record to your DNS that lists the approved IP addresses or domains. When an email server receives a message from `you@your-domain.com`, it checks the SPF record for `your-domain.com`. If the server that sent the email is on that list, the check passes. This is what a record we give you might look like
* **Your Record:**
  ```text
  TXT | mail.domain.com | v=spf1 include:agentmail.com -all
  ```
  This record tells the world that we are an authorized sender for the `mail.domain.com` subdomain. The `-all` part suggests that any server *not* on this list should be considered unauthorized.

### DKIM: DomainKeys Identified Mail

* **What it is:** DKIM is like a digital signature for your emails. This signature proves two things: that the email actually came from your domain and that its content hasn't been messed with with in transit from you to who you are trying to send to.
* **How it works:** We generate a unique, secure key for your domain. When we send an email, we "sign" it with this key. The public part of that key is published in your DNS. Receiving servers use this public key to verify the signature.

These are a couple of records we might ask you to add.

* **Your Records:**
  ```text
  CNAME | b4w..._domainkey.payment... | b4w...dkim.agentmail.com
  CNAME | 32c..._domainkey.payment... | 32c...dkim.agentmail.com
  CNAME | xl4..._domainkey.payment... | xl4...dkim.agentmail.com
  ```
  Instead of having you publish the raw key (which can be messy and needs to be rotated), we use `CNAME` records. These records act as aliases, pointing a specific address on your domain to one managed by us. This allows us to manage the security of your signing keys automatically without you ever needing to change them.

### DMARC: Domain-based Message Authentication, Reporting, and Conformance

* **What it is:** DMARC is the policy that ties SPF and DKIM together. It tells receiving email servers what to do if an email claims to be from you but fails the SPF or DKIM checks(or both).
* **How it works:** You publish a `TXT` record that specifies your policy. You can tell servers to `reject` the message, quarantine it (mark as spam), or do nothing. It also allows you to get reports on which emails are passing and failing these checks.

We typically tell servers to reject the message as this increases deliverability(as you can see, this is something we've done our research on!)

* **Your Record:**
  ```text
  TXT | _dmarc.domain.com | v=DMARC1; p=reject; rua=mailto:dmarc@agentmail.to
  ```
  This policy tells servers to `reject` any email that fails authentication. The `rua` tag specifies that aggregate reports about these failures should be sent to `dmarc@agentmail.to`, allowing us to monitor your domain's health and deliverability on your behalf.

## Receiving Mail: The MX Records

Finally, to receive emails for your agents, you need to tell the internet where to deliver them. This is the job of the **MX (Mail Exchange)** records.

* **What they are:** MX records are the post office address for your domain's email.
* **How they work:** When someone sends an email to `your-agent@your-domain.com`, their mail server looks up the MX record for `your-domain.com` to find out where to send it.

This is some records that we might give you:

* **Your Records:**
  ```text
  MX | domain.com | 10 inbound-agentmail.com
  MX | mail.domain.com | 10 feedback-smtp.agentmail.com
  ```
  The first record directs all incoming mail for your domain to our servers, so we can ingest it and trigger your agents. The second `feedback-smtp` record is specifically for routing automated feedback, like bounce and complaint notifications from other mail servers, which is crucial for maintaining a healthy sender reputation.

We hope this provides a clear and transparent look into why these DNS records are required. By setting them up, you enable AgentMail to provide a secure and reliable email experience for your AI agents.


# SOC 2 Compliance

> AgentMail's SOC 2 Type I achievement and Type II certification progress.

> AgentMail has **achieved SOC 2 Type I compliance** (July 2025) and is currently working toward **Type II certification** (target: Q1 2026).

***

## Current Status

<CardGroup cols={2}>
  <Card title="Type I Achieved" icon="check-circle">
    **Completed July 2025** - Controls properly designed and in place
  </Card>

  <Card title="Type II In Progress" icon="spinner">
    **Target Q1 2026** - Demonstrating operational effectiveness over time
  </Card>
</CardGroup>

### Compliance Timeline

| Phase                          | Period              | Status      |
| ------------------------------ | ------------------- | ----------- |
| **Type I Preparation**         | June 2025           | Completed   |
| **Type I Assessment**          | July 2025           | Completed   |
| **Type II Observation Period** | Aug 2025 - Dec 2025 | In Progress |
| **Type II Certification**      | Q1 2026             | Target      |

***

## What is SOC 2?

**SOC 2** is an attestation standard by **AICPA** (The American Institute of Certified Public Accountants) evaluating controls over:

1. **Security** - Protection against unauthorized access, both physical and logical
2. **Availability** - System accessibility and operational performance as committed
3. **Processing Integrity** - System processing is complete, valid, accurate, timely, and authorized
4. **Confidentiality** - Information designated as confidential is protected
5. **Privacy** - Personal information is collected, used, retained, disclosed, and disposed per privacy commitments

### Report Types

* **Type I**: Verifies that security controls are properly **designed** at a point in time.
* **Type II**: Validates that controls **operate effectively** over a period (typically 6–12 months).

<Callout intent="success">
  AgentMail's SOC 2 Type I report confirms that our security infrastructure is properly designed and implemented.
</Callout>

***

## Security Controls Implemented

The following controls have been audited and verified as part of our SOC 2 Type I compliance:

### Access Control

* Role-based access; **least privilege** enforced
* **MFA** (Multi-Factor Authentication) for administrative access and sensitive operations
* Quarterly access reviews and revocation upon role change

### Encryption & Key Management

* **TLS 1.2+** for all service/API communications
* Data at rest encrypted using industry-standard ciphers
* Centralized **KMS** (Key Management Service) for key generation, rotation, and revocation
* **Encrypted point-in-time backups** with 30-day retention

See [Security Overview](https://agentmail.to/security) for more details.

### Email Authentication & Anti-Abuse

* **SPF, DKIM, DMARC** configured across all sending domains
* Real-time scanning of inbound/outbound messages for malware/phishing
* IP-based **rate limiting** and behavioral abuse detection

See [Email Protocols](https://docs.agentmail.to/email-protocols) for technical details.

### Monitoring & Incident Response

* Centralized logging and anomaly detection with alerting
* Documented incident response process: detect → triage → contain → eradicate → recover → post-incident review
* Responsible disclosure channel for external security researchers

### Resilience, Backup & Recovery

* Daily encrypted backups with **30-day retention**
* Regular **restore tests** to validate RTO/RPO targets
* Multi-AZ/high-availability architecture for critical components

***

## SOC 2 Control Mapping

| Control Area         | Implementation                                 | SOC 2 Criteria |
| -------------------- | ---------------------------------------------- | -------------- |
| Access Control       | RBAC, MFA, quarterly reviews                   | CC6.1–CC6.7    |
| Encryption & KMS     | TLS 1.2+, at-rest encryption, key rotation     | CC6.8–CC6.9    |
| Email Authentication | SPF/DKIM/DMARC, anti-abuse filters             | CC7.1–CC7.4    |
| Threat Monitoring    | Centralized logs, alerts, malware scanning     | CC7.2–CC7.4    |
| Backup & Recovery    | Daily backups, 30-day retention, restore tests | CC7.3          |
| Incident Response    | Runbooks, post-mortems, disclosure program     | CC7.4–CC7.5    |
| Workforce Security   | Security training, NDAs, background checks     | CC5.3–CC5.4    |

> The above mappings reflect our audited Type I controls and are maintained during the Type II observation period.

***

## Type II Certification Progress

AgentMail is currently in the **Type II observation period** (August 2025 - December 2025), during which an independent auditor is testing and validating that our security controls operate effectively over time.

### What's Being Tested

* **Continuous Operation**: Controls function consistently without gaps
* **Change Management**: Security maintained through system updates and changes
* **Evidence Collection**: Logs, tickets, training records, access reviews
* **Incident Handling**: Real-world response to security events (if any)

### Expected Completion

**Q1 2026** - Full SOC 2 Type II certification report from independent CPA firm

Type II certification provides the highest level of assurance that AgentMail's security controls are not only well-designed but also operate effectively over time.

***

## Accessing SOC 2 Reports

Organizations evaluating AgentMail can [request SOC 2 documentation](mailto:security@agentmail.to).

***


# API Welcome

> Quick overview of the AgentMail SDK

## Introduction

AgentMail provides a powerful API for managing email communications programmatically. Whether you're building automated testing systems, handling customer support workflows, or developing email-based applications, our API offers the tools you need!

## Available SDKs

<Cards>
  {" "}

  <Card title="Python SDK" icon="fa-brands fa-python" href="https://github.com/agentmail-to/agentmail-python">
    Use our Python SDK for seamless integration with your Python applications.
  </Card>

  <Card title="Node SDK" icon="fa-brands fa-node-js" href="https://github.com/agentmail-to/agentmail-node">
    Use our Node SDK for seamless integration with your Node applications.
  </Card>
</Cards>

## Contribute

We welcome contributions to our SDKs. If you have any suggestions or improvements, please feel free to open a pull request!

If you have any other languages you would like us to support, please [reach out to us](mailto:support@agentmail.cc).

## License

All of our SDKs are open source and available under the MIT license.


# List Inboxes

GET https://api.agentmail.to/v0/inboxes

Reference: https://docs.agentmail.to/api-reference/inboxes/list

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: List Inboxes
  version: endpoint_inboxes.list
paths:
  /v0/inboxes:
    get:
      operationId: list
      summary: List Inboxes
      tags:
        - - subpackage_inboxes
      parameters:
        - name: limit
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Limit'
        - name: page_token
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:PageToken'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_inboxes:ListInboxesResponse'
components:
  schemas:
    type_:Limit:
      type: integer
    type_:PageToken:
      type: string
    type_:Count:
      type: integer
    type_pods:PodId:
      type: string
    type_inboxes:InboxId:
      type: string
    type_inboxes:DisplayName:
      type: string
    type_inboxes:ClientId:
      type: string
    type_inboxes:Inbox:
      type: object
      properties:
        pod_id:
          $ref: '#/components/schemas/type_pods:PodId'
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        display_name:
          $ref: '#/components/schemas/type_inboxes:DisplayName'
        client_id:
          $ref: '#/components/schemas/type_inboxes:ClientId'
        updated_at:
          type: string
          format: date-time
          description: Time at which inbox was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which inbox was created.
      required:
        - pod_id
        - inbox_id
        - updated_at
        - created_at
    type_inboxes:ListInboxesResponse:
      type: object
      properties:
        count:
          $ref: '#/components/schemas/type_:Count'
        limit:
          $ref: '#/components/schemas/type_:Limit'
        next_page_token:
          $ref: '#/components/schemas/type_:PageToken'
        inboxes:
          type: array
          items:
            $ref: '#/components/schemas/type_inboxes:Inbox'
          description: Ordered by `created_at` descending.
      required:
        - count
        - inboxes

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.list({});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.list()

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("GET", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/inboxes")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/inboxes', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get Inbox

GET https://api.agentmail.to/v0/inboxes/{inbox_id}

Reference: https://docs.agentmail.to/api-reference/inboxes/get

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get Inbox
  version: endpoint_inboxes.get
paths:
  /v0/inboxes/{inbox_id}:
    get:
      operationId: get
      summary: Get Inbox
      tags:
        - - subpackage_inboxes
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_inboxes:Inbox'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_pods:PodId:
      type: string
    type_inboxes:DisplayName:
      type: string
    type_inboxes:ClientId:
      type: string
    type_inboxes:Inbox:
      type: object
      properties:
        pod_id:
          $ref: '#/components/schemas/type_pods:PodId'
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        display_name:
          $ref: '#/components/schemas/type_inboxes:DisplayName'
        client_id:
          $ref: '#/components/schemas/type_inboxes:ClientId'
        updated_at:
          type: string
          format: date-time
          description: Time at which inbox was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which inbox was created.
      required:
        - pod_id
        - inbox_id
        - updated_at
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.get("inbox_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.get(
    inbox_id="inbox_id"
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("GET", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/inboxes/inbox_id")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/inboxes/inbox_id', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Create Inbox

POST https://api.agentmail.to/v0/inboxes
Content-Type: application/json

Reference: https://docs.agentmail.to/api-reference/inboxes/create

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Create Inbox
  version: endpoint_inboxes.create
paths:
  /v0/inboxes:
    post:
      operationId: create
      summary: Create Inbox
      tags:
        - - subpackage_inboxes
      parameters:
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_inboxes:Inbox'
        '400':
          description: Error response with status 400
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_inboxes:CreateInboxRequest'
components:
  schemas:
    type_inboxes:DisplayName:
      type: string
    type_inboxes:ClientId:
      type: string
    type_inboxes:CreateInboxRequest:
      type: object
      properties:
        username:
          type: string
          description: Username of address. Randomly generated if not specified.
        domain:
          type: string
          description: >-
            Domain of address. Must be verified domain. Defaults to
            `agentmail.to`.
        display_name:
          $ref: '#/components/schemas/type_inboxes:DisplayName'
        client_id:
          $ref: '#/components/schemas/type_inboxes:ClientId'
    type_pods:PodId:
      type: string
    type_inboxes:InboxId:
      type: string
    type_inboxes:Inbox:
      type: object
      properties:
        pod_id:
          $ref: '#/components/schemas/type_pods:PodId'
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        display_name:
          $ref: '#/components/schemas/type_inboxes:DisplayName'
        client_id:
          $ref: '#/components/schemas/type_inboxes:ClientId'
        updated_at:
          type: string
          format: date-time
          description: Time at which inbox was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which inbox was created.
      required:
        - pod_id
        - inbox_id
        - updated_at
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.create({
        displayName: "Customer Support Inbox",
        clientId: "1c6e9f4a-8b2d-4f3a-9d7e-2a1b3c4d5e6f",
    });
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.create(
    display_name="Customer Support Inbox",
    client_id="1c6e9f4a-8b2d-4f3a-9d7e-2a1b3c4d5e6f"
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes"

	payload := strings.NewReader("{\n  \"display_name\": \"Customer Support Inbox\",\n  \"client_id\": \"1c6e9f4a-8b2d-4f3a-9d7e-2a1b3c4d5e6f\",\n  \"pod_id\": \"3fa85f64-5717-4562-b3fc-2c963f66afa6\",\n  \"inbox_id\": \"support@example.com\"\n}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Post.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{\n  \"display_name\": \"Customer Support Inbox\",\n  \"client_id\": \"1c6e9f4a-8b2d-4f3a-9d7e-2a1b3c4d5e6f\",\n  \"pod_id\": \"3fa85f64-5717-4562-b3fc-2c963f66afa6\",\n  \"inbox_id\": \"support@example.com\"\n}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.post("https://api.agentmail.to/v0/inboxes")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{\n  \"display_name\": \"Customer Support Inbox\",\n  \"client_id\": \"1c6e9f4a-8b2d-4f3a-9d7e-2a1b3c4d5e6f\",\n  \"pod_id\": \"3fa85f64-5717-4562-b3fc-2c963f66afa6\",\n  \"inbox_id\": \"support@example.com\"\n}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('POST', 'https://api.agentmail.to/v0/inboxes', [
  'body' => '{
  "display_name": "Customer Support Inbox",
  "client_id": "1c6e9f4a-8b2d-4f3a-9d7e-2a1b3c4d5e6f",
  "pod_id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
  "inbox_id": "support@example.com"
}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes");
var request = new RestRequest(Method.POST);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{\n  \"display_name\": \"Customer Support Inbox\",\n  \"client_id\": \"1c6e9f4a-8b2d-4f3a-9d7e-2a1b3c4d5e6f\",\n  \"pod_id\": \"3fa85f64-5717-4562-b3fc-2c963f66afa6\",\n  \"inbox_id\": \"support@example.com\"\n}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [
  "display_name": "Customer Support Inbox",
  "client_id": "1c6e9f4a-8b2d-4f3a-9d7e-2a1b3c4d5e6f",
  "pod_id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
  "inbox_id": "support@example.com"
] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Update Inbox

PATCH https://api.agentmail.to/v0/inboxes/{inbox_id}
Content-Type: application/json

Reference: https://docs.agentmail.to/api-reference/inboxes/update

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Update Inbox
  version: endpoint_inboxes.update
paths:
  /v0/inboxes/{inbox_id}:
    patch:
      operationId: update
      summary: Update Inbox
      tags:
        - - subpackage_inboxes
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_inboxes:Inbox'
        '404':
          description: Error response with status 404
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_inboxes:UpdateInboxRequest'
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_inboxes:DisplayName:
      type: string
    type_inboxes:UpdateInboxRequest:
      type: object
      properties:
        display_name:
          $ref: '#/components/schemas/type_inboxes:DisplayName'
      required:
        - display_name
    type_pods:PodId:
      type: string
    type_inboxes:ClientId:
      type: string
    type_inboxes:Inbox:
      type: object
      properties:
        pod_id:
          $ref: '#/components/schemas/type_pods:PodId'
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        display_name:
          $ref: '#/components/schemas/type_inboxes:DisplayName'
        client_id:
          $ref: '#/components/schemas/type_inboxes:ClientId'
        updated_at:
          type: string
          format: date-time
          description: Time at which inbox was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which inbox was created.
      required:
        - pod_id
        - inbox_id
        - updated_at
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.update("inbox_id", {
        displayName: "display_name",
    });
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.update(
    inbox_id="inbox_id",
    display_name="display_name"
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id"

	payload := strings.NewReader("{\n  \"display_name\": \"display_name\"\n}")

	req, _ := http.NewRequest("PATCH", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Patch.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{\n  \"display_name\": \"display_name\"\n}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.patch("https://api.agentmail.to/v0/inboxes/inbox_id")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{\n  \"display_name\": \"display_name\"\n}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('PATCH', 'https://api.agentmail.to/v0/inboxes/inbox_id', [
  'body' => '{
  "display_name": "display_name"
}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id");
var request = new RestRequest(Method.PATCH);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{\n  \"display_name\": \"display_name\"\n}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = ["display_name": "display_name"] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Delete Inbox

DELETE https://api.agentmail.to/v0/inboxes/{inbox_id}

Reference: https://docs.agentmail.to/api-reference/inboxes/delete

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Delete Inbox
  version: endpoint_inboxes.delete
paths:
  /v0/inboxes/{inbox_id}:
    delete:
      operationId: delete
      summary: Delete Inbox
      tags:
        - - subpackage_inboxes
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Successful response
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_inboxes:InboxId:
      type: string

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.delete("inbox_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.delete(
    inbox_id="inbox_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id"

	req, _ := http.NewRequest("DELETE", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Delete.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.delete("https://api.agentmail.to/v0/inboxes/inbox_id")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('DELETE', 'https://api.agentmail.to/v0/inboxes/inbox_id', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id");
var request = new RestRequest(Method.DELETE);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "DELETE"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# List Threads

GET https://api.agentmail.to/v0/inboxes/{inbox_id}/threads

Reference: https://docs.agentmail.to/api-reference/inboxes/threads/list

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: List Threads
  version: endpoint_inboxes/threads.list
paths:
  /v0/inboxes/{inbox_id}/threads:
    get:
      operationId: list
      summary: List Threads
      tags:
        - - subpackage_inboxes
          - subpackage_inboxes/threads
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: limit
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Limit'
        - name: page_token
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:PageToken'
        - name: labels
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Labels'
        - name: before
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Before'
        - name: after
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:After'
        - name: ascending
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Ascending'
        - name: include_spam
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:IncludeSpam'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_threads:ListThreadsResponse'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_:Limit:
      type: integer
    type_:PageToken:
      type: string
    type_:Labels:
      type: array
      items:
        type: string
    type_:Before:
      type: string
      format: date-time
    type_:After:
      type: string
      format: date-time
    type_:Ascending:
      type: boolean
    type_:IncludeSpam:
      type: boolean
    type_:Count:
      type: integer
    type_threads:ThreadId:
      type: string
    type_threads:ThreadLabels:
      type: array
      items:
        type: string
    type_threads:ThreadTimestamp:
      type: string
      format: date-time
    type_threads:ThreadReceivedTimestamp:
      type: string
      format: date-time
    type_threads:ThreadSentTimestamp:
      type: string
      format: date-time
    type_threads:ThreadSenders:
      type: array
      items:
        type: string
    type_threads:ThreadRecipients:
      type: array
      items:
        type: string
    type_threads:ThreadSubject:
      type: string
    type_threads:ThreadPreview:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:Attachment:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
      required:
        - attachment_id
        - size
    type_threads:ThreadAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_threads:ThreadLastMessageId:
      type: string
    type_threads:ThreadMessageCount:
      type: integer
    type_threads:ThreadSize:
      type: integer
    type_threads:ThreadUpdatedAt:
      type: string
      format: date-time
    type_threads:ThreadCreatedAt:
      type: string
      format: date-time
    type_threads:ThreadItem:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        labels:
          $ref: '#/components/schemas/type_threads:ThreadLabels'
        timestamp:
          $ref: '#/components/schemas/type_threads:ThreadTimestamp'
        received_timestamp:
          $ref: '#/components/schemas/type_threads:ThreadReceivedTimestamp'
        sent_timestamp:
          $ref: '#/components/schemas/type_threads:ThreadSentTimestamp'
        senders:
          $ref: '#/components/schemas/type_threads:ThreadSenders'
        recipients:
          $ref: '#/components/schemas/type_threads:ThreadRecipients'
        subject:
          $ref: '#/components/schemas/type_threads:ThreadSubject'
        preview:
          $ref: '#/components/schemas/type_threads:ThreadPreview'
        attachments:
          $ref: '#/components/schemas/type_threads:ThreadAttachments'
        last_message_id:
          $ref: '#/components/schemas/type_threads:ThreadLastMessageId'
        message_count:
          $ref: '#/components/schemas/type_threads:ThreadMessageCount'
        size:
          $ref: '#/components/schemas/type_threads:ThreadSize'
        updated_at:
          $ref: '#/components/schemas/type_threads:ThreadUpdatedAt'
        created_at:
          $ref: '#/components/schemas/type_threads:ThreadCreatedAt'
      required:
        - inbox_id
        - thread_id
        - labels
        - timestamp
        - senders
        - recipients
        - last_message_id
        - message_count
        - size
        - updated_at
        - created_at
    type_threads:ListThreadsResponse:
      type: object
      properties:
        count:
          $ref: '#/components/schemas/type_:Count'
        limit:
          $ref: '#/components/schemas/type_:Limit'
        next_page_token:
          $ref: '#/components/schemas/type_:PageToken'
        threads:
          type: array
          items:
            $ref: '#/components/schemas/type_threads:ThreadItem'
          description: Ordered by `timestamp` descending.
      required:
        - count
        - threads

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.threads.list("inbox_id", {});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.threads.list(
    inbox_id="inbox_id"
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id/threads"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("GET", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id/threads")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/inboxes/inbox_id/threads")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/inboxes/inbox_id/threads', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id/threads");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id/threads")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get Thread

GET https://api.agentmail.to/v0/inboxes/{inbox_id}/threads/{thread_id}

Reference: https://docs.agentmail.to/api-reference/inboxes/threads/get

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get Thread
  version: endpoint_inboxes/threads.get
paths:
  /v0/inboxes/{inbox_id}/threads/{thread_id}:
    get:
      operationId: get
      summary: Get Thread
      tags:
        - - subpackage_inboxes
          - subpackage_inboxes/threads
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: thread_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_threads:ThreadId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_threads:Thread'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_threads:ThreadId:
      type: string
    type_threads:ThreadLabels:
      type: array
      items:
        type: string
    type_threads:ThreadTimestamp:
      type: string
      format: date-time
    type_threads:ThreadReceivedTimestamp:
      type: string
      format: date-time
    type_threads:ThreadSentTimestamp:
      type: string
      format: date-time
    type_threads:ThreadSenders:
      type: array
      items:
        type: string
    type_threads:ThreadRecipients:
      type: array
      items:
        type: string
    type_threads:ThreadSubject:
      type: string
    type_threads:ThreadPreview:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:Attachment:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
      required:
        - attachment_id
        - size
    type_threads:ThreadAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_threads:ThreadLastMessageId:
      type: string
    type_threads:ThreadMessageCount:
      type: integer
    type_threads:ThreadSize:
      type: integer
    type_threads:ThreadUpdatedAt:
      type: string
      format: date-time
    type_threads:ThreadCreatedAt:
      type: string
      format: date-time
    type_messages:MessageId:
      type: string
    type_messages:MessageLabels:
      type: array
      items:
        type: string
    type_messages:MessageTimestamp:
      type: string
      format: date-time
    type_messages:MessageFrom:
      type: string
    type_messages:MessageTo:
      type: array
      items:
        type: string
    type_messages:MessageCc:
      type: array
      items:
        type: string
    type_messages:MessageBcc:
      type: array
      items:
        type: string
    type_messages:MessageSubject:
      type: string
    type_messages:MessagePreview:
      type: string
    type_messages:MessageText:
      type: string
    type_messages:MessageHtml:
      type: string
    type_messages:MessageAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_messages:MessageInReplyTo:
      type: string
    type_messages:MessageReferences:
      type: array
      items:
        type: string
    type_messages:MessageHeaders:
      type: object
      additionalProperties:
        type: string
    type_messages:MessageSize:
      type: integer
    type_messages:MessageUpdatedAt:
      type: string
      format: date-time
    type_messages:MessageCreatedAt:
      type: string
      format: date-time
    type_messages:Message:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        labels:
          $ref: '#/components/schemas/type_messages:MessageLabels'
        timestamp:
          $ref: '#/components/schemas/type_messages:MessageTimestamp'
        from:
          $ref: '#/components/schemas/type_messages:MessageFrom'
        reply_to:
          type: array
          items:
            type: string
          description: >-
            Reply-to addresses. In format `username@domain.com` or `Display Name
            <username@domain.com>`.
        to:
          $ref: '#/components/schemas/type_messages:MessageTo'
        cc:
          $ref: '#/components/schemas/type_messages:MessageCc'
        bcc:
          $ref: '#/components/schemas/type_messages:MessageBcc'
        subject:
          $ref: '#/components/schemas/type_messages:MessageSubject'
        preview:
          $ref: '#/components/schemas/type_messages:MessagePreview'
        text:
          $ref: '#/components/schemas/type_messages:MessageText'
        html:
          $ref: '#/components/schemas/type_messages:MessageHtml'
        extracted_text:
          type: string
          description: Extracted new text content.
        extracted_html:
          type: string
          description: Extracted new HTML content.
        attachments:
          $ref: '#/components/schemas/type_messages:MessageAttachments'
        in_reply_to:
          $ref: '#/components/schemas/type_messages:MessageInReplyTo'
        references:
          $ref: '#/components/schemas/type_messages:MessageReferences'
        headers:
          $ref: '#/components/schemas/type_messages:MessageHeaders'
        size:
          $ref: '#/components/schemas/type_messages:MessageSize'
        updated_at:
          $ref: '#/components/schemas/type_messages:MessageUpdatedAt'
        created_at:
          $ref: '#/components/schemas/type_messages:MessageCreatedAt'
      required:
        - inbox_id
        - thread_id
        - message_id
        - labels
        - timestamp
        - from
        - to
        - size
        - updated_at
        - created_at
    type_threads:Thread:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        labels:
          $ref: '#/components/schemas/type_threads:ThreadLabels'
        timestamp:
          $ref: '#/components/schemas/type_threads:ThreadTimestamp'
        received_timestamp:
          $ref: '#/components/schemas/type_threads:ThreadReceivedTimestamp'
        sent_timestamp:
          $ref: '#/components/schemas/type_threads:ThreadSentTimestamp'
        senders:
          $ref: '#/components/schemas/type_threads:ThreadSenders'
        recipients:
          $ref: '#/components/schemas/type_threads:ThreadRecipients'
        subject:
          $ref: '#/components/schemas/type_threads:ThreadSubject'
        preview:
          $ref: '#/components/schemas/type_threads:ThreadPreview'
        attachments:
          $ref: '#/components/schemas/type_threads:ThreadAttachments'
        last_message_id:
          $ref: '#/components/schemas/type_threads:ThreadLastMessageId'
        message_count:
          $ref: '#/components/schemas/type_threads:ThreadMessageCount'
        size:
          $ref: '#/components/schemas/type_threads:ThreadSize'
        updated_at:
          $ref: '#/components/schemas/type_threads:ThreadUpdatedAt'
        created_at:
          $ref: '#/components/schemas/type_threads:ThreadCreatedAt'
        messages:
          type: array
          items:
            $ref: '#/components/schemas/type_messages:Message'
          description: Messages in thread. Ordered by `timestamp` ascending.
      required:
        - inbox_id
        - thread_id
        - labels
        - timestamp
        - senders
        - recipients
        - last_message_id
        - message_count
        - size
        - updated_at
        - created_at
        - messages

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.threads.get("inbox_id", "thread_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.threads.get(
    inbox_id="inbox_id",
    thread_id="thread_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id/threads/thread_id"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id/threads/thread_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/inboxes/inbox_id/threads/thread_id")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/inboxes/inbox_id/threads/thread_id', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id/threads/thread_id");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id/threads/thread_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get Attachment

GET https://api.agentmail.to/v0/inboxes/{inbox_id}/threads/{thread_id}/attachments/{attachment_id}

Reference: https://docs.agentmail.to/api-reference/inboxes/threads/get-attachment

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get Attachment
  version: endpoint_inboxes/threads.getAttachment
paths:
  /v0/inboxes/{inbox_id}/threads/{thread_id}/attachments/{attachment_id}:
    get:
      operationId: get-attachment
      summary: Get Attachment
      tags:
        - - subpackage_inboxes
          - subpackage_inboxes/threads
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: thread_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_threads:ThreadId'
        - name: attachment_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_attachments:AttachmentId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_attachments:AttachmentResponse'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_threads:ThreadId:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:AttachmentResponse:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
        download_url:
          type: string
          description: URL to download the attachment.
        expires_at:
          type: string
          format: date-time
          description: Time at which the download URL expires.
      required:
        - attachment_id
        - size
        - download_url
        - expires_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.threads.getAttachment("inbox_id", "thread_id", "attachment_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.threads.get_attachment(
    inbox_id="inbox_id",
    thread_id="thread_id",
    attachment_id="attachment_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id/threads/thread_id/attachments/attachment_id"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id/threads/thread_id/attachments/attachment_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/inboxes/inbox_id/threads/thread_id/attachments/attachment_id")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/inboxes/inbox_id/threads/thread_id/attachments/attachment_id', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id/threads/thread_id/attachments/attachment_id");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id/threads/thread_id/attachments/attachment_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Delete Thread

DELETE https://api.agentmail.to/v0/inboxes/{inbox_id}/threads/{thread_id}

Reference: https://docs.agentmail.to/api-reference/inboxes/threads/delete

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Delete Thread
  version: endpoint_inboxes/threads.delete
paths:
  /v0/inboxes/{inbox_id}/threads/{thread_id}:
    delete:
      operationId: delete
      summary: Delete Thread
      tags:
        - - subpackage_inboxes
          - subpackage_inboxes/threads
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: thread_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_threads:ThreadId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Successful response
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_threads:ThreadId:
      type: string

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.threads.delete("inbox_id", "thread_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.threads.delete(
    inbox_id="inbox_id",
    thread_id="thread_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id/threads/thread_id"

	req, _ := http.NewRequest("DELETE", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id/threads/thread_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Delete.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.delete("https://api.agentmail.to/v0/inboxes/inbox_id/threads/thread_id")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('DELETE', 'https://api.agentmail.to/v0/inboxes/inbox_id/threads/thread_id', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id/threads/thread_id");
var request = new RestRequest(Method.DELETE);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id/threads/thread_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "DELETE"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# List Messages

GET https://api.agentmail.to/v0/inboxes/{inbox_id}/messages

Reference: https://docs.agentmail.to/api-reference/inboxes/messages/list

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: List Messages
  version: endpoint_inboxes/messages.list
paths:
  /v0/inboxes/{inbox_id}/messages:
    get:
      operationId: list
      summary: List Messages
      tags:
        - - subpackage_inboxes
          - subpackage_inboxes/messages
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: limit
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Limit'
        - name: page_token
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:PageToken'
        - name: labels
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Labels'
        - name: before
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Before'
        - name: after
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:After'
        - name: ascending
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Ascending'
        - name: include_spam
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:IncludeSpam'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_messages:ListMessagesResponse'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_:Limit:
      type: integer
    type_:PageToken:
      type: string
    type_:Labels:
      type: array
      items:
        type: string
    type_:Before:
      type: string
      format: date-time
    type_:After:
      type: string
      format: date-time
    type_:Ascending:
      type: boolean
    type_:IncludeSpam:
      type: boolean
    type_:Count:
      type: integer
    type_threads:ThreadId:
      type: string
    type_messages:MessageId:
      type: string
    type_messages:MessageLabels:
      type: array
      items:
        type: string
    type_messages:MessageTimestamp:
      type: string
      format: date-time
    type_messages:MessageFrom:
      type: string
    type_messages:MessageTo:
      type: array
      items:
        type: string
    type_messages:MessageCc:
      type: array
      items:
        type: string
    type_messages:MessageBcc:
      type: array
      items:
        type: string
    type_messages:MessageSubject:
      type: string
    type_messages:MessagePreview:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:Attachment:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
      required:
        - attachment_id
        - size
    type_messages:MessageAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_messages:MessageInReplyTo:
      type: string
    type_messages:MessageReferences:
      type: array
      items:
        type: string
    type_messages:MessageHeaders:
      type: object
      additionalProperties:
        type: string
    type_messages:MessageSize:
      type: integer
    type_messages:MessageUpdatedAt:
      type: string
      format: date-time
    type_messages:MessageCreatedAt:
      type: string
      format: date-time
    type_messages:MessageItem:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        labels:
          $ref: '#/components/schemas/type_messages:MessageLabels'
        timestamp:
          $ref: '#/components/schemas/type_messages:MessageTimestamp'
        from:
          $ref: '#/components/schemas/type_messages:MessageFrom'
        to:
          $ref: '#/components/schemas/type_messages:MessageTo'
        cc:
          $ref: '#/components/schemas/type_messages:MessageCc'
        bcc:
          $ref: '#/components/schemas/type_messages:MessageBcc'
        subject:
          $ref: '#/components/schemas/type_messages:MessageSubject'
        preview:
          $ref: '#/components/schemas/type_messages:MessagePreview'
        attachments:
          $ref: '#/components/schemas/type_messages:MessageAttachments'
        in_reply_to:
          $ref: '#/components/schemas/type_messages:MessageInReplyTo'
        references:
          $ref: '#/components/schemas/type_messages:MessageReferences'
        headers:
          $ref: '#/components/schemas/type_messages:MessageHeaders'
        size:
          $ref: '#/components/schemas/type_messages:MessageSize'
        updated_at:
          $ref: '#/components/schemas/type_messages:MessageUpdatedAt'
        created_at:
          $ref: '#/components/schemas/type_messages:MessageCreatedAt'
      required:
        - inbox_id
        - thread_id
        - message_id
        - labels
        - timestamp
        - from
        - to
        - size
        - updated_at
        - created_at
    type_messages:ListMessagesResponse:
      type: object
      properties:
        count:
          $ref: '#/components/schemas/type_:Count'
        limit:
          $ref: '#/components/schemas/type_:Limit'
        next_page_token:
          $ref: '#/components/schemas/type_:PageToken'
        messages:
          type: array
          items:
            $ref: '#/components/schemas/type_messages:MessageItem'
          description: Ordered by `timestamp` descending.
      required:
        - count
        - messages

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.messages.list("inbox_id", {});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.messages.list(
    inbox_id="inbox_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id/messages"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id/messages")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/inboxes/inbox_id/messages")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/inboxes/inbox_id/messages', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id/messages");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id/messages")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get Message

GET https://api.agentmail.to/v0/inboxes/{inbox_id}/messages/{message_id}

Reference: https://docs.agentmail.to/api-reference/inboxes/messages/get

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get Message
  version: endpoint_inboxes/messages.get
paths:
  /v0/inboxes/{inbox_id}/messages/{message_id}:
    get:
      operationId: get
      summary: Get Message
      tags:
        - - subpackage_inboxes
          - subpackage_inboxes/messages
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: message_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_messages:MessageId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_messages:Message'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_messages:MessageId:
      type: string
    type_threads:ThreadId:
      type: string
    type_messages:MessageLabels:
      type: array
      items:
        type: string
    type_messages:MessageTimestamp:
      type: string
      format: date-time
    type_messages:MessageFrom:
      type: string
    type_messages:MessageTo:
      type: array
      items:
        type: string
    type_messages:MessageCc:
      type: array
      items:
        type: string
    type_messages:MessageBcc:
      type: array
      items:
        type: string
    type_messages:MessageSubject:
      type: string
    type_messages:MessagePreview:
      type: string
    type_messages:MessageText:
      type: string
    type_messages:MessageHtml:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:Attachment:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
      required:
        - attachment_id
        - size
    type_messages:MessageAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_messages:MessageInReplyTo:
      type: string
    type_messages:MessageReferences:
      type: array
      items:
        type: string
    type_messages:MessageHeaders:
      type: object
      additionalProperties:
        type: string
    type_messages:MessageSize:
      type: integer
    type_messages:MessageUpdatedAt:
      type: string
      format: date-time
    type_messages:MessageCreatedAt:
      type: string
      format: date-time
    type_messages:Message:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        labels:
          $ref: '#/components/schemas/type_messages:MessageLabels'
        timestamp:
          $ref: '#/components/schemas/type_messages:MessageTimestamp'
        from:
          $ref: '#/components/schemas/type_messages:MessageFrom'
        reply_to:
          type: array
          items:
            type: string
          description: >-
            Reply-to addresses. In format `username@domain.com` or `Display Name
            <username@domain.com>`.
        to:
          $ref: '#/components/schemas/type_messages:MessageTo'
        cc:
          $ref: '#/components/schemas/type_messages:MessageCc'
        bcc:
          $ref: '#/components/schemas/type_messages:MessageBcc'
        subject:
          $ref: '#/components/schemas/type_messages:MessageSubject'
        preview:
          $ref: '#/components/schemas/type_messages:MessagePreview'
        text:
          $ref: '#/components/schemas/type_messages:MessageText'
        html:
          $ref: '#/components/schemas/type_messages:MessageHtml'
        extracted_text:
          type: string
          description: Extracted new text content.
        extracted_html:
          type: string
          description: Extracted new HTML content.
        attachments:
          $ref: '#/components/schemas/type_messages:MessageAttachments'
        in_reply_to:
          $ref: '#/components/schemas/type_messages:MessageInReplyTo'
        references:
          $ref: '#/components/schemas/type_messages:MessageReferences'
        headers:
          $ref: '#/components/schemas/type_messages:MessageHeaders'
        size:
          $ref: '#/components/schemas/type_messages:MessageSize'
        updated_at:
          $ref: '#/components/schemas/type_messages:MessageUpdatedAt'
        created_at:
          $ref: '#/components/schemas/type_messages:MessageCreatedAt'
      required:
        - inbox_id
        - thread_id
        - message_id
        - labels
        - timestamp
        - from
        - to
        - size
        - updated_at
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.messages.get("inbox_id", "message_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.messages.get(
    inbox_id="inbox_id",
    message_id="message_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get Attachment

GET https://api.agentmail.to/v0/inboxes/{inbox_id}/messages/{message_id}/attachments/{attachment_id}

Reference: https://docs.agentmail.to/api-reference/inboxes/messages/get-attachment

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get Attachment
  version: endpoint_inboxes/messages.getAttachment
paths:
  /v0/inboxes/{inbox_id}/messages/{message_id}/attachments/{attachment_id}:
    get:
      operationId: get-attachment
      summary: Get Attachment
      tags:
        - - subpackage_inboxes
          - subpackage_inboxes/messages
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: message_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_messages:MessageId'
        - name: attachment_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_attachments:AttachmentId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_attachments:AttachmentResponse'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_messages:MessageId:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:AttachmentResponse:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
        download_url:
          type: string
          description: URL to download the attachment.
        expires_at:
          type: string
          format: date-time
          description: Time at which the download URL expires.
      required:
        - attachment_id
        - size
        - download_url
        - expires_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.messages.getAttachment("inbox_id", "message_id", "attachment_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.messages.get_attachment(
    inbox_id="inbox_id",
    message_id="message_id",
    attachment_id="attachment_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/attachments/attachment_id"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/attachments/attachment_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/attachments/attachment_id")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/attachments/attachment_id', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/attachments/attachment_id");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/attachments/attachment_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get Raw Message

GET https://api.agentmail.to/v0/inboxes/{inbox_id}/messages/{message_id}/raw

Reference: https://docs.agentmail.to/api-reference/inboxes/messages/get-raw

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get Raw Message
  version: endpoint_inboxes/messages.getRaw
paths:
  /v0/inboxes/{inbox_id}/messages/{message_id}/raw:
    get:
      operationId: get-raw
      summary: Get Raw Message
      tags:
        - - subpackage_inboxes
          - subpackage_inboxes/messages
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: message_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_messages:MessageId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/octet-stream:
              schema:
                type: string
                format: binary
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_messages:MessageId:
      type: string

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.messages.getRaw(":inbox_id", ":message_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.messages.get_raw(
    inbox_id=":inbox_id",
    message_id=":message_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/%3Ainbox_id/messages/%3Amessage_id/raw"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/%3Ainbox_id/messages/%3Amessage_id/raw")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/inboxes/%3Ainbox_id/messages/%3Amessage_id/raw")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/inboxes/%3Ainbox_id/messages/%3Amessage_id/raw', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/%3Ainbox_id/messages/%3Amessage_id/raw");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/%3Ainbox_id/messages/%3Amessage_id/raw")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Send Message

POST https://api.agentmail.to/v0/inboxes/{inbox_id}/messages/send
Content-Type: application/json

Reference: https://docs.agentmail.to/api-reference/inboxes/messages/send

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Send Message
  version: endpoint_inboxes/messages.send
paths:
  /v0/inboxes/{inbox_id}/messages/send:
    post:
      operationId: send
      summary: Send Message
      tags:
        - - subpackage_inboxes
          - subpackage_inboxes/messages
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_messages:SendMessageResponse'
        '400':
          description: Error response with status 400
          content: {}
        '403':
          description: Error response with status 403
          content: {}
        '404':
          description: Error response with status 404
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_messages:SendMessageRequest'
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_messages:MessageLabels:
      type: array
      items:
        type: string
    type_messages:Addresses:
      oneOf:
        - type: string
        - type: array
          items:
            type: string
    type_messages:SendMessageReplyTo:
      $ref: '#/components/schemas/type_messages:Addresses'
    type_messages:SendMessageTo:
      $ref: '#/components/schemas/type_messages:Addresses'
    type_messages:SendMessageCc:
      $ref: '#/components/schemas/type_messages:Addresses'
    type_messages:SendMessageBcc:
      $ref: '#/components/schemas/type_messages:Addresses'
    type_messages:MessageSubject:
      type: string
    type_messages:MessageText:
      type: string
    type_messages:MessageHtml:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:SendAttachment:
      type: object
      properties:
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
        content:
          type: string
          description: Base64 encoded content of attachment.
        url:
          type: string
          description: URL to the attachment.
    type_messages:SendMessageAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:SendAttachment'
    type_messages:SendMessageHeaders:
      type: object
      additionalProperties:
        type: string
    type_messages:SendMessageRequest:
      type: object
      properties:
        labels:
          $ref: '#/components/schemas/type_messages:MessageLabels'
        reply_to:
          $ref: '#/components/schemas/type_messages:SendMessageReplyTo'
        to:
          $ref: '#/components/schemas/type_messages:SendMessageTo'
        cc:
          $ref: '#/components/schemas/type_messages:SendMessageCc'
        bcc:
          $ref: '#/components/schemas/type_messages:SendMessageBcc'
        subject:
          $ref: '#/components/schemas/type_messages:MessageSubject'
        text:
          $ref: '#/components/schemas/type_messages:MessageText'
        html:
          $ref: '#/components/schemas/type_messages:MessageHtml'
        attachments:
          $ref: '#/components/schemas/type_messages:SendMessageAttachments'
        headers:
          $ref: '#/components/schemas/type_messages:SendMessageHeaders'
    type_messages:MessageId:
      type: string
    type_threads:ThreadId:
      type: string
    type_messages:SendMessageResponse:
      type: object
      properties:
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
      required:
        - message_id
        - thread_id

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.messages.send("inbox_id", {});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.messages.send(
    inbox_id="inbox_id"
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id/messages/send"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id/messages/send")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Post.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.post("https://api.agentmail.to/v0/inboxes/inbox_id/messages/send")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('POST', 'https://api.agentmail.to/v0/inboxes/inbox_id/messages/send', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id/messages/send");
var request = new RestRequest(Method.POST);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id/messages/send")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Reply To Message

POST https://api.agentmail.to/v0/inboxes/{inbox_id}/messages/{message_id}/reply
Content-Type: application/json

Reference: https://docs.agentmail.to/api-reference/inboxes/messages/reply

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Reply To Message
  version: endpoint_inboxes/messages.reply
paths:
  /v0/inboxes/{inbox_id}/messages/{message_id}/reply:
    post:
      operationId: reply
      summary: Reply To Message
      tags:
        - - subpackage_inboxes
          - subpackage_inboxes/messages
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: message_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_messages:MessageId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_messages:SendMessageResponse'
        '400':
          description: Error response with status 400
          content: {}
        '403':
          description: Error response with status 403
          content: {}
        '404':
          description: Error response with status 404
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_messages:ReplyToMessageRequest'
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_messages:MessageId:
      type: string
    type_messages:MessageLabels:
      type: array
      items:
        type: string
    type_messages:Addresses:
      oneOf:
        - type: string
        - type: array
          items:
            type: string
    type_messages:SendMessageReplyTo:
      $ref: '#/components/schemas/type_messages:Addresses'
    type_messages:SendMessageTo:
      $ref: '#/components/schemas/type_messages:Addresses'
    type_messages:SendMessageCc:
      $ref: '#/components/schemas/type_messages:Addresses'
    type_messages:SendMessageBcc:
      $ref: '#/components/schemas/type_messages:Addresses'
    type_messages:ReplyAll:
      type: boolean
    type_messages:MessageText:
      type: string
    type_messages:MessageHtml:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:SendAttachment:
      type: object
      properties:
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
        content:
          type: string
          description: Base64 encoded content of attachment.
        url:
          type: string
          description: URL to the attachment.
    type_messages:SendMessageAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:SendAttachment'
    type_messages:SendMessageHeaders:
      type: object
      additionalProperties:
        type: string
    type_messages:ReplyToMessageRequest:
      type: object
      properties:
        labels:
          $ref: '#/components/schemas/type_messages:MessageLabels'
        reply_to:
          $ref: '#/components/schemas/type_messages:SendMessageReplyTo'
        to:
          $ref: '#/components/schemas/type_messages:SendMessageTo'
        cc:
          $ref: '#/components/schemas/type_messages:SendMessageCc'
        bcc:
          $ref: '#/components/schemas/type_messages:SendMessageBcc'
        reply_all:
          $ref: '#/components/schemas/type_messages:ReplyAll'
        text:
          $ref: '#/components/schemas/type_messages:MessageText'
        html:
          $ref: '#/components/schemas/type_messages:MessageHtml'
        attachments:
          $ref: '#/components/schemas/type_messages:SendMessageAttachments'
        headers:
          $ref: '#/components/schemas/type_messages:SendMessageHeaders'
    type_threads:ThreadId:
      type: string
    type_messages:SendMessageResponse:
      type: object
      properties:
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
      required:
        - message_id
        - thread_id

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.messages.reply("inbox_id", "message_id", {});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.messages.reply(
    inbox_id="inbox_id",
    message_id="message_id"
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/reply"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/reply")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Post.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.post("https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/reply")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('POST', 'https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/reply', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/reply");
var request = new RestRequest(Method.POST);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/reply")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Reply All Message

POST https://api.agentmail.to/v0/inboxes/{inbox_id}/messages/{message_id}/reply-all
Content-Type: application/json

Reference: https://docs.agentmail.to/api-reference/inboxes/messages/reply-all

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Reply All Message
  version: endpoint_inboxes/messages.reply-all
paths:
  /v0/inboxes/{inbox_id}/messages/{message_id}/reply-all:
    post:
      operationId: reply-all
      summary: Reply All Message
      tags:
        - - subpackage_inboxes
          - subpackage_inboxes/messages
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: message_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_messages:MessageId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_messages:SendMessageResponse'
        '400':
          description: Error response with status 400
          content: {}
        '403':
          description: Error response with status 403
          content: {}
        '404':
          description: Error response with status 404
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_messages:ReplyAllMessageRequest'
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_messages:MessageId:
      type: string
    type_messages:MessageLabels:
      type: array
      items:
        type: string
    type_messages:Addresses:
      oneOf:
        - type: string
        - type: array
          items:
            type: string
    type_messages:SendMessageReplyTo:
      $ref: '#/components/schemas/type_messages:Addresses'
    type_messages:MessageText:
      type: string
    type_messages:MessageHtml:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:SendAttachment:
      type: object
      properties:
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
        content:
          type: string
          description: Base64 encoded content of attachment.
        url:
          type: string
          description: URL to the attachment.
    type_messages:SendMessageAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:SendAttachment'
    type_messages:SendMessageHeaders:
      type: object
      additionalProperties:
        type: string
    type_messages:ReplyAllMessageRequest:
      type: object
      properties:
        labels:
          $ref: '#/components/schemas/type_messages:MessageLabels'
        reply_to:
          $ref: '#/components/schemas/type_messages:SendMessageReplyTo'
        text:
          $ref: '#/components/schemas/type_messages:MessageText'
        html:
          $ref: '#/components/schemas/type_messages:MessageHtml'
        attachments:
          $ref: '#/components/schemas/type_messages:SendMessageAttachments'
        headers:
          $ref: '#/components/schemas/type_messages:SendMessageHeaders'
    type_threads:ThreadId:
      type: string
    type_messages:SendMessageResponse:
      type: object
      properties:
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
      required:
        - message_id
        - thread_id

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.messages.replyAll("inbox_id", "message_id", {});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.messages.reply_all(
    inbox_id="inbox_id",
    message_id="message_id"
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/reply-all"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/reply-all")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Post.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.post("https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/reply-all")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('POST', 'https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/reply-all', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/reply-all");
var request = new RestRequest(Method.POST);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/reply-all")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Forward Message

POST https://api.agentmail.to/v0/inboxes/{inbox_id}/messages/{message_id}/forward
Content-Type: application/json

Reference: https://docs.agentmail.to/api-reference/inboxes/messages/forward

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Forward Message
  version: endpoint_inboxes/messages.forward
paths:
  /v0/inboxes/{inbox_id}/messages/{message_id}/forward:
    post:
      operationId: forward
      summary: Forward Message
      tags:
        - - subpackage_inboxes
          - subpackage_inboxes/messages
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: message_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_messages:MessageId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_messages:SendMessageResponse'
        '400':
          description: Error response with status 400
          content: {}
        '403':
          description: Error response with status 403
          content: {}
        '404':
          description: Error response with status 404
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_messages:SendMessageRequest'
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_messages:MessageId:
      type: string
    type_messages:MessageLabels:
      type: array
      items:
        type: string
    type_messages:Addresses:
      oneOf:
        - type: string
        - type: array
          items:
            type: string
    type_messages:SendMessageReplyTo:
      $ref: '#/components/schemas/type_messages:Addresses'
    type_messages:SendMessageTo:
      $ref: '#/components/schemas/type_messages:Addresses'
    type_messages:SendMessageCc:
      $ref: '#/components/schemas/type_messages:Addresses'
    type_messages:SendMessageBcc:
      $ref: '#/components/schemas/type_messages:Addresses'
    type_messages:MessageSubject:
      type: string
    type_messages:MessageText:
      type: string
    type_messages:MessageHtml:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:SendAttachment:
      type: object
      properties:
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
        content:
          type: string
          description: Base64 encoded content of attachment.
        url:
          type: string
          description: URL to the attachment.
    type_messages:SendMessageAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:SendAttachment'
    type_messages:SendMessageHeaders:
      type: object
      additionalProperties:
        type: string
    type_messages:SendMessageRequest:
      type: object
      properties:
        labels:
          $ref: '#/components/schemas/type_messages:MessageLabels'
        reply_to:
          $ref: '#/components/schemas/type_messages:SendMessageReplyTo'
        to:
          $ref: '#/components/schemas/type_messages:SendMessageTo'
        cc:
          $ref: '#/components/schemas/type_messages:SendMessageCc'
        bcc:
          $ref: '#/components/schemas/type_messages:SendMessageBcc'
        subject:
          $ref: '#/components/schemas/type_messages:MessageSubject'
        text:
          $ref: '#/components/schemas/type_messages:MessageText'
        html:
          $ref: '#/components/schemas/type_messages:MessageHtml'
        attachments:
          $ref: '#/components/schemas/type_messages:SendMessageAttachments'
        headers:
          $ref: '#/components/schemas/type_messages:SendMessageHeaders'
    type_threads:ThreadId:
      type: string
    type_messages:SendMessageResponse:
      type: object
      properties:
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
      required:
        - message_id
        - thread_id

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.messages.forward("inbox_id", "message_id", {});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.messages.forward(
    inbox_id="inbox_id",
    message_id="message_id"
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/forward"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/forward")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Post.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.post("https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/forward")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('POST', 'https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/forward', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/forward");
var request = new RestRequest(Method.POST);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id/forward")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Update Message

PATCH https://api.agentmail.to/v0/inboxes/{inbox_id}/messages/{message_id}
Content-Type: application/json

Reference: https://docs.agentmail.to/api-reference/inboxes/messages/update

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Update Message
  version: endpoint_inboxes/messages.update
paths:
  /v0/inboxes/{inbox_id}/messages/{message_id}:
    patch:
      operationId: update
      summary: Update Message
      tags:
        - - subpackage_inboxes
          - subpackage_inboxes/messages
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: message_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_messages:MessageId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_messages:Message'
        '400':
          description: Error response with status 400
          content: {}
        '404':
          description: Error response with status 404
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_messages:UpdateMessageRequest'
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_messages:MessageId:
      type: string
    type_messages:UpdateMessageRequest:
      type: object
      properties:
        add_labels:
          type: array
          items:
            type: string
          description: Labels to add to message.
        remove_labels:
          type: array
          items:
            type: string
          description: Labels to remove from message.
    type_threads:ThreadId:
      type: string
    type_messages:MessageLabels:
      type: array
      items:
        type: string
    type_messages:MessageTimestamp:
      type: string
      format: date-time
    type_messages:MessageFrom:
      type: string
    type_messages:MessageTo:
      type: array
      items:
        type: string
    type_messages:MessageCc:
      type: array
      items:
        type: string
    type_messages:MessageBcc:
      type: array
      items:
        type: string
    type_messages:MessageSubject:
      type: string
    type_messages:MessagePreview:
      type: string
    type_messages:MessageText:
      type: string
    type_messages:MessageHtml:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:Attachment:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
      required:
        - attachment_id
        - size
    type_messages:MessageAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_messages:MessageInReplyTo:
      type: string
    type_messages:MessageReferences:
      type: array
      items:
        type: string
    type_messages:MessageHeaders:
      type: object
      additionalProperties:
        type: string
    type_messages:MessageSize:
      type: integer
    type_messages:MessageUpdatedAt:
      type: string
      format: date-time
    type_messages:MessageCreatedAt:
      type: string
      format: date-time
    type_messages:Message:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        labels:
          $ref: '#/components/schemas/type_messages:MessageLabels'
        timestamp:
          $ref: '#/components/schemas/type_messages:MessageTimestamp'
        from:
          $ref: '#/components/schemas/type_messages:MessageFrom'
        reply_to:
          type: array
          items:
            type: string
          description: >-
            Reply-to addresses. In format `username@domain.com` or `Display Name
            <username@domain.com>`.
        to:
          $ref: '#/components/schemas/type_messages:MessageTo'
        cc:
          $ref: '#/components/schemas/type_messages:MessageCc'
        bcc:
          $ref: '#/components/schemas/type_messages:MessageBcc'
        subject:
          $ref: '#/components/schemas/type_messages:MessageSubject'
        preview:
          $ref: '#/components/schemas/type_messages:MessagePreview'
        text:
          $ref: '#/components/schemas/type_messages:MessageText'
        html:
          $ref: '#/components/schemas/type_messages:MessageHtml'
        extracted_text:
          type: string
          description: Extracted new text content.
        extracted_html:
          type: string
          description: Extracted new HTML content.
        attachments:
          $ref: '#/components/schemas/type_messages:MessageAttachments'
        in_reply_to:
          $ref: '#/components/schemas/type_messages:MessageInReplyTo'
        references:
          $ref: '#/components/schemas/type_messages:MessageReferences'
        headers:
          $ref: '#/components/schemas/type_messages:MessageHeaders'
        size:
          $ref: '#/components/schemas/type_messages:MessageSize'
        updated_at:
          $ref: '#/components/schemas/type_messages:MessageUpdatedAt'
        created_at:
          $ref: '#/components/schemas/type_messages:MessageCreatedAt'
      required:
        - inbox_id
        - thread_id
        - message_id
        - labels
        - timestamp
        - from
        - to
        - size
        - updated_at
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.messages.update("inbox_id", "message_id", {});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.messages.update(
    inbox_id="inbox_id",
    message_id="message_id"
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("PATCH", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Patch.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.patch("https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('PATCH', 'https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id");
var request = new RestRequest(Method.PATCH);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id/messages/message_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# List Drafts

GET https://api.agentmail.to/v0/inboxes/{inbox_id}/drafts

Reference: https://docs.agentmail.to/api-reference/inboxes/drafts/list

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: List Drafts
  version: endpoint_inboxes/drafts.list
paths:
  /v0/inboxes/{inbox_id}/drafts:
    get:
      operationId: list
      summary: List Drafts
      tags:
        - - subpackage_inboxes
          - subpackage_inboxes/drafts
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: limit
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Limit'
        - name: page_token
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:PageToken'
        - name: labels
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Labels'
        - name: before
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Before'
        - name: after
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:After'
        - name: ascending
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Ascending'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_drafts:ListDraftsResponse'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_:Limit:
      type: integer
    type_:PageToken:
      type: string
    type_:Labels:
      type: array
      items:
        type: string
    type_:Before:
      type: string
      format: date-time
    type_:After:
      type: string
      format: date-time
    type_:Ascending:
      type: boolean
    type_:Count:
      type: integer
    type_threads:ThreadId:
      type: string
    type_drafts:DraftId:
      type: string
    type_drafts:DraftLabels:
      type: array
      items:
        type: string
    type_drafts:DraftTo:
      type: array
      items:
        type: string
    type_drafts:DraftCc:
      type: array
      items:
        type: string
    type_drafts:DraftBcc:
      type: array
      items:
        type: string
    type_drafts:DraftSubject:
      type: string
    type_drafts:DraftPreview:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:Attachment:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
      required:
        - attachment_id
        - size
    type_drafts:DraftAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_drafts:DraftSendStatus:
      type: string
      enum:
        - value: scheduled
        - value: sending
        - value: failed
    type_drafts:DraftSendAt:
      type: string
      format: date-time
    type_drafts:DraftUpdatedAt:
      type: string
      format: date-time
    type_drafts:DraftItem:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        draft_id:
          $ref: '#/components/schemas/type_drafts:DraftId'
        labels:
          $ref: '#/components/schemas/type_drafts:DraftLabels'
        to:
          $ref: '#/components/schemas/type_drafts:DraftTo'
        cc:
          $ref: '#/components/schemas/type_drafts:DraftCc'
        bcc:
          $ref: '#/components/schemas/type_drafts:DraftBcc'
        subject:
          $ref: '#/components/schemas/type_drafts:DraftSubject'
        preview:
          $ref: '#/components/schemas/type_drafts:DraftPreview'
        attachments:
          $ref: '#/components/schemas/type_drafts:DraftAttachments'
        send_status:
          $ref: '#/components/schemas/type_drafts:DraftSendStatus'
        send_at:
          $ref: '#/components/schemas/type_drafts:DraftSendAt'
        updated_at:
          $ref: '#/components/schemas/type_drafts:DraftUpdatedAt'
      required:
        - inbox_id
        - thread_id
        - draft_id
        - labels
        - updated_at
    type_drafts:ListDraftsResponse:
      type: object
      properties:
        count:
          $ref: '#/components/schemas/type_:Count'
        limit:
          $ref: '#/components/schemas/type_:Limit'
        next_page_token:
          $ref: '#/components/schemas/type_:PageToken'
        drafts:
          type: array
          items:
            $ref: '#/components/schemas/type_drafts:DraftItem'
          description: Ordered by `updated_at` descending.
      required:
        - count
        - drafts

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.drafts.list("inbox_id", {});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.drafts.list(
    inbox_id="inbox_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id/drafts"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id/drafts")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/inboxes/inbox_id/drafts")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/inboxes/inbox_id/drafts', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id/drafts");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id/drafts")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get Draft

GET https://api.agentmail.to/v0/inboxes/{inbox_id}/drafts/{draft_id}

Reference: https://docs.agentmail.to/api-reference/inboxes/drafts/get

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get Draft
  version: endpoint_inboxes/drafts.get
paths:
  /v0/inboxes/{inbox_id}/drafts/{draft_id}:
    get:
      operationId: get
      summary: Get Draft
      tags:
        - - subpackage_inboxes
          - subpackage_inboxes/drafts
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: draft_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_drafts:DraftId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_drafts:Draft'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_drafts:DraftId:
      type: string
    type_threads:ThreadId:
      type: string
    type_drafts:DraftClientId:
      type: string
    type_drafts:DraftLabels:
      type: array
      items:
        type: string
    type_drafts:DraftReplyTo:
      type: array
      items:
        type: string
    type_drafts:DraftTo:
      type: array
      items:
        type: string
    type_drafts:DraftCc:
      type: array
      items:
        type: string
    type_drafts:DraftBcc:
      type: array
      items:
        type: string
    type_drafts:DraftSubject:
      type: string
    type_drafts:DraftPreview:
      type: string
    type_drafts:DraftText:
      type: string
    type_drafts:DraftHtml:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:Attachment:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
      required:
        - attachment_id
        - size
    type_drafts:DraftAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_drafts:DraftInReplyTo:
      type: string
    type_drafts:DraftSendStatus:
      type: string
      enum:
        - value: scheduled
        - value: sending
        - value: failed
    type_drafts:DraftSendAt:
      type: string
      format: date-time
    type_drafts:DraftUpdatedAt:
      type: string
      format: date-time
    type_drafts:Draft:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        draft_id:
          $ref: '#/components/schemas/type_drafts:DraftId'
        client_id:
          $ref: '#/components/schemas/type_drafts:DraftClientId'
        labels:
          $ref: '#/components/schemas/type_drafts:DraftLabels'
        reply_to:
          $ref: '#/components/schemas/type_drafts:DraftReplyTo'
        to:
          $ref: '#/components/schemas/type_drafts:DraftTo'
        cc:
          $ref: '#/components/schemas/type_drafts:DraftCc'
        bcc:
          $ref: '#/components/schemas/type_drafts:DraftBcc'
        subject:
          $ref: '#/components/schemas/type_drafts:DraftSubject'
        preview:
          $ref: '#/components/schemas/type_drafts:DraftPreview'
        text:
          $ref: '#/components/schemas/type_drafts:DraftText'
        html:
          $ref: '#/components/schemas/type_drafts:DraftHtml'
        attachments:
          $ref: '#/components/schemas/type_drafts:DraftAttachments'
        in_reply_to:
          $ref: '#/components/schemas/type_drafts:DraftInReplyTo'
        references:
          type: array
          items:
            type: string
          description: IDs of previous messages in thread.
        send_status:
          $ref: '#/components/schemas/type_drafts:DraftSendStatus'
        send_at:
          $ref: '#/components/schemas/type_drafts:DraftSendAt'
        updated_at:
          $ref: '#/components/schemas/type_drafts:DraftUpdatedAt'
        created_at:
          type: string
          format: date-time
          description: Time at which draft was created.
      required:
        - inbox_id
        - thread_id
        - draft_id
        - labels
        - updated_at
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.drafts.get("inbox_id", "draft_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.drafts.get(
    inbox_id="inbox_id",
    draft_id="draft_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Create Draft

POST https://api.agentmail.to/v0/inboxes/{inbox_id}/drafts
Content-Type: application/json

Reference: https://docs.agentmail.to/api-reference/inboxes/drafts/create

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Create Draft
  version: endpoint_inboxes/drafts.create
paths:
  /v0/inboxes/{inbox_id}/drafts:
    post:
      operationId: create
      summary: Create Draft
      tags:
        - - subpackage_inboxes
          - subpackage_inboxes/drafts
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_drafts:Draft'
        '404':
          description: Error response with status 404
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_drafts:CreateDraftRequest'
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_drafts:DraftLabels:
      type: array
      items:
        type: string
    type_drafts:DraftReplyTo:
      type: array
      items:
        type: string
    type_drafts:DraftTo:
      type: array
      items:
        type: string
    type_drafts:DraftCc:
      type: array
      items:
        type: string
    type_drafts:DraftBcc:
      type: array
      items:
        type: string
    type_drafts:DraftSubject:
      type: string
    type_drafts:DraftText:
      type: string
    type_drafts:DraftHtml:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:SendAttachment:
      type: object
      properties:
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
        content:
          type: string
          description: Base64 encoded content of attachment.
        url:
          type: string
          description: URL to the attachment.
    type_drafts:DraftInReplyTo:
      type: string
    type_drafts:DraftSendAt:
      type: string
      format: date-time
    type_drafts:DraftClientId:
      type: string
    type_drafts:CreateDraftRequest:
      type: object
      properties:
        labels:
          $ref: '#/components/schemas/type_drafts:DraftLabels'
        reply_to:
          $ref: '#/components/schemas/type_drafts:DraftReplyTo'
        to:
          $ref: '#/components/schemas/type_drafts:DraftTo'
        cc:
          $ref: '#/components/schemas/type_drafts:DraftCc'
        bcc:
          $ref: '#/components/schemas/type_drafts:DraftBcc'
        subject:
          $ref: '#/components/schemas/type_drafts:DraftSubject'
        text:
          $ref: '#/components/schemas/type_drafts:DraftText'
        html:
          $ref: '#/components/schemas/type_drafts:DraftHtml'
        attachments:
          type: array
          items:
            $ref: '#/components/schemas/type_attachments:SendAttachment'
          description: Attachments to include in draft.
        in_reply_to:
          $ref: '#/components/schemas/type_drafts:DraftInReplyTo'
        send_at:
          $ref: '#/components/schemas/type_drafts:DraftSendAt'
        client_id:
          $ref: '#/components/schemas/type_drafts:DraftClientId'
    type_threads:ThreadId:
      type: string
    type_drafts:DraftId:
      type: string
    type_drafts:DraftPreview:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:Attachment:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
      required:
        - attachment_id
        - size
    type_drafts:DraftAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_drafts:DraftSendStatus:
      type: string
      enum:
        - value: scheduled
        - value: sending
        - value: failed
    type_drafts:DraftUpdatedAt:
      type: string
      format: date-time
    type_drafts:Draft:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        draft_id:
          $ref: '#/components/schemas/type_drafts:DraftId'
        client_id:
          $ref: '#/components/schemas/type_drafts:DraftClientId'
        labels:
          $ref: '#/components/schemas/type_drafts:DraftLabels'
        reply_to:
          $ref: '#/components/schemas/type_drafts:DraftReplyTo'
        to:
          $ref: '#/components/schemas/type_drafts:DraftTo'
        cc:
          $ref: '#/components/schemas/type_drafts:DraftCc'
        bcc:
          $ref: '#/components/schemas/type_drafts:DraftBcc'
        subject:
          $ref: '#/components/schemas/type_drafts:DraftSubject'
        preview:
          $ref: '#/components/schemas/type_drafts:DraftPreview'
        text:
          $ref: '#/components/schemas/type_drafts:DraftText'
        html:
          $ref: '#/components/schemas/type_drafts:DraftHtml'
        attachments:
          $ref: '#/components/schemas/type_drafts:DraftAttachments'
        in_reply_to:
          $ref: '#/components/schemas/type_drafts:DraftInReplyTo'
        references:
          type: array
          items:
            type: string
          description: IDs of previous messages in thread.
        send_status:
          $ref: '#/components/schemas/type_drafts:DraftSendStatus'
        send_at:
          $ref: '#/components/schemas/type_drafts:DraftSendAt'
        updated_at:
          $ref: '#/components/schemas/type_drafts:DraftUpdatedAt'
        created_at:
          type: string
          format: date-time
          description: Time at which draft was created.
      required:
        - inbox_id
        - thread_id
        - draft_id
        - labels
        - updated_at
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.drafts.create("inbox_id", {});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.drafts.create(
    inbox_id="inbox_id"
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id/drafts"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id/drafts")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Post.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.post("https://api.agentmail.to/v0/inboxes/inbox_id/drafts")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('POST', 'https://api.agentmail.to/v0/inboxes/inbox_id/drafts', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id/drafts");
var request = new RestRequest(Method.POST);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id/drafts")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Update Draft

PATCH https://api.agentmail.to/v0/inboxes/{inbox_id}/drafts/{draft_id}
Content-Type: application/json

Reference: https://docs.agentmail.to/api-reference/inboxes/drafts/update

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Update Draft
  version: endpoint_inboxes/drafts.update
paths:
  /v0/inboxes/{inbox_id}/drafts/{draft_id}:
    patch:
      operationId: update
      summary: Update Draft
      tags:
        - - subpackage_inboxes
          - subpackage_inboxes/drafts
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: draft_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_drafts:DraftId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_drafts:Draft'
        '404':
          description: Error response with status 404
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_drafts:UpdateDraftRequest'
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_drafts:DraftId:
      type: string
    type_drafts:DraftReplyTo:
      type: array
      items:
        type: string
    type_drafts:DraftTo:
      type: array
      items:
        type: string
    type_drafts:DraftCc:
      type: array
      items:
        type: string
    type_drafts:DraftBcc:
      type: array
      items:
        type: string
    type_drafts:DraftSubject:
      type: string
    type_drafts:DraftText:
      type: string
    type_drafts:DraftHtml:
      type: string
    type_drafts:DraftSendAt:
      type: string
      format: date-time
    type_drafts:UpdateDraftRequest:
      type: object
      properties:
        reply_to:
          $ref: '#/components/schemas/type_drafts:DraftReplyTo'
        to:
          $ref: '#/components/schemas/type_drafts:DraftTo'
        cc:
          $ref: '#/components/schemas/type_drafts:DraftCc'
        bcc:
          $ref: '#/components/schemas/type_drafts:DraftBcc'
        subject:
          $ref: '#/components/schemas/type_drafts:DraftSubject'
        text:
          $ref: '#/components/schemas/type_drafts:DraftText'
        html:
          $ref: '#/components/schemas/type_drafts:DraftHtml'
        send_at:
          $ref: '#/components/schemas/type_drafts:DraftSendAt'
    type_threads:ThreadId:
      type: string
    type_drafts:DraftClientId:
      type: string
    type_drafts:DraftLabels:
      type: array
      items:
        type: string
    type_drafts:DraftPreview:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:Attachment:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
      required:
        - attachment_id
        - size
    type_drafts:DraftAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_drafts:DraftInReplyTo:
      type: string
    type_drafts:DraftSendStatus:
      type: string
      enum:
        - value: scheduled
        - value: sending
        - value: failed
    type_drafts:DraftUpdatedAt:
      type: string
      format: date-time
    type_drafts:Draft:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        draft_id:
          $ref: '#/components/schemas/type_drafts:DraftId'
        client_id:
          $ref: '#/components/schemas/type_drafts:DraftClientId'
        labels:
          $ref: '#/components/schemas/type_drafts:DraftLabels'
        reply_to:
          $ref: '#/components/schemas/type_drafts:DraftReplyTo'
        to:
          $ref: '#/components/schemas/type_drafts:DraftTo'
        cc:
          $ref: '#/components/schemas/type_drafts:DraftCc'
        bcc:
          $ref: '#/components/schemas/type_drafts:DraftBcc'
        subject:
          $ref: '#/components/schemas/type_drafts:DraftSubject'
        preview:
          $ref: '#/components/schemas/type_drafts:DraftPreview'
        text:
          $ref: '#/components/schemas/type_drafts:DraftText'
        html:
          $ref: '#/components/schemas/type_drafts:DraftHtml'
        attachments:
          $ref: '#/components/schemas/type_drafts:DraftAttachments'
        in_reply_to:
          $ref: '#/components/schemas/type_drafts:DraftInReplyTo'
        references:
          type: array
          items:
            type: string
          description: IDs of previous messages in thread.
        send_status:
          $ref: '#/components/schemas/type_drafts:DraftSendStatus'
        send_at:
          $ref: '#/components/schemas/type_drafts:DraftSendAt'
        updated_at:
          $ref: '#/components/schemas/type_drafts:DraftUpdatedAt'
        created_at:
          type: string
          format: date-time
          description: Time at which draft was created.
      required:
        - inbox_id
        - thread_id
        - draft_id
        - labels
        - updated_at
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.drafts.update("inbox_id", "draft_id", {});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.drafts.update(
    inbox_id="inbox_id",
    draft_id="draft_id"
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("PATCH", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Patch.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.patch("https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('PATCH', 'https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id");
var request = new RestRequest(Method.PATCH);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Send Draft

POST https://api.agentmail.to/v0/inboxes/{inbox_id}/drafts/{draft_id}/send
Content-Type: application/json

Reference: https://docs.agentmail.to/api-reference/inboxes/drafts/send

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Send Draft
  version: endpoint_inboxes/drafts.send
paths:
  /v0/inboxes/{inbox_id}/drafts/{draft_id}/send:
    post:
      operationId: send
      summary: Send Draft
      tags:
        - - subpackage_inboxes
          - subpackage_inboxes/drafts
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: draft_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_drafts:DraftId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_messages:SendMessageResponse'
        '400':
          description: Error response with status 400
          content: {}
        '403':
          description: Error response with status 403
          content: {}
        '404':
          description: Error response with status 404
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_messages:UpdateMessageRequest'
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_drafts:DraftId:
      type: string
    type_messages:UpdateMessageRequest:
      type: object
      properties:
        add_labels:
          type: array
          items:
            type: string
          description: Labels to add to message.
        remove_labels:
          type: array
          items:
            type: string
          description: Labels to remove from message.
    type_messages:MessageId:
      type: string
    type_threads:ThreadId:
      type: string
    type_messages:SendMessageResponse:
      type: object
      properties:
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
      required:
        - message_id
        - thread_id

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.drafts.send("inbox_id", "draft_id", {});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.drafts.send(
    inbox_id="inbox_id",
    draft_id="draft_id"
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id/send"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id/send")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Post.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.post("https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id/send")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('POST', 'https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id/send', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id/send");
var request = new RestRequest(Method.POST);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id/send")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Delete Draft

DELETE https://api.agentmail.to/v0/inboxes/{inbox_id}/drafts/{draft_id}

Reference: https://docs.agentmail.to/api-reference/inboxes/drafts/delete

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Delete Draft
  version: endpoint_inboxes/drafts.delete
paths:
  /v0/inboxes/{inbox_id}/drafts/{draft_id}:
    delete:
      operationId: delete
      summary: Delete Draft
      tags:
        - - subpackage_inboxes
          - subpackage_inboxes/drafts
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: draft_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_drafts:DraftId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Successful response
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_drafts:DraftId:
      type: string

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.drafts.delete("inbox_id", "draft_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.drafts.delete(
    inbox_id="inbox_id",
    draft_id="draft_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id"

	req, _ := http.NewRequest("DELETE", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Delete.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.delete("https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('DELETE', 'https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id");
var request = new RestRequest(Method.DELETE);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id/drafts/draft_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "DELETE"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# List Metrics

GET https://api.agentmail.to/v0/inboxes/{inbox_id}/metrics

Reference: https://docs.agentmail.to/api-reference/inboxes/metrics/get

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: List Metrics
  version: endpoint_inboxes/metrics.get
paths:
  /v0/inboxes/{inbox_id}/metrics:
    get:
      operationId: get
      summary: List Metrics
      tags:
        - - subpackage_inboxes
          - subpackage_inboxes/metrics
      parameters:
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: event_types
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_metrics:MetricEventTypes'
        - name: start_timestamp
          in: query
          required: true
          schema:
            $ref: '#/components/schemas/type_metrics:MetricStartTimestamp'
        - name: end_timestamp
          in: query
          required: true
          schema:
            $ref: '#/components/schemas/type_metrics:MetricEndTimestamp'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_metrics:ListMetricsResponse'
        '400':
          description: Error response with status 400
          content: {}
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_inboxes:InboxId:
      type: string
    type_metrics:MetricEventType:
      type: string
      enum:
        - value: message.sent
        - value: message.delivered
        - value: message.bounced
        - value: message.delayed
        - value: message.rejected
        - value: message.complained
        - value: message.received
    type_metrics:MetricEventTypes:
      type: array
      items:
        $ref: '#/components/schemas/type_metrics:MetricEventType'
    type_metrics:MetricStartTimestamp:
      type: string
      format: date-time
    type_metrics:MetricEndTimestamp:
      type: string
      format: date-time
    type_metrics:MetricTimestamp:
      type: string
      format: date-time
    type_metrics:MessageMetrics:
      type: object
      properties:
        sent:
          type: array
          items:
            $ref: '#/components/schemas/type_metrics:MetricTimestamp'
          description: Timestamps when messages were sent.
        delivered:
          type: array
          items:
            $ref: '#/components/schemas/type_metrics:MetricTimestamp'
          description: Timestamps when messages were delivered.
        bounced:
          type: array
          items:
            $ref: '#/components/schemas/type_metrics:MetricTimestamp'
          description: Timestamps when messages bounced.
        delayed:
          type: array
          items:
            $ref: '#/components/schemas/type_metrics:MetricTimestamp'
          description: Timestamps when messages were delayed.
        rejected:
          type: array
          items:
            $ref: '#/components/schemas/type_metrics:MetricTimestamp'
          description: Timestamps when messages were rejected.
        complained:
          type: array
          items:
            $ref: '#/components/schemas/type_metrics:MetricTimestamp'
          description: Timestamps when messages received complaints.
        received:
          type: array
          items:
            $ref: '#/components/schemas/type_metrics:MetricTimestamp'
          description: Timestamps when messages were received.
    type_metrics:ListMetricsResponse:
      type: object
      properties:
        message:
          $ref: '#/components/schemas/type_metrics:MessageMetrics'
          description: Message metrics grouped by event type.

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.inboxes.metrics.get("inbox_id", {
        startTimestamp: new Date("2024-01-15T09:30:00Z"),
        endTimestamp: new Date("2024-01-15T09:30:00Z"),
    });
}
main();

```

```python
from agentmail import AgentMail
from datetime import datetime

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.inboxes.metrics.get(
    inbox_id="inbox_id",
    start_timestamp=datetime.fromisoformat("2024-01-15T09:30:00Z"),
    end_timestamp=datetime.fromisoformat("2024-01-15T09:30:00Z")
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/inboxes/inbox_id/metrics?start_timestamp=2024-01-15T09%3A30%3A00Z&end_timestamp=2024-01-15T09%3A30%3A00Z"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("GET", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/inboxes/inbox_id/metrics?start_timestamp=2024-01-15T09%3A30%3A00Z&end_timestamp=2024-01-15T09%3A30%3A00Z")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/inboxes/inbox_id/metrics?start_timestamp=2024-01-15T09%3A30%3A00Z&end_timestamp=2024-01-15T09%3A30%3A00Z")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/inboxes/inbox_id/metrics?start_timestamp=2024-01-15T09%3A30%3A00Z&end_timestamp=2024-01-15T09%3A30%3A00Z', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/inboxes/inbox_id/metrics?start_timestamp=2024-01-15T09%3A30%3A00Z&end_timestamp=2024-01-15T09%3A30%3A00Z");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/inboxes/inbox_id/metrics?start_timestamp=2024-01-15T09%3A30%3A00Z&end_timestamp=2024-01-15T09%3A30%3A00Z")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# List Threads

GET https://api.agentmail.to/v0/threads

Reference: https://docs.agentmail.to/api-reference/threads/list

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: List Threads
  version: endpoint_threads.list
paths:
  /v0/threads:
    get:
      operationId: list
      summary: List Threads
      tags:
        - - subpackage_threads
      parameters:
        - name: limit
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Limit'
        - name: page_token
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:PageToken'
        - name: labels
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Labels'
        - name: before
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Before'
        - name: after
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:After'
        - name: ascending
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Ascending'
        - name: include_spam
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:IncludeSpam'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_threads:ListThreadsResponse'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_:Limit:
      type: integer
    type_:PageToken:
      type: string
    type_:Labels:
      type: array
      items:
        type: string
    type_:Before:
      type: string
      format: date-time
    type_:After:
      type: string
      format: date-time
    type_:Ascending:
      type: boolean
    type_:IncludeSpam:
      type: boolean
    type_:Count:
      type: integer
    type_inboxes:InboxId:
      type: string
    type_threads:ThreadId:
      type: string
    type_threads:ThreadLabels:
      type: array
      items:
        type: string
    type_threads:ThreadTimestamp:
      type: string
      format: date-time
    type_threads:ThreadReceivedTimestamp:
      type: string
      format: date-time
    type_threads:ThreadSentTimestamp:
      type: string
      format: date-time
    type_threads:ThreadSenders:
      type: array
      items:
        type: string
    type_threads:ThreadRecipients:
      type: array
      items:
        type: string
    type_threads:ThreadSubject:
      type: string
    type_threads:ThreadPreview:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:Attachment:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
      required:
        - attachment_id
        - size
    type_threads:ThreadAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_threads:ThreadLastMessageId:
      type: string
    type_threads:ThreadMessageCount:
      type: integer
    type_threads:ThreadSize:
      type: integer
    type_threads:ThreadUpdatedAt:
      type: string
      format: date-time
    type_threads:ThreadCreatedAt:
      type: string
      format: date-time
    type_threads:ThreadItem:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        labels:
          $ref: '#/components/schemas/type_threads:ThreadLabels'
        timestamp:
          $ref: '#/components/schemas/type_threads:ThreadTimestamp'
        received_timestamp:
          $ref: '#/components/schemas/type_threads:ThreadReceivedTimestamp'
        sent_timestamp:
          $ref: '#/components/schemas/type_threads:ThreadSentTimestamp'
        senders:
          $ref: '#/components/schemas/type_threads:ThreadSenders'
        recipients:
          $ref: '#/components/schemas/type_threads:ThreadRecipients'
        subject:
          $ref: '#/components/schemas/type_threads:ThreadSubject'
        preview:
          $ref: '#/components/schemas/type_threads:ThreadPreview'
        attachments:
          $ref: '#/components/schemas/type_threads:ThreadAttachments'
        last_message_id:
          $ref: '#/components/schemas/type_threads:ThreadLastMessageId'
        message_count:
          $ref: '#/components/schemas/type_threads:ThreadMessageCount'
        size:
          $ref: '#/components/schemas/type_threads:ThreadSize'
        updated_at:
          $ref: '#/components/schemas/type_threads:ThreadUpdatedAt'
        created_at:
          $ref: '#/components/schemas/type_threads:ThreadCreatedAt'
      required:
        - inbox_id
        - thread_id
        - labels
        - timestamp
        - senders
        - recipients
        - last_message_id
        - message_count
        - size
        - updated_at
        - created_at
    type_threads:ListThreadsResponse:
      type: object
      properties:
        count:
          $ref: '#/components/schemas/type_:Count'
        limit:
          $ref: '#/components/schemas/type_:Limit'
        next_page_token:
          $ref: '#/components/schemas/type_:PageToken'
        threads:
          type: array
          items:
            $ref: '#/components/schemas/type_threads:ThreadItem'
          description: Ordered by `timestamp` descending.
      required:
        - count
        - threads

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.threads.list({});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.threads.list()

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/threads"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("GET", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/threads")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/threads")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/threads', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/threads");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/threads")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get Thread

GET https://api.agentmail.to/v0/threads/{thread_id}

Reference: https://docs.agentmail.to/api-reference/threads/get

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get Thread
  version: endpoint_threads.get
paths:
  /v0/threads/{thread_id}:
    get:
      operationId: get
      summary: Get Thread
      tags:
        - - subpackage_threads
      parameters:
        - name: thread_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_threads:ThreadId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_threads:Thread'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_threads:ThreadId:
      type: string
    type_inboxes:InboxId:
      type: string
    type_threads:ThreadLabels:
      type: array
      items:
        type: string
    type_threads:ThreadTimestamp:
      type: string
      format: date-time
    type_threads:ThreadReceivedTimestamp:
      type: string
      format: date-time
    type_threads:ThreadSentTimestamp:
      type: string
      format: date-time
    type_threads:ThreadSenders:
      type: array
      items:
        type: string
    type_threads:ThreadRecipients:
      type: array
      items:
        type: string
    type_threads:ThreadSubject:
      type: string
    type_threads:ThreadPreview:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:Attachment:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
      required:
        - attachment_id
        - size
    type_threads:ThreadAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_threads:ThreadLastMessageId:
      type: string
    type_threads:ThreadMessageCount:
      type: integer
    type_threads:ThreadSize:
      type: integer
    type_threads:ThreadUpdatedAt:
      type: string
      format: date-time
    type_threads:ThreadCreatedAt:
      type: string
      format: date-time
    type_messages:MessageId:
      type: string
    type_messages:MessageLabels:
      type: array
      items:
        type: string
    type_messages:MessageTimestamp:
      type: string
      format: date-time
    type_messages:MessageFrom:
      type: string
    type_messages:MessageTo:
      type: array
      items:
        type: string
    type_messages:MessageCc:
      type: array
      items:
        type: string
    type_messages:MessageBcc:
      type: array
      items:
        type: string
    type_messages:MessageSubject:
      type: string
    type_messages:MessagePreview:
      type: string
    type_messages:MessageText:
      type: string
    type_messages:MessageHtml:
      type: string
    type_messages:MessageAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_messages:MessageInReplyTo:
      type: string
    type_messages:MessageReferences:
      type: array
      items:
        type: string
    type_messages:MessageHeaders:
      type: object
      additionalProperties:
        type: string
    type_messages:MessageSize:
      type: integer
    type_messages:MessageUpdatedAt:
      type: string
      format: date-time
    type_messages:MessageCreatedAt:
      type: string
      format: date-time
    type_messages:Message:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        labels:
          $ref: '#/components/schemas/type_messages:MessageLabels'
        timestamp:
          $ref: '#/components/schemas/type_messages:MessageTimestamp'
        from:
          $ref: '#/components/schemas/type_messages:MessageFrom'
        reply_to:
          type: array
          items:
            type: string
          description: >-
            Reply-to addresses. In format `username@domain.com` or `Display Name
            <username@domain.com>`.
        to:
          $ref: '#/components/schemas/type_messages:MessageTo'
        cc:
          $ref: '#/components/schemas/type_messages:MessageCc'
        bcc:
          $ref: '#/components/schemas/type_messages:MessageBcc'
        subject:
          $ref: '#/components/schemas/type_messages:MessageSubject'
        preview:
          $ref: '#/components/schemas/type_messages:MessagePreview'
        text:
          $ref: '#/components/schemas/type_messages:MessageText'
        html:
          $ref: '#/components/schemas/type_messages:MessageHtml'
        extracted_text:
          type: string
          description: Extracted new text content.
        extracted_html:
          type: string
          description: Extracted new HTML content.
        attachments:
          $ref: '#/components/schemas/type_messages:MessageAttachments'
        in_reply_to:
          $ref: '#/components/schemas/type_messages:MessageInReplyTo'
        references:
          $ref: '#/components/schemas/type_messages:MessageReferences'
        headers:
          $ref: '#/components/schemas/type_messages:MessageHeaders'
        size:
          $ref: '#/components/schemas/type_messages:MessageSize'
        updated_at:
          $ref: '#/components/schemas/type_messages:MessageUpdatedAt'
        created_at:
          $ref: '#/components/schemas/type_messages:MessageCreatedAt'
      required:
        - inbox_id
        - thread_id
        - message_id
        - labels
        - timestamp
        - from
        - to
        - size
        - updated_at
        - created_at
    type_threads:Thread:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        labels:
          $ref: '#/components/schemas/type_threads:ThreadLabels'
        timestamp:
          $ref: '#/components/schemas/type_threads:ThreadTimestamp'
        received_timestamp:
          $ref: '#/components/schemas/type_threads:ThreadReceivedTimestamp'
        sent_timestamp:
          $ref: '#/components/schemas/type_threads:ThreadSentTimestamp'
        senders:
          $ref: '#/components/schemas/type_threads:ThreadSenders'
        recipients:
          $ref: '#/components/schemas/type_threads:ThreadRecipients'
        subject:
          $ref: '#/components/schemas/type_threads:ThreadSubject'
        preview:
          $ref: '#/components/schemas/type_threads:ThreadPreview'
        attachments:
          $ref: '#/components/schemas/type_threads:ThreadAttachments'
        last_message_id:
          $ref: '#/components/schemas/type_threads:ThreadLastMessageId'
        message_count:
          $ref: '#/components/schemas/type_threads:ThreadMessageCount'
        size:
          $ref: '#/components/schemas/type_threads:ThreadSize'
        updated_at:
          $ref: '#/components/schemas/type_threads:ThreadUpdatedAt'
        created_at:
          $ref: '#/components/schemas/type_threads:ThreadCreatedAt'
        messages:
          type: array
          items:
            $ref: '#/components/schemas/type_messages:Message'
          description: Messages in thread. Ordered by `timestamp` ascending.
      required:
        - inbox_id
        - thread_id
        - labels
        - timestamp
        - senders
        - recipients
        - last_message_id
        - message_count
        - size
        - updated_at
        - created_at
        - messages

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.threads.get("thread_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.threads.get(
    thread_id="thread_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/threads/thread_id"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/threads/thread_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/threads/thread_id")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/threads/thread_id', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/threads/thread_id");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/threads/thread_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get Attachment

GET https://api.agentmail.to/v0/threads/{thread_id}/attachments/{attachment_id}

Reference: https://docs.agentmail.to/api-reference/threads/get-attachment

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get Attachment
  version: endpoint_threads.getAttachment
paths:
  /v0/threads/{thread_id}/attachments/{attachment_id}:
    get:
      operationId: get-attachment
      summary: Get Attachment
      tags:
        - - subpackage_threads
      parameters:
        - name: thread_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_threads:ThreadId'
        - name: attachment_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_attachments:AttachmentId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_attachments:AttachmentResponse'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_threads:ThreadId:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:AttachmentResponse:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
        download_url:
          type: string
          description: URL to download the attachment.
        expires_at:
          type: string
          format: date-time
          description: Time at which the download URL expires.
      required:
        - attachment_id
        - size
        - download_url
        - expires_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.threads.getAttachment("thread_id", "attachment_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.threads.get_attachment(
    thread_id="thread_id",
    attachment_id="attachment_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/threads/thread_id/attachments/attachment_id"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/threads/thread_id/attachments/attachment_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/threads/thread_id/attachments/attachment_id")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/threads/thread_id/attachments/attachment_id', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/threads/thread_id/attachments/attachment_id");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/threads/thread_id/attachments/attachment_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# List Drafts

GET https://api.agentmail.to/v0/drafts

Reference: https://docs.agentmail.to/api-reference/drafts/list

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: List Drafts
  version: endpoint_drafts.list
paths:
  /v0/drafts:
    get:
      operationId: list
      summary: List Drafts
      tags:
        - - subpackage_drafts
      parameters:
        - name: limit
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Limit'
        - name: page_token
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:PageToken'
        - name: labels
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Labels'
        - name: before
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Before'
        - name: after
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:After'
        - name: ascending
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Ascending'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_drafts:ListDraftsResponse'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_:Limit:
      type: integer
    type_:PageToken:
      type: string
    type_:Labels:
      type: array
      items:
        type: string
    type_:Before:
      type: string
      format: date-time
    type_:After:
      type: string
      format: date-time
    type_:Ascending:
      type: boolean
    type_:Count:
      type: integer
    type_inboxes:InboxId:
      type: string
    type_threads:ThreadId:
      type: string
    type_drafts:DraftId:
      type: string
    type_drafts:DraftLabels:
      type: array
      items:
        type: string
    type_drafts:DraftTo:
      type: array
      items:
        type: string
    type_drafts:DraftCc:
      type: array
      items:
        type: string
    type_drafts:DraftBcc:
      type: array
      items:
        type: string
    type_drafts:DraftSubject:
      type: string
    type_drafts:DraftPreview:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:Attachment:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
      required:
        - attachment_id
        - size
    type_drafts:DraftAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_drafts:DraftSendStatus:
      type: string
      enum:
        - value: scheduled
        - value: sending
        - value: failed
    type_drafts:DraftSendAt:
      type: string
      format: date-time
    type_drafts:DraftUpdatedAt:
      type: string
      format: date-time
    type_drafts:DraftItem:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        draft_id:
          $ref: '#/components/schemas/type_drafts:DraftId'
        labels:
          $ref: '#/components/schemas/type_drafts:DraftLabels'
        to:
          $ref: '#/components/schemas/type_drafts:DraftTo'
        cc:
          $ref: '#/components/schemas/type_drafts:DraftCc'
        bcc:
          $ref: '#/components/schemas/type_drafts:DraftBcc'
        subject:
          $ref: '#/components/schemas/type_drafts:DraftSubject'
        preview:
          $ref: '#/components/schemas/type_drafts:DraftPreview'
        attachments:
          $ref: '#/components/schemas/type_drafts:DraftAttachments'
        send_status:
          $ref: '#/components/schemas/type_drafts:DraftSendStatus'
        send_at:
          $ref: '#/components/schemas/type_drafts:DraftSendAt'
        updated_at:
          $ref: '#/components/schemas/type_drafts:DraftUpdatedAt'
      required:
        - inbox_id
        - thread_id
        - draft_id
        - labels
        - updated_at
    type_drafts:ListDraftsResponse:
      type: object
      properties:
        count:
          $ref: '#/components/schemas/type_:Count'
        limit:
          $ref: '#/components/schemas/type_:Limit'
        next_page_token:
          $ref: '#/components/schemas/type_:PageToken'
        drafts:
          type: array
          items:
            $ref: '#/components/schemas/type_drafts:DraftItem'
          description: Ordered by `updated_at` descending.
      required:
        - count
        - drafts

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.drafts.list({});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.drafts.list()

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/drafts"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/drafts")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/drafts")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/drafts', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/drafts");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/drafts")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get Draft

GET https://api.agentmail.to/v0/drafts/{draft_id}

Reference: https://docs.agentmail.to/api-reference/drafts/get

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get Draft
  version: endpoint_drafts.get
paths:
  /v0/drafts/{draft_id}:
    get:
      operationId: get
      summary: Get Draft
      tags:
        - - subpackage_drafts
      parameters:
        - name: draft_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_drafts:DraftId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_drafts:Draft'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_drafts:DraftId:
      type: string
    type_inboxes:InboxId:
      type: string
    type_threads:ThreadId:
      type: string
    type_drafts:DraftClientId:
      type: string
    type_drafts:DraftLabels:
      type: array
      items:
        type: string
    type_drafts:DraftReplyTo:
      type: array
      items:
        type: string
    type_drafts:DraftTo:
      type: array
      items:
        type: string
    type_drafts:DraftCc:
      type: array
      items:
        type: string
    type_drafts:DraftBcc:
      type: array
      items:
        type: string
    type_drafts:DraftSubject:
      type: string
    type_drafts:DraftPreview:
      type: string
    type_drafts:DraftText:
      type: string
    type_drafts:DraftHtml:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:Attachment:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
      required:
        - attachment_id
        - size
    type_drafts:DraftAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_drafts:DraftInReplyTo:
      type: string
    type_drafts:DraftSendStatus:
      type: string
      enum:
        - value: scheduled
        - value: sending
        - value: failed
    type_drafts:DraftSendAt:
      type: string
      format: date-time
    type_drafts:DraftUpdatedAt:
      type: string
      format: date-time
    type_drafts:Draft:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        draft_id:
          $ref: '#/components/schemas/type_drafts:DraftId'
        client_id:
          $ref: '#/components/schemas/type_drafts:DraftClientId'
        labels:
          $ref: '#/components/schemas/type_drafts:DraftLabels'
        reply_to:
          $ref: '#/components/schemas/type_drafts:DraftReplyTo'
        to:
          $ref: '#/components/schemas/type_drafts:DraftTo'
        cc:
          $ref: '#/components/schemas/type_drafts:DraftCc'
        bcc:
          $ref: '#/components/schemas/type_drafts:DraftBcc'
        subject:
          $ref: '#/components/schemas/type_drafts:DraftSubject'
        preview:
          $ref: '#/components/schemas/type_drafts:DraftPreview'
        text:
          $ref: '#/components/schemas/type_drafts:DraftText'
        html:
          $ref: '#/components/schemas/type_drafts:DraftHtml'
        attachments:
          $ref: '#/components/schemas/type_drafts:DraftAttachments'
        in_reply_to:
          $ref: '#/components/schemas/type_drafts:DraftInReplyTo'
        references:
          type: array
          items:
            type: string
          description: IDs of previous messages in thread.
        send_status:
          $ref: '#/components/schemas/type_drafts:DraftSendStatus'
        send_at:
          $ref: '#/components/schemas/type_drafts:DraftSendAt'
        updated_at:
          $ref: '#/components/schemas/type_drafts:DraftUpdatedAt'
        created_at:
          type: string
          format: date-time
          description: Time at which draft was created.
      required:
        - inbox_id
        - thread_id
        - draft_id
        - labels
        - updated_at
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.drafts.get("draft_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.drafts.get(
    draft_id="draft_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/drafts/draft_id"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/drafts/draft_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/drafts/draft_id")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/drafts/draft_id', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/drafts/draft_id");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/drafts/draft_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# List Domains

GET https://api.agentmail.to/v0/domains

Reference: https://docs.agentmail.to/api-reference/domains/list

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: List Domains
  version: endpoint_domains.list
paths:
  /v0/domains:
    get:
      operationId: list
      summary: List Domains
      tags:
        - - subpackage_domains
      parameters:
        - name: limit
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Limit'
        - name: page_token
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:PageToken'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_domains:ListDomainsResponse'
components:
  schemas:
    type_:Limit:
      type: integer
    type_:PageToken:
      type: string
    type_:Count:
      type: integer
    type_pods:PodId:
      type: string
    type_domains:DomainId:
      type: string
    type_domains:FeedbackEnabled:
      type: boolean
    type_domains:ClientId:
      type: string
    type_domains:DomainItem:
      type: object
      properties:
        pod_id:
          $ref: '#/components/schemas/type_pods:PodId'
        domain_id:
          $ref: '#/components/schemas/type_domains:DomainId'
        feedback_enabled:
          $ref: '#/components/schemas/type_domains:FeedbackEnabled'
        client_id:
          $ref: '#/components/schemas/type_domains:ClientId'
        updated_at:
          type: string
          format: date-time
          description: Time at which the domain was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which the domain was created.
      required:
        - domain_id
        - feedback_enabled
        - updated_at
        - created_at
    type_domains:ListDomainsResponse:
      type: object
      properties:
        count:
          $ref: '#/components/schemas/type_:Count'
        limit:
          $ref: '#/components/schemas/type_:Limit'
        next_page_token:
          $ref: '#/components/schemas/type_:PageToken'
        domains:
          type: array
          items:
            $ref: '#/components/schemas/type_domains:DomainItem'
          description: Ordered by `created_at` descending.
      required:
        - count
        - domains

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.domains.list({});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.domains.list()

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/domains"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("GET", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/domains")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/domains")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/domains', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/domains");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/domains")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get Domain

GET https://api.agentmail.to/v0/domains/{domain_id}

Reference: https://docs.agentmail.to/api-reference/domains/get

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get Domain
  version: endpoint_domains.get
paths:
  /v0/domains/{domain_id}:
    get:
      operationId: get
      summary: Get Domain
      tags:
        - - subpackage_domains
      parameters:
        - name: domain_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_domains:DomainId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_domains:Domain'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_domains:DomainId:
      type: string
    type_pods:PodId:
      type: string
    type_domains:VerificationStatus:
      type: string
      enum:
        - value: NOT_STARTED
        - value: PENDING
        - value: INVALID
        - value: FAILED
        - value: VERIFYING
        - value: VERIFIED
    type_domains:FeedbackEnabled:
      type: boolean
    type_domains:RecordType:
      type: string
      enum:
        - value: TXT
        - value: CNAME
        - value: MX
    type_domains:RecordStatus:
      type: string
      enum:
        - value: MISSING
        - value: INVALID
        - value: VALID
    type_domains:VerificationRecord:
      type: object
      properties:
        type:
          $ref: '#/components/schemas/type_domains:RecordType'
          description: The type of the DNS record.
        name:
          type: string
          description: The name or host of the record.
        value:
          type: string
          description: The value of the record.
        status:
          $ref: '#/components/schemas/type_domains:RecordStatus'
          description: The verification status of this specific record.
        priority:
          type: integer
          description: The priority of the MX record.
      required:
        - type
        - name
        - value
        - status
    type_domains:ClientId:
      type: string
    type_domains:Domain:
      type: object
      properties:
        pod_id:
          $ref: '#/components/schemas/type_pods:PodId'
        domain_id:
          $ref: '#/components/schemas/type_domains:DomainId'
        status:
          $ref: '#/components/schemas/type_domains:VerificationStatus'
          description: The verification status of the domain.
        feedback_enabled:
          $ref: '#/components/schemas/type_domains:FeedbackEnabled'
        records:
          type: array
          items:
            $ref: '#/components/schemas/type_domains:VerificationRecord'
          description: A list of DNS records required to verify the domain.
        client_id:
          $ref: '#/components/schemas/type_domains:ClientId'
        updated_at:
          type: string
          format: date-time
          description: Time at which the domain was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which the domain was created.
      required:
        - domain_id
        - status
        - feedback_enabled
        - records
        - updated_at
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.domains.get("domain_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.domains.get(
    domain_id="domain_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/domains/domain_id"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/domains/domain_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/domains/domain_id")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/domains/domain_id', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/domains/domain_id");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/domains/domain_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get Zone File

GET https://api.agentmail.to/v0/domains/{domain_id}/zone-file

Reference: https://docs.agentmail.to/api-reference/domains/get-zone-file

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get Zone File
  version: endpoint_domains.getZoneFile
paths:
  /v0/domains/{domain_id}/zone-file:
    get:
      operationId: get-zone-file
      summary: Get Zone File
      tags:
        - - subpackage_domains
      parameters:
        - name: domain_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_domains:DomainId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/octet-stream:
              schema:
                type: string
                format: binary
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_domains:DomainId:
      type: string

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.domains.getZoneFile(":domain_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.domains.get_zone_file(
    domain_id=":domain_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/domains/%3Adomain_id/zone-file"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/domains/%3Adomain_id/zone-file")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/domains/%3Adomain_id/zone-file")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/domains/%3Adomain_id/zone-file', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/domains/%3Adomain_id/zone-file");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/domains/%3Adomain_id/zone-file")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Create Domain

POST https://api.agentmail.to/v0/domains
Content-Type: application/json

Reference: https://docs.agentmail.to/api-reference/domains/create

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Create Domain
  version: endpoint_domains.create
paths:
  /v0/domains:
    post:
      operationId: create
      summary: Create Domain
      tags:
        - - subpackage_domains
      parameters:
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_domains:Domain'
        '400':
          description: Error response with status 400
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_domains:CreateDomainRequest'
components:
  schemas:
    type_domains:DomainName:
      type: string
    type_domains:FeedbackEnabled:
      type: boolean
    type_domains:CreateDomainRequest:
      type: object
      properties:
        domain:
          $ref: '#/components/schemas/type_domains:DomainName'
        feedback_enabled:
          $ref: '#/components/schemas/type_domains:FeedbackEnabled'
      required:
        - domain
        - feedback_enabled
    type_pods:PodId:
      type: string
    type_domains:DomainId:
      type: string
    type_domains:VerificationStatus:
      type: string
      enum:
        - value: NOT_STARTED
        - value: PENDING
        - value: INVALID
        - value: FAILED
        - value: VERIFYING
        - value: VERIFIED
    type_domains:RecordType:
      type: string
      enum:
        - value: TXT
        - value: CNAME
        - value: MX
    type_domains:RecordStatus:
      type: string
      enum:
        - value: MISSING
        - value: INVALID
        - value: VALID
    type_domains:VerificationRecord:
      type: object
      properties:
        type:
          $ref: '#/components/schemas/type_domains:RecordType'
          description: The type of the DNS record.
        name:
          type: string
          description: The name or host of the record.
        value:
          type: string
          description: The value of the record.
        status:
          $ref: '#/components/schemas/type_domains:RecordStatus'
          description: The verification status of this specific record.
        priority:
          type: integer
          description: The priority of the MX record.
      required:
        - type
        - name
        - value
        - status
    type_domains:ClientId:
      type: string
    type_domains:Domain:
      type: object
      properties:
        pod_id:
          $ref: '#/components/schemas/type_pods:PodId'
        domain_id:
          $ref: '#/components/schemas/type_domains:DomainId'
        status:
          $ref: '#/components/schemas/type_domains:VerificationStatus'
          description: The verification status of the domain.
        feedback_enabled:
          $ref: '#/components/schemas/type_domains:FeedbackEnabled'
        records:
          type: array
          items:
            $ref: '#/components/schemas/type_domains:VerificationRecord'
          description: A list of DNS records required to verify the domain.
        client_id:
          $ref: '#/components/schemas/type_domains:ClientId'
        updated_at:
          type: string
          format: date-time
          description: Time at which the domain was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which the domain was created.
      required:
        - domain_id
        - status
        - feedback_enabled
        - records
        - updated_at
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.domains.create({
        domain: "example.com",
        feedbackEnabled: true,
    });
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.domains.create(
    domain="example.com",
    feedback_enabled=True
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/domains"

	payload := strings.NewReader("{\n  \"domain\": \"example.com\",\n  \"feedback_enabled\": true\n}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/domains")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Post.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{\n  \"domain\": \"example.com\",\n  \"feedback_enabled\": true\n}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.post("https://api.agentmail.to/v0/domains")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{\n  \"domain\": \"example.com\",\n  \"feedback_enabled\": true\n}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('POST', 'https://api.agentmail.to/v0/domains', [
  'body' => '{
  "domain": "example.com",
  "feedback_enabled": true
}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/domains");
var request = new RestRequest(Method.POST);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{\n  \"domain\": \"example.com\",\n  \"feedback_enabled\": true\n}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [
  "domain": "example.com",
  "feedback_enabled": true
] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/domains")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Delete Domain

DELETE https://api.agentmail.to/v0/domains/{domain_id}

Reference: https://docs.agentmail.to/api-reference/domains/delete

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Delete Domain
  version: endpoint_domains.delete
paths:
  /v0/domains/{domain_id}:
    delete:
      operationId: delete
      summary: Delete Domain
      tags:
        - - subpackage_domains
      parameters:
        - name: domain_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_domains:DomainId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Successful response
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_domains:DomainId:
      type: string

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.domains.delete("domain_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.domains.delete(
    domain_id="domain_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/domains/domain_id"

	req, _ := http.NewRequest("DELETE", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/domains/domain_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Delete.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.delete("https://api.agentmail.to/v0/domains/domain_id")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('DELETE', 'https://api.agentmail.to/v0/domains/domain_id', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/domains/domain_id");
var request = new RestRequest(Method.DELETE);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/domains/domain_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "DELETE"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Verify Domain

POST https://api.agentmail.to/v0/domains/{domain_id}/verify

Reference: https://docs.agentmail.to/api-reference/domains/verify

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Verify Domain
  version: endpoint_domains.verify
paths:
  /v0/domains/{domain_id}/verify:
    post:
      operationId: verify
      summary: Verify Domain
      tags:
        - - subpackage_domains
      parameters:
        - name: domain_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_domains:DomainId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Successful response
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_domains:DomainId:
      type: string

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.domains.verify("domain_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.domains.verify(
    domain_id="domain_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/domains/domain_id/verify"

	req, _ := http.NewRequest("POST", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/domains/domain_id/verify")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Post.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.post("https://api.agentmail.to/v0/domains/domain_id/verify")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('POST', 'https://api.agentmail.to/v0/domains/domain_id/verify', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/domains/domain_id/verify");
var request = new RestRequest(Method.POST);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/domains/domain_id/verify")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# List Webhooks

GET https://api.agentmail.to/v0/webhooks

Reference: https://docs.agentmail.to/api-reference/webhooks/list

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: List Webhooks
  version: endpoint_webhooks.list
paths:
  /v0/webhooks:
    get:
      operationId: list
      summary: List Webhooks
      tags:
        - - subpackage_webhooks
      parameters:
        - name: limit
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Limit'
        - name: page_token
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:PageToken'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_webhooks:ListWebhooksResponse'
components:
  schemas:
    type_:Limit:
      type: integer
    type_:PageToken:
      type: string
    type_:Count:
      type: integer
    type_webhooks:WebhookId:
      type: string
    type_webhooks:Url:
      type: string
    type_events:EventType:
      type: string
      enum:
        - value: message.received
        - value: message.sent
        - value: message.delivered
        - value: message.bounced
        - value: message.complained
        - value: message.rejected
        - value: domain.verified
    type_events:EventTypes:
      type: array
      items:
        $ref: '#/components/schemas/type_events:EventType'
    type_events:PodIds:
      type: array
      items:
        type: string
    type_events:InboxIds:
      type: array
      items:
        type: string
    type_webhooks:ClientId:
      type: string
    type_webhooks:Webhook:
      type: object
      properties:
        webhook_id:
          $ref: '#/components/schemas/type_webhooks:WebhookId'
        url:
          $ref: '#/components/schemas/type_webhooks:Url'
        event_types:
          $ref: '#/components/schemas/type_events:EventTypes'
        pod_ids:
          $ref: '#/components/schemas/type_events:PodIds'
        inbox_ids:
          $ref: '#/components/schemas/type_events:InboxIds'
        secret:
          type: string
          description: Secret for webhook signature verification.
        enabled:
          type: boolean
          description: Webhook is enabled.
        updated_at:
          type: string
          format: date-time
          description: Time at which webhook was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which webhook was created.
        client_id:
          $ref: '#/components/schemas/type_webhooks:ClientId'
      required:
        - webhook_id
        - url
        - secret
        - enabled
        - updated_at
        - created_at
    type_webhooks:ListWebhooksResponse:
      type: object
      properties:
        count:
          $ref: '#/components/schemas/type_:Count'
        limit:
          $ref: '#/components/schemas/type_:Limit'
        next_page_token:
          $ref: '#/components/schemas/type_:PageToken'
        webhooks:
          type: array
          items:
            $ref: '#/components/schemas/type_webhooks:Webhook'
          description: Ordered by `created_at` descending.
      required:
        - count
        - webhooks

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.webhooks.list({});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.webhooks.list()

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/webhooks"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/webhooks")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/webhooks")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/webhooks', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/webhooks");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/webhooks")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get Webhook

GET https://api.agentmail.to/v0/webhooks/{webhook_id}

Reference: https://docs.agentmail.to/api-reference/webhooks/get

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get Webhook
  version: endpoint_webhooks.get
paths:
  /v0/webhooks/{webhook_id}:
    get:
      operationId: get
      summary: Get Webhook
      tags:
        - - subpackage_webhooks
      parameters:
        - name: webhook_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks:WebhookId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_webhooks:Webhook'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_webhooks:WebhookId:
      type: string
    type_webhooks:Url:
      type: string
    type_events:EventType:
      type: string
      enum:
        - value: message.received
        - value: message.sent
        - value: message.delivered
        - value: message.bounced
        - value: message.complained
        - value: message.rejected
        - value: domain.verified
    type_events:EventTypes:
      type: array
      items:
        $ref: '#/components/schemas/type_events:EventType'
    type_events:PodIds:
      type: array
      items:
        type: string
    type_events:InboxIds:
      type: array
      items:
        type: string
    type_webhooks:ClientId:
      type: string
    type_webhooks:Webhook:
      type: object
      properties:
        webhook_id:
          $ref: '#/components/schemas/type_webhooks:WebhookId'
        url:
          $ref: '#/components/schemas/type_webhooks:Url'
        event_types:
          $ref: '#/components/schemas/type_events:EventTypes'
        pod_ids:
          $ref: '#/components/schemas/type_events:PodIds'
        inbox_ids:
          $ref: '#/components/schemas/type_events:InboxIds'
        secret:
          type: string
          description: Secret for webhook signature verification.
        enabled:
          type: boolean
          description: Webhook is enabled.
        updated_at:
          type: string
          format: date-time
          description: Time at which webhook was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which webhook was created.
        client_id:
          $ref: '#/components/schemas/type_webhooks:ClientId'
      required:
        - webhook_id
        - url
        - secret
        - enabled
        - updated_at
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.webhooks.get("webhook_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.webhooks.get(
    webhook_id="webhook_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/webhooks/webhook_id"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/webhooks/webhook_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/webhooks/webhook_id")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/webhooks/webhook_id', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/webhooks/webhook_id");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/webhooks/webhook_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Update Webhook

PATCH https://api.agentmail.to/v0/webhooks/{webhook_id}
Content-Type: application/json

Reference: https://docs.agentmail.to/api-reference/webhooks/update

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Update Webhook
  version: endpoint_webhooks.update
paths:
  /v0/webhooks/{webhook_id}:
    patch:
      operationId: update
      summary: Update Webhook
      tags:
        - - subpackage_webhooks
      parameters:
        - name: webhook_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks:WebhookId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_webhooks:Webhook'
        '400':
          description: Error response with status 400
          content: {}
        '404':
          description: Error response with status 404
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_webhooks:UpdateWebhookRequest'
components:
  schemas:
    type_webhooks:WebhookId:
      type: string
    type_events:InboxIds:
      type: array
      items:
        type: string
    type_events:PodIds:
      type: array
      items:
        type: string
    type_webhooks:UpdateWebhookRequest:
      type: object
      properties:
        add_inbox_ids:
          $ref: '#/components/schemas/type_events:InboxIds'
          description: Inbox IDs to subscribe to the webhook.
        remove_inbox_ids:
          $ref: '#/components/schemas/type_events:InboxIds'
          description: Inbox IDs to unsubscribe from the webhook.
        add_pod_ids:
          $ref: '#/components/schemas/type_events:PodIds'
          description: Pod IDs to subscribe to the webhook.
        remove_pod_ids:
          $ref: '#/components/schemas/type_events:PodIds'
          description: Pod IDs to unsubscribe from the webhook.
    type_webhooks:Url:
      type: string
    type_events:EventType:
      type: string
      enum:
        - value: message.received
        - value: message.sent
        - value: message.delivered
        - value: message.bounced
        - value: message.complained
        - value: message.rejected
        - value: domain.verified
    type_events:EventTypes:
      type: array
      items:
        $ref: '#/components/schemas/type_events:EventType'
    type_webhooks:ClientId:
      type: string
    type_webhooks:Webhook:
      type: object
      properties:
        webhook_id:
          $ref: '#/components/schemas/type_webhooks:WebhookId'
        url:
          $ref: '#/components/schemas/type_webhooks:Url'
        event_types:
          $ref: '#/components/schemas/type_events:EventTypes'
        pod_ids:
          $ref: '#/components/schemas/type_events:PodIds'
        inbox_ids:
          $ref: '#/components/schemas/type_events:InboxIds'
        secret:
          type: string
          description: Secret for webhook signature verification.
        enabled:
          type: boolean
          description: Webhook is enabled.
        updated_at:
          type: string
          format: date-time
          description: Time at which webhook was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which webhook was created.
        client_id:
          $ref: '#/components/schemas/type_webhooks:ClientId'
      required:
        - webhook_id
        - url
        - secret
        - enabled
        - updated_at
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.webhooks.update("webhook_id", {});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.webhooks.update(
    webhook_id="webhook_id"
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/webhooks/webhook_id"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("PATCH", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/webhooks/webhook_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Patch.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.patch("https://api.agentmail.to/v0/webhooks/webhook_id")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('PATCH', 'https://api.agentmail.to/v0/webhooks/webhook_id', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/webhooks/webhook_id");
var request = new RestRequest(Method.PATCH);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/webhooks/webhook_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "PATCH"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Create Webhook

POST https://api.agentmail.to/v0/webhooks
Content-Type: application/json

Reference: https://docs.agentmail.to/api-reference/webhooks/create

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Create Webhook
  version: endpoint_webhooks.create
paths:
  /v0/webhooks:
    post:
      operationId: create
      summary: Create Webhook
      tags:
        - - subpackage_webhooks
      parameters:
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_webhooks:Webhook'
        '400':
          description: Error response with status 400
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_webhooks:CreateWebhookRequest'
components:
  schemas:
    type_webhooks:Url:
      type: string
    type_events:EventType:
      type: string
      enum:
        - value: message.received
        - value: message.sent
        - value: message.delivered
        - value: message.bounced
        - value: message.complained
        - value: message.rejected
        - value: domain.verified
    type_events:EventTypes:
      type: array
      items:
        $ref: '#/components/schemas/type_events:EventType'
    type_events:PodIds:
      type: array
      items:
        type: string
    type_events:InboxIds:
      type: array
      items:
        type: string
    type_webhooks:ClientId:
      type: string
    type_webhooks:CreateWebhookRequest:
      type: object
      properties:
        url:
          $ref: '#/components/schemas/type_webhooks:Url'
        event_types:
          $ref: '#/components/schemas/type_events:EventTypes'
        pod_ids:
          $ref: '#/components/schemas/type_events:PodIds'
        inbox_ids:
          $ref: '#/components/schemas/type_events:InboxIds'
        client_id:
          $ref: '#/components/schemas/type_webhooks:ClientId'
      required:
        - url
        - event_types
    type_webhooks:WebhookId:
      type: string
    type_webhooks:Webhook:
      type: object
      properties:
        webhook_id:
          $ref: '#/components/schemas/type_webhooks:WebhookId'
        url:
          $ref: '#/components/schemas/type_webhooks:Url'
        event_types:
          $ref: '#/components/schemas/type_events:EventTypes'
        pod_ids:
          $ref: '#/components/schemas/type_events:PodIds'
        inbox_ids:
          $ref: '#/components/schemas/type_events:InboxIds'
        secret:
          type: string
          description: Secret for webhook signature verification.
        enabled:
          type: boolean
          description: Webhook is enabled.
        updated_at:
          type: string
          format: date-time
          description: Time at which webhook was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which webhook was created.
        client_id:
          $ref: '#/components/schemas/type_webhooks:ClientId'
      required:
        - webhook_id
        - url
        - secret
        - enabled
        - updated_at
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.webhooks.create({
        url: "url",
        eventTypes: [
            "message.received",
            "message.received",
        ],
    });
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.webhooks.create(
    url="url",
    event_types=[
        "message.received",
        "message.received"
    ]
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/webhooks"

	payload := strings.NewReader("{\n  \"url\": \"url\",\n  \"event_types\": [\n    \"message.received\",\n    \"message.received\"\n  ]\n}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/webhooks")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Post.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{\n  \"url\": \"url\",\n  \"event_types\": [\n    \"message.received\",\n    \"message.received\"\n  ]\n}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.post("https://api.agentmail.to/v0/webhooks")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{\n  \"url\": \"url\",\n  \"event_types\": [\n    \"message.received\",\n    \"message.received\"\n  ]\n}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('POST', 'https://api.agentmail.to/v0/webhooks', [
  'body' => '{
  "url": "url",
  "event_types": [
    "message.received",
    "message.received"
  ]
}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/webhooks");
var request = new RestRequest(Method.POST);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{\n  \"url\": \"url\",\n  \"event_types\": [\n    \"message.received\",\n    \"message.received\"\n  ]\n}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [
  "url": "url",
  "event_types": ["message.received", "message.received"]
] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/webhooks")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Delete Webhook

DELETE https://api.agentmail.to/v0/webhooks/{webhook_id}

Reference: https://docs.agentmail.to/api-reference/webhooks/delete

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Delete Webhook
  version: endpoint_webhooks.delete
paths:
  /v0/webhooks/{webhook_id}:
    delete:
      operationId: delete
      summary: Delete Webhook
      tags:
        - - subpackage_webhooks
      parameters:
        - name: webhook_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks:WebhookId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Successful response
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_webhooks:WebhookId:
      type: string

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.webhooks.delete("webhook_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.webhooks.delete(
    webhook_id="webhook_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/webhooks/webhook_id"

	req, _ := http.NewRequest("DELETE", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/webhooks/webhook_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Delete.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.delete("https://api.agentmail.to/v0/webhooks/webhook_id")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('DELETE', 'https://api.agentmail.to/v0/webhooks/webhook_id', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/webhooks/webhook_id");
var request = new RestRequest(Method.DELETE);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/webhooks/webhook_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "DELETE"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Message Received

POST 

Reference: https://docs.agentmail.to/api-reference/webhooks/events/message-received

## OpenAPI 3.1 Webhook Specification

```yaml
openapi: 3.1.1
info:
  title: Message Received
  version: subpackage_webhooks/events.messageReceived
webhooks:
  message-received:
    post:
      operationId: message-received
      summary: Message Received
      tags:
        - subpackage_webhooks,subpackage_webhooks/events
      parameters:
        - name: svix-id
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks/events:SvixId'
        - name: svix-signature
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks/events:SvixSignature'
        - name: svix-timestamp
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks/events:SvixTimestamp'
      responses:
        '200':
          description: Webhook received successfully
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_events:MessageReceivedEvent'
components:
  schemas:
    type_webhooks/events:SvixId:
      type: string
    type_webhooks/events:SvixSignature:
      type: string
    type_webhooks/events:SvixTimestamp:
      type: string
      format: date-time
    type_events:EventId:
      type: string
    type_inboxes:InboxId:
      type: string
    type_threads:ThreadId:
      type: string
    type_messages:MessageId:
      type: string
    type_messages:MessageLabels:
      type: array
      items:
        type: string
    type_messages:MessageTimestamp:
      type: string
      format: date-time
    type_messages:MessageFrom:
      type: string
    type_messages:MessageTo:
      type: array
      items:
        type: string
    type_messages:MessageCc:
      type: array
      items:
        type: string
    type_messages:MessageBcc:
      type: array
      items:
        type: string
    type_messages:MessageSubject:
      type: string
    type_messages:MessagePreview:
      type: string
    type_messages:MessageText:
      type: string
    type_messages:MessageHtml:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:Attachment:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
      required:
        - attachment_id
        - size
    type_messages:MessageAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_messages:MessageInReplyTo:
      type: string
    type_messages:MessageReferences:
      type: array
      items:
        type: string
    type_messages:MessageHeaders:
      type: object
      additionalProperties:
        type: string
    type_messages:MessageSize:
      type: integer
    type_messages:MessageUpdatedAt:
      type: string
      format: date-time
    type_messages:MessageCreatedAt:
      type: string
      format: date-time
    type_messages:Message:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        labels:
          $ref: '#/components/schemas/type_messages:MessageLabels'
        timestamp:
          $ref: '#/components/schemas/type_messages:MessageTimestamp'
        from:
          $ref: '#/components/schemas/type_messages:MessageFrom'
        reply_to:
          type: array
          items:
            type: string
          description: >-
            Reply-to addresses. In format `username@domain.com` or `Display Name
            <username@domain.com>`.
        to:
          $ref: '#/components/schemas/type_messages:MessageTo'
        cc:
          $ref: '#/components/schemas/type_messages:MessageCc'
        bcc:
          $ref: '#/components/schemas/type_messages:MessageBcc'
        subject:
          $ref: '#/components/schemas/type_messages:MessageSubject'
        preview:
          $ref: '#/components/schemas/type_messages:MessagePreview'
        text:
          $ref: '#/components/schemas/type_messages:MessageText'
        html:
          $ref: '#/components/schemas/type_messages:MessageHtml'
        extracted_text:
          type: string
          description: Extracted new text content.
        extracted_html:
          type: string
          description: Extracted new HTML content.
        attachments:
          $ref: '#/components/schemas/type_messages:MessageAttachments'
        in_reply_to:
          $ref: '#/components/schemas/type_messages:MessageInReplyTo'
        references:
          $ref: '#/components/schemas/type_messages:MessageReferences'
        headers:
          $ref: '#/components/schemas/type_messages:MessageHeaders'
        size:
          $ref: '#/components/schemas/type_messages:MessageSize'
        updated_at:
          $ref: '#/components/schemas/type_messages:MessageUpdatedAt'
        created_at:
          $ref: '#/components/schemas/type_messages:MessageCreatedAt'
      required:
        - inbox_id
        - thread_id
        - message_id
        - labels
        - timestamp
        - from
        - to
        - size
        - updated_at
        - created_at
    type_threads:ThreadLabels:
      type: array
      items:
        type: string
    type_threads:ThreadTimestamp:
      type: string
      format: date-time
    type_threads:ThreadReceivedTimestamp:
      type: string
      format: date-time
    type_threads:ThreadSentTimestamp:
      type: string
      format: date-time
    type_threads:ThreadSenders:
      type: array
      items:
        type: string
    type_threads:ThreadRecipients:
      type: array
      items:
        type: string
    type_threads:ThreadSubject:
      type: string
    type_threads:ThreadPreview:
      type: string
    type_threads:ThreadAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_threads:ThreadLastMessageId:
      type: string
    type_threads:ThreadMessageCount:
      type: integer
    type_threads:ThreadSize:
      type: integer
    type_threads:ThreadUpdatedAt:
      type: string
      format: date-time
    type_threads:ThreadCreatedAt:
      type: string
      format: date-time
    type_threads:ThreadItem:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        labels:
          $ref: '#/components/schemas/type_threads:ThreadLabels'
        timestamp:
          $ref: '#/components/schemas/type_threads:ThreadTimestamp'
        received_timestamp:
          $ref: '#/components/schemas/type_threads:ThreadReceivedTimestamp'
        sent_timestamp:
          $ref: '#/components/schemas/type_threads:ThreadSentTimestamp'
        senders:
          $ref: '#/components/schemas/type_threads:ThreadSenders'
        recipients:
          $ref: '#/components/schemas/type_threads:ThreadRecipients'
        subject:
          $ref: '#/components/schemas/type_threads:ThreadSubject'
        preview:
          $ref: '#/components/schemas/type_threads:ThreadPreview'
        attachments:
          $ref: '#/components/schemas/type_threads:ThreadAttachments'
        last_message_id:
          $ref: '#/components/schemas/type_threads:ThreadLastMessageId'
        message_count:
          $ref: '#/components/schemas/type_threads:ThreadMessageCount'
        size:
          $ref: '#/components/schemas/type_threads:ThreadSize'
        updated_at:
          $ref: '#/components/schemas/type_threads:ThreadUpdatedAt'
        created_at:
          $ref: '#/components/schemas/type_threads:ThreadCreatedAt'
      required:
        - inbox_id
        - thread_id
        - labels
        - timestamp
        - senders
        - recipients
        - last_message_id
        - message_count
        - size
        - updated_at
        - created_at
    type_events:MessageReceivedEvent:
      type: object
      properties:
        type:
          type: string
          enum:
            - type: stringLiteral
              value: event
        event_type:
          type: string
          enum:
            - type: stringLiteral
              value: message.received
        event_id:
          $ref: '#/components/schemas/type_events:EventId'
        message:
          $ref: '#/components/schemas/type_messages:Message'
        thread:
          $ref: '#/components/schemas/type_threads:ThreadItem'
      required:
        - type
        - event_type
        - event_id
        - message
        - thread

```

# Message Sent

POST 

Reference: https://docs.agentmail.to/api-reference/webhooks/events/message-sent

## OpenAPI 3.1 Webhook Specification

```yaml
openapi: 3.1.1
info:
  title: Message Sent
  version: subpackage_webhooks/events.messageSent
webhooks:
  message-sent:
    post:
      operationId: message-sent
      summary: Message Sent
      tags:
        - subpackage_webhooks,subpackage_webhooks/events
      parameters:
        - name: svix-id
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks/events:SvixId'
        - name: svix-signature
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks/events:SvixSignature'
        - name: svix-timestamp
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks/events:SvixTimestamp'
      responses:
        '200':
          description: Webhook received successfully
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_events:MessageSentEvent'
components:
  schemas:
    type_webhooks/events:SvixId:
      type: string
    type_webhooks/events:SvixSignature:
      type: string
    type_webhooks/events:SvixTimestamp:
      type: string
      format: date-time
    type_events:EventId:
      type: string
    type_inboxes:InboxId:
      type: string
    type_threads:ThreadId:
      type: string
    type_messages:MessageId:
      type: string
    type_events:Timestamp:
      type: string
      format: date-time
    type_events:Send:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        timestamp:
          $ref: '#/components/schemas/type_events:Timestamp'
        recipients:
          type: array
          items:
            type: string
          description: Sent recipients.
      required:
        - inbox_id
        - thread_id
        - message_id
        - timestamp
        - recipients
    type_events:MessageSentEvent:
      type: object
      properties:
        type:
          type: string
          enum:
            - type: stringLiteral
              value: event
        event_type:
          type: string
          enum:
            - type: stringLiteral
              value: message.sent
        event_id:
          $ref: '#/components/schemas/type_events:EventId'
        send:
          $ref: '#/components/schemas/type_events:Send'
      required:
        - type
        - event_type
        - event_id
        - send

```

# Message Delivered

POST 

Reference: https://docs.agentmail.to/api-reference/webhooks/events/message-delivered

## OpenAPI 3.1 Webhook Specification

```yaml
openapi: 3.1.1
info:
  title: Message Delivered
  version: subpackage_webhooks/events.messageDelivered
webhooks:
  message-delivered:
    post:
      operationId: message-delivered
      summary: Message Delivered
      tags:
        - subpackage_webhooks,subpackage_webhooks/events
      parameters:
        - name: svix-id
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks/events:SvixId'
        - name: svix-signature
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks/events:SvixSignature'
        - name: svix-timestamp
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks/events:SvixTimestamp'
      responses:
        '200':
          description: Webhook received successfully
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_events:MessageDeliveredEvent'
components:
  schemas:
    type_webhooks/events:SvixId:
      type: string
    type_webhooks/events:SvixSignature:
      type: string
    type_webhooks/events:SvixTimestamp:
      type: string
      format: date-time
    type_events:EventId:
      type: string
    type_inboxes:InboxId:
      type: string
    type_threads:ThreadId:
      type: string
    type_messages:MessageId:
      type: string
    type_events:Timestamp:
      type: string
      format: date-time
    type_events:Delivery:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        timestamp:
          $ref: '#/components/schemas/type_events:Timestamp'
        recipients:
          type: array
          items:
            type: string
          description: Delivered recipients.
      required:
        - inbox_id
        - thread_id
        - message_id
        - timestamp
        - recipients
    type_events:MessageDeliveredEvent:
      type: object
      properties:
        type:
          type: string
          enum:
            - type: stringLiteral
              value: event
        event_type:
          type: string
          enum:
            - type: stringLiteral
              value: message.delivered
        event_id:
          $ref: '#/components/schemas/type_events:EventId'
        delivery:
          $ref: '#/components/schemas/type_events:Delivery'
      required:
        - type
        - event_type
        - event_id
        - delivery

```

# Message Bounced

POST 

Reference: https://docs.agentmail.to/api-reference/webhooks/events/message-bounced

## OpenAPI 3.1 Webhook Specification

```yaml
openapi: 3.1.1
info:
  title: Message Bounced
  version: subpackage_webhooks/events.messageBounced
webhooks:
  message-bounced:
    post:
      operationId: message-bounced
      summary: Message Bounced
      tags:
        - subpackage_webhooks,subpackage_webhooks/events
      parameters:
        - name: svix-id
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks/events:SvixId'
        - name: svix-signature
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks/events:SvixSignature'
        - name: svix-timestamp
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks/events:SvixTimestamp'
      responses:
        '200':
          description: Webhook received successfully
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_events:MessageBouncedEvent'
components:
  schemas:
    type_webhooks/events:SvixId:
      type: string
    type_webhooks/events:SvixSignature:
      type: string
    type_webhooks/events:SvixTimestamp:
      type: string
      format: date-time
    type_events:EventId:
      type: string
    type_inboxes:InboxId:
      type: string
    type_threads:ThreadId:
      type: string
    type_messages:MessageId:
      type: string
    type_events:Timestamp:
      type: string
      format: date-time
    type_events:Recipient:
      type: object
      properties:
        address:
          type: string
          description: Recipient address.
        status:
          type: string
          description: Recipient status.
      required:
        - address
        - status
    type_events:Bounce:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        timestamp:
          $ref: '#/components/schemas/type_events:Timestamp'
        type:
          type: string
          description: Bounce type.
        sub_type:
          type: string
          description: Bounce sub-type.
        recipients:
          type: array
          items:
            $ref: '#/components/schemas/type_events:Recipient'
          description: Bounced recipients.
      required:
        - inbox_id
        - thread_id
        - message_id
        - timestamp
        - type
        - sub_type
        - recipients
    type_events:MessageBouncedEvent:
      type: object
      properties:
        type:
          type: string
          enum:
            - type: stringLiteral
              value: event
        event_type:
          type: string
          enum:
            - type: stringLiteral
              value: message.bounced
        event_id:
          $ref: '#/components/schemas/type_events:EventId'
        bounce:
          $ref: '#/components/schemas/type_events:Bounce'
      required:
        - type
        - event_type
        - event_id
        - bounce

```

# Message Complained

POST 

Reference: https://docs.agentmail.to/api-reference/webhooks/events/message-complained

## OpenAPI 3.1 Webhook Specification

```yaml
openapi: 3.1.1
info:
  title: Message Complained
  version: subpackage_webhooks/events.messageComplained
webhooks:
  message-complained:
    post:
      operationId: message-complained
      summary: Message Complained
      tags:
        - subpackage_webhooks,subpackage_webhooks/events
      parameters:
        - name: svix-id
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks/events:SvixId'
        - name: svix-signature
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks/events:SvixSignature'
        - name: svix-timestamp
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks/events:SvixTimestamp'
      responses:
        '200':
          description: Webhook received successfully
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_events:MessageComplainedEvent'
components:
  schemas:
    type_webhooks/events:SvixId:
      type: string
    type_webhooks/events:SvixSignature:
      type: string
    type_webhooks/events:SvixTimestamp:
      type: string
      format: date-time
    type_events:EventId:
      type: string
    type_inboxes:InboxId:
      type: string
    type_threads:ThreadId:
      type: string
    type_messages:MessageId:
      type: string
    type_events:Timestamp:
      type: string
      format: date-time
    type_events:Complaint:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        timestamp:
          $ref: '#/components/schemas/type_events:Timestamp'
        type:
          type: string
          description: Complaint type.
        sub_type:
          type: string
          description: Complaint sub-type.
        recipients:
          type: array
          items:
            type: string
          description: Complained recipients.
      required:
        - inbox_id
        - thread_id
        - message_id
        - timestamp
        - type
        - sub_type
        - recipients
    type_events:MessageComplainedEvent:
      type: object
      properties:
        type:
          type: string
          enum:
            - type: stringLiteral
              value: event
        event_type:
          type: string
          enum:
            - type: stringLiteral
              value: message.complained
        event_id:
          $ref: '#/components/schemas/type_events:EventId'
        complaint:
          $ref: '#/components/schemas/type_events:Complaint'
      required:
        - type
        - event_type
        - event_id
        - complaint

```

# Message Rejected

POST 

Reference: https://docs.agentmail.to/api-reference/webhooks/events/message-rejected

## OpenAPI 3.1 Webhook Specification

```yaml
openapi: 3.1.1
info:
  title: Message Rejected
  version: subpackage_webhooks/events.messageRejected
webhooks:
  message-rejected:
    post:
      operationId: message-rejected
      summary: Message Rejected
      tags:
        - subpackage_webhooks,subpackage_webhooks/events
      parameters:
        - name: svix-id
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks/events:SvixId'
        - name: svix-signature
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks/events:SvixSignature'
        - name: svix-timestamp
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks/events:SvixTimestamp'
      responses:
        '200':
          description: Webhook received successfully
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_events:MessageRejectedEvent'
components:
  schemas:
    type_webhooks/events:SvixId:
      type: string
    type_webhooks/events:SvixSignature:
      type: string
    type_webhooks/events:SvixTimestamp:
      type: string
      format: date-time
    type_events:EventId:
      type: string
    type_inboxes:InboxId:
      type: string
    type_threads:ThreadId:
      type: string
    type_messages:MessageId:
      type: string
    type_events:Timestamp:
      type: string
      format: date-time
    type_events:Reject:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        timestamp:
          $ref: '#/components/schemas/type_events:Timestamp'
        reason:
          type: string
          description: Reject reason.
      required:
        - inbox_id
        - thread_id
        - message_id
        - timestamp
        - reason
    type_events:MessageRejectedEvent:
      type: object
      properties:
        type:
          type: string
          enum:
            - type: stringLiteral
              value: event
        event_type:
          type: string
          enum:
            - type: stringLiteral
              value: message.rejected
        event_id:
          $ref: '#/components/schemas/type_events:EventId'
        reject:
          $ref: '#/components/schemas/type_events:Reject'
      required:
        - type
        - event_type
        - event_id
        - reject

```

# Domain Verified

POST 

Reference: https://docs.agentmail.to/api-reference/webhooks/events/domain-verified

## OpenAPI 3.1 Webhook Specification

```yaml
openapi: 3.1.1
info:
  title: Domain Verified
  version: subpackage_webhooks/events.domainVerified
webhooks:
  domain-verified:
    post:
      operationId: domain-verified
      summary: Domain Verified
      tags:
        - subpackage_webhooks,subpackage_webhooks/events
      parameters:
        - name: svix-id
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks/events:SvixId'
        - name: svix-signature
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks/events:SvixSignature'
        - name: svix-timestamp
          in: header
          required: true
          schema:
            $ref: '#/components/schemas/type_webhooks/events:SvixTimestamp'
      responses:
        '200':
          description: Webhook received successfully
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_events:DomainVerifiedEvent'
components:
  schemas:
    type_webhooks/events:SvixId:
      type: string
    type_webhooks/events:SvixSignature:
      type: string
    type_webhooks/events:SvixTimestamp:
      type: string
      format: date-time
    type_events:EventId:
      type: string
    type_pods:PodId:
      type: string
    type_domains:DomainId:
      type: string
    type_domains:VerificationStatus:
      type: string
      enum:
        - value: NOT_STARTED
        - value: PENDING
        - value: INVALID
        - value: FAILED
        - value: VERIFYING
        - value: VERIFIED
    type_domains:FeedbackEnabled:
      type: boolean
    type_domains:RecordType:
      type: string
      enum:
        - value: TXT
        - value: CNAME
        - value: MX
    type_domains:RecordStatus:
      type: string
      enum:
        - value: MISSING
        - value: INVALID
        - value: VALID
    type_domains:VerificationRecord:
      type: object
      properties:
        type:
          $ref: '#/components/schemas/type_domains:RecordType'
          description: The type of the DNS record.
        name:
          type: string
          description: The name or host of the record.
        value:
          type: string
          description: The value of the record.
        status:
          $ref: '#/components/schemas/type_domains:RecordStatus'
          description: The verification status of this specific record.
        priority:
          type: integer
          description: The priority of the MX record.
      required:
        - type
        - name
        - value
        - status
    type_domains:ClientId:
      type: string
    type_domains:Domain:
      type: object
      properties:
        pod_id:
          $ref: '#/components/schemas/type_pods:PodId'
        domain_id:
          $ref: '#/components/schemas/type_domains:DomainId'
        status:
          $ref: '#/components/schemas/type_domains:VerificationStatus'
          description: The verification status of the domain.
        feedback_enabled:
          $ref: '#/components/schemas/type_domains:FeedbackEnabled'
        records:
          type: array
          items:
            $ref: '#/components/schemas/type_domains:VerificationRecord'
          description: A list of DNS records required to verify the domain.
        client_id:
          $ref: '#/components/schemas/type_domains:ClientId'
        updated_at:
          type: string
          format: date-time
          description: Time at which the domain was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which the domain was created.
      required:
        - domain_id
        - status
        - feedback_enabled
        - records
        - updated_at
        - created_at
    type_events:DomainVerifiedEvent:
      type: object
      properties:
        type:
          type: string
          enum:
            - type: stringLiteral
              value: event
        event_type:
          type: string
          enum:
            - type: stringLiteral
              value: domain.verified
        event_id:
          $ref: '#/components/schemas/type_events:EventId'
        domain:
          $ref: '#/components/schemas/type_domains:Domain'
      required:
        - type
        - event_type
        - event_id
        - domain

```

# Connect

GET /v0

Reference: https://docs.agentmail.to/api-reference/websockets/websockets

## AsyncAPI Specification

```yaml
asyncapi: 2.6.0
info:
  title: Connect
  version: subpackage_websockets.websockets
channels:
  /v0:
    bindings:
      ws:
        query:
          type: object
          properties:
            auth_token:
              type: string
    publish:
      operationId: websockets-publish
      summary: Server messages
      message:
        oneOf:
          - $ref: >-
              #/components/messages/subpackage_websockets.websockets-server-0-subscribed
          - $ref: >-
              #/components/messages/subpackage_websockets.websockets-server-1-message_received
          - $ref: >-
              #/components/messages/subpackage_websockets.websockets-server-2-message_sent
          - $ref: >-
              #/components/messages/subpackage_websockets.websockets-server-3-message_delivered
          - $ref: >-
              #/components/messages/subpackage_websockets.websockets-server-4-message_bounced
          - $ref: >-
              #/components/messages/subpackage_websockets.websockets-server-5-message_complained
          - $ref: >-
              #/components/messages/subpackage_websockets.websockets-server-6-message_rejected
          - $ref: >-
              #/components/messages/subpackage_websockets.websockets-server-7-domain_verified
    subscribe:
      operationId: websockets-subscribe
      summary: Client message
      message:
        name: subscribe
        payload:
          $ref: '#/components/schemas/type_websockets:Subscribe'
servers:
  Production:
    url: wss://ws.agentmail.to/
    protocol: wss
    x-default: true
  Development:
    url: wss://ws.agentmail.dev/
    protocol: wss
components:
  messages:
    subpackage_websockets.websockets-server-0-subscribed:
      name: subscribed
      payload:
        $ref: '#/components/schemas/type_websockets:Subscribed'
    subpackage_websockets.websockets-server-1-message_received:
      name: message_received
      payload:
        $ref: '#/components/schemas/type_events:MessageReceivedEvent'
    subpackage_websockets.websockets-server-2-message_sent:
      name: message_sent
      payload:
        $ref: '#/components/schemas/type_events:MessageSentEvent'
    subpackage_websockets.websockets-server-3-message_delivered:
      name: message_delivered
      payload:
        $ref: '#/components/schemas/type_events:MessageDeliveredEvent'
    subpackage_websockets.websockets-server-4-message_bounced:
      name: message_bounced
      payload:
        $ref: '#/components/schemas/type_events:MessageBouncedEvent'
    subpackage_websockets.websockets-server-5-message_complained:
      name: message_complained
      payload:
        $ref: '#/components/schemas/type_events:MessageComplainedEvent'
    subpackage_websockets.websockets-server-6-message_rejected:
      name: message_rejected
      payload:
        $ref: '#/components/schemas/type_events:MessageRejectedEvent'
    subpackage_websockets.websockets-server-7-domain_verified:
      name: domain_verified
      payload:
        $ref: '#/components/schemas/type_events:DomainVerifiedEvent'
  schemas:
    type_events:EventType:
      type: string
      enum:
        - value: message.received
        - value: message.sent
        - value: message.delivered
        - value: message.bounced
        - value: message.complained
        - value: message.rejected
        - value: domain.verified
    type_events:EventTypes:
      type: array
      items:
        $ref: '#/components/schemas/type_events:EventType'
    type_events:InboxIds:
      type: array
      items:
        type: string
    type_events:PodIds:
      type: array
      items:
        type: string
    type_websockets:Subscribed:
      type: object
      properties:
        type:
          type: string
          enum:
            - type: stringLiteral
              value: subscribed
        event_types:
          $ref: '#/components/schemas/type_events:EventTypes'
        inbox_ids:
          $ref: '#/components/schemas/type_events:InboxIds'
        pod_ids:
          $ref: '#/components/schemas/type_events:PodIds'
      required:
        - type
    type_events:EventId:
      type: string
    type_inboxes:InboxId:
      type: string
    type_threads:ThreadId:
      type: string
    type_messages:MessageId:
      type: string
    type_messages:MessageLabels:
      type: array
      items:
        type: string
    type_messages:MessageTimestamp:
      type: string
      format: date-time
    type_messages:MessageFrom:
      type: string
    type_messages:MessageTo:
      type: array
      items:
        type: string
    type_messages:MessageCc:
      type: array
      items:
        type: string
    type_messages:MessageBcc:
      type: array
      items:
        type: string
    type_messages:MessageSubject:
      type: string
    type_messages:MessagePreview:
      type: string
    type_messages:MessageText:
      type: string
    type_messages:MessageHtml:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:Attachment:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
      required:
        - attachment_id
        - size
    type_messages:MessageAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_messages:MessageInReplyTo:
      type: string
    type_messages:MessageReferences:
      type: array
      items:
        type: string
    type_messages:MessageHeaders:
      type: object
      additionalProperties:
        type: string
    type_messages:MessageSize:
      type: integer
    type_messages:MessageUpdatedAt:
      type: string
      format: date-time
    type_messages:MessageCreatedAt:
      type: string
      format: date-time
    type_messages:Message:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        labels:
          $ref: '#/components/schemas/type_messages:MessageLabels'
        timestamp:
          $ref: '#/components/schemas/type_messages:MessageTimestamp'
        from:
          $ref: '#/components/schemas/type_messages:MessageFrom'
        reply_to:
          type: array
          items:
            type: string
          description: >-
            Reply-to addresses. In format `username@domain.com` or `Display Name
            <username@domain.com>`.
        to:
          $ref: '#/components/schemas/type_messages:MessageTo'
        cc:
          $ref: '#/components/schemas/type_messages:MessageCc'
        bcc:
          $ref: '#/components/schemas/type_messages:MessageBcc'
        subject:
          $ref: '#/components/schemas/type_messages:MessageSubject'
        preview:
          $ref: '#/components/schemas/type_messages:MessagePreview'
        text:
          $ref: '#/components/schemas/type_messages:MessageText'
        html:
          $ref: '#/components/schemas/type_messages:MessageHtml'
        extracted_text:
          type: string
          description: Extracted new text content.
        extracted_html:
          type: string
          description: Extracted new HTML content.
        attachments:
          $ref: '#/components/schemas/type_messages:MessageAttachments'
        in_reply_to:
          $ref: '#/components/schemas/type_messages:MessageInReplyTo'
        references:
          $ref: '#/components/schemas/type_messages:MessageReferences'
        headers:
          $ref: '#/components/schemas/type_messages:MessageHeaders'
        size:
          $ref: '#/components/schemas/type_messages:MessageSize'
        updated_at:
          $ref: '#/components/schemas/type_messages:MessageUpdatedAt'
        created_at:
          $ref: '#/components/schemas/type_messages:MessageCreatedAt'
      required:
        - inbox_id
        - thread_id
        - message_id
        - labels
        - timestamp
        - from
        - to
        - size
        - updated_at
        - created_at
    type_threads:ThreadLabels:
      type: array
      items:
        type: string
    type_threads:ThreadTimestamp:
      type: string
      format: date-time
    type_threads:ThreadReceivedTimestamp:
      type: string
      format: date-time
    type_threads:ThreadSentTimestamp:
      type: string
      format: date-time
    type_threads:ThreadSenders:
      type: array
      items:
        type: string
    type_threads:ThreadRecipients:
      type: array
      items:
        type: string
    type_threads:ThreadSubject:
      type: string
    type_threads:ThreadPreview:
      type: string
    type_threads:ThreadAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_threads:ThreadLastMessageId:
      type: string
    type_threads:ThreadMessageCount:
      type: integer
    type_threads:ThreadSize:
      type: integer
    type_threads:ThreadUpdatedAt:
      type: string
      format: date-time
    type_threads:ThreadCreatedAt:
      type: string
      format: date-time
    type_threads:ThreadItem:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        labels:
          $ref: '#/components/schemas/type_threads:ThreadLabels'
        timestamp:
          $ref: '#/components/schemas/type_threads:ThreadTimestamp'
        received_timestamp:
          $ref: '#/components/schemas/type_threads:ThreadReceivedTimestamp'
        sent_timestamp:
          $ref: '#/components/schemas/type_threads:ThreadSentTimestamp'
        senders:
          $ref: '#/components/schemas/type_threads:ThreadSenders'
        recipients:
          $ref: '#/components/schemas/type_threads:ThreadRecipients'
        subject:
          $ref: '#/components/schemas/type_threads:ThreadSubject'
        preview:
          $ref: '#/components/schemas/type_threads:ThreadPreview'
        attachments:
          $ref: '#/components/schemas/type_threads:ThreadAttachments'
        last_message_id:
          $ref: '#/components/schemas/type_threads:ThreadLastMessageId'
        message_count:
          $ref: '#/components/schemas/type_threads:ThreadMessageCount'
        size:
          $ref: '#/components/schemas/type_threads:ThreadSize'
        updated_at:
          $ref: '#/components/schemas/type_threads:ThreadUpdatedAt'
        created_at:
          $ref: '#/components/schemas/type_threads:ThreadCreatedAt'
      required:
        - inbox_id
        - thread_id
        - labels
        - timestamp
        - senders
        - recipients
        - last_message_id
        - message_count
        - size
        - updated_at
        - created_at
    type_events:MessageReceivedEvent:
      type: object
      properties:
        type:
          type: string
          enum:
            - type: stringLiteral
              value: event
        event_type:
          type: string
          enum:
            - type: stringLiteral
              value: message.received
        event_id:
          $ref: '#/components/schemas/type_events:EventId'
        message:
          $ref: '#/components/schemas/type_messages:Message'
        thread:
          $ref: '#/components/schemas/type_threads:ThreadItem'
      required:
        - type
        - event_type
        - event_id
        - message
        - thread
    type_events:Timestamp:
      type: string
      format: date-time
    type_events:Send:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        timestamp:
          $ref: '#/components/schemas/type_events:Timestamp'
        recipients:
          type: array
          items:
            type: string
          description: Sent recipients.
      required:
        - inbox_id
        - thread_id
        - message_id
        - timestamp
        - recipients
    type_events:MessageSentEvent:
      type: object
      properties:
        type:
          type: string
          enum:
            - type: stringLiteral
              value: event
        event_type:
          type: string
          enum:
            - type: stringLiteral
              value: message.sent
        event_id:
          $ref: '#/components/schemas/type_events:EventId'
        send:
          $ref: '#/components/schemas/type_events:Send'
      required:
        - type
        - event_type
        - event_id
        - send
    type_events:Delivery:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        timestamp:
          $ref: '#/components/schemas/type_events:Timestamp'
        recipients:
          type: array
          items:
            type: string
          description: Delivered recipients.
      required:
        - inbox_id
        - thread_id
        - message_id
        - timestamp
        - recipients
    type_events:MessageDeliveredEvent:
      type: object
      properties:
        type:
          type: string
          enum:
            - type: stringLiteral
              value: event
        event_type:
          type: string
          enum:
            - type: stringLiteral
              value: message.delivered
        event_id:
          $ref: '#/components/schemas/type_events:EventId'
        delivery:
          $ref: '#/components/schemas/type_events:Delivery'
      required:
        - type
        - event_type
        - event_id
        - delivery
    type_events:Recipient:
      type: object
      properties:
        address:
          type: string
          description: Recipient address.
        status:
          type: string
          description: Recipient status.
      required:
        - address
        - status
    type_events:Bounce:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        timestamp:
          $ref: '#/components/schemas/type_events:Timestamp'
        type:
          type: string
          description: Bounce type.
        sub_type:
          type: string
          description: Bounce sub-type.
        recipients:
          type: array
          items:
            $ref: '#/components/schemas/type_events:Recipient'
          description: Bounced recipients.
      required:
        - inbox_id
        - thread_id
        - message_id
        - timestamp
        - type
        - sub_type
        - recipients
    type_events:MessageBouncedEvent:
      type: object
      properties:
        type:
          type: string
          enum:
            - type: stringLiteral
              value: event
        event_type:
          type: string
          enum:
            - type: stringLiteral
              value: message.bounced
        event_id:
          $ref: '#/components/schemas/type_events:EventId'
        bounce:
          $ref: '#/components/schemas/type_events:Bounce'
      required:
        - type
        - event_type
        - event_id
        - bounce
    type_events:Complaint:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        timestamp:
          $ref: '#/components/schemas/type_events:Timestamp'
        type:
          type: string
          description: Complaint type.
        sub_type:
          type: string
          description: Complaint sub-type.
        recipients:
          type: array
          items:
            type: string
          description: Complained recipients.
      required:
        - inbox_id
        - thread_id
        - message_id
        - timestamp
        - type
        - sub_type
        - recipients
    type_events:MessageComplainedEvent:
      type: object
      properties:
        type:
          type: string
          enum:
            - type: stringLiteral
              value: event
        event_type:
          type: string
          enum:
            - type: stringLiteral
              value: message.complained
        event_id:
          $ref: '#/components/schemas/type_events:EventId'
        complaint:
          $ref: '#/components/schemas/type_events:Complaint'
      required:
        - type
        - event_type
        - event_id
        - complaint
    type_events:Reject:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        timestamp:
          $ref: '#/components/schemas/type_events:Timestamp'
        reason:
          type: string
          description: Reject reason.
      required:
        - inbox_id
        - thread_id
        - message_id
        - timestamp
        - reason
    type_events:MessageRejectedEvent:
      type: object
      properties:
        type:
          type: string
          enum:
            - type: stringLiteral
              value: event
        event_type:
          type: string
          enum:
            - type: stringLiteral
              value: message.rejected
        event_id:
          $ref: '#/components/schemas/type_events:EventId'
        reject:
          $ref: '#/components/schemas/type_events:Reject'
      required:
        - type
        - event_type
        - event_id
        - reject
    type_pods:PodId:
      type: string
    type_domains:DomainId:
      type: string
    type_domains:VerificationStatus:
      type: string
      enum:
        - value: NOT_STARTED
        - value: PENDING
        - value: INVALID
        - value: FAILED
        - value: VERIFYING
        - value: VERIFIED
    type_domains:FeedbackEnabled:
      type: boolean
    type_domains:RecordType:
      type: string
      enum:
        - value: TXT
        - value: CNAME
        - value: MX
    type_domains:RecordStatus:
      type: string
      enum:
        - value: MISSING
        - value: INVALID
        - value: VALID
    type_domains:VerificationRecord:
      type: object
      properties:
        type:
          $ref: '#/components/schemas/type_domains:RecordType'
          description: The type of the DNS record.
        name:
          type: string
          description: The name or host of the record.
        value:
          type: string
          description: The value of the record.
        status:
          $ref: '#/components/schemas/type_domains:RecordStatus'
          description: The verification status of this specific record.
        priority:
          type: integer
          description: The priority of the MX record.
      required:
        - type
        - name
        - value
        - status
    type_domains:ClientId:
      type: string
    type_domains:Domain:
      type: object
      properties:
        pod_id:
          $ref: '#/components/schemas/type_pods:PodId'
        domain_id:
          $ref: '#/components/schemas/type_domains:DomainId'
        status:
          $ref: '#/components/schemas/type_domains:VerificationStatus'
          description: The verification status of the domain.
        feedback_enabled:
          $ref: '#/components/schemas/type_domains:FeedbackEnabled'
        records:
          type: array
          items:
            $ref: '#/components/schemas/type_domains:VerificationRecord'
          description: A list of DNS records required to verify the domain.
        client_id:
          $ref: '#/components/schemas/type_domains:ClientId'
        updated_at:
          type: string
          format: date-time
          description: Time at which the domain was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which the domain was created.
      required:
        - domain_id
        - status
        - feedback_enabled
        - records
        - updated_at
        - created_at
    type_events:DomainVerifiedEvent:
      type: object
      properties:
        type:
          type: string
          enum:
            - type: stringLiteral
              value: event
        event_type:
          type: string
          enum:
            - type: stringLiteral
              value: domain.verified
        event_id:
          $ref: '#/components/schemas/type_events:EventId'
        domain:
          $ref: '#/components/schemas/type_domains:Domain'
      required:
        - type
        - event_type
        - event_id
        - domain
    type_websockets:Subscribe:
      type: object
      properties:
        type:
          type: string
          enum:
            - type: stringLiteral
              value: subscribe
        event_types:
          $ref: '#/components/schemas/type_events:EventTypes'
        inbox_ids:
          $ref: '#/components/schemas/type_events:InboxIds'
        pod_ids:
          $ref: '#/components/schemas/type_events:PodIds'
      required:
        - type

```

# List Metrics

GET https://api.agentmail.to/v0/metrics

Reference: https://docs.agentmail.to/api-reference/metrics/list

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: List Metrics
  version: endpoint_metrics.list
paths:
  /v0/metrics:
    get:
      operationId: list
      summary: List Metrics
      tags:
        - - subpackage_metrics
      parameters:
        - name: event_types
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_metrics:MetricEventTypes'
        - name: start_timestamp
          in: query
          required: true
          schema:
            $ref: '#/components/schemas/type_metrics:MetricStartTimestamp'
        - name: end_timestamp
          in: query
          required: true
          schema:
            $ref: '#/components/schemas/type_metrics:MetricEndTimestamp'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_metrics:ListMetricsResponse'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_metrics:MetricEventType:
      type: string
      enum:
        - value: message.sent
        - value: message.delivered
        - value: message.bounced
        - value: message.delayed
        - value: message.rejected
        - value: message.complained
        - value: message.received
    type_metrics:MetricEventTypes:
      type: array
      items:
        $ref: '#/components/schemas/type_metrics:MetricEventType'
    type_metrics:MetricStartTimestamp:
      type: string
      format: date-time
    type_metrics:MetricEndTimestamp:
      type: string
      format: date-time
    type_metrics:MetricTimestamp:
      type: string
      format: date-time
    type_metrics:MessageMetrics:
      type: object
      properties:
        sent:
          type: array
          items:
            $ref: '#/components/schemas/type_metrics:MetricTimestamp'
          description: Timestamps when messages were sent.
        delivered:
          type: array
          items:
            $ref: '#/components/schemas/type_metrics:MetricTimestamp'
          description: Timestamps when messages were delivered.
        bounced:
          type: array
          items:
            $ref: '#/components/schemas/type_metrics:MetricTimestamp'
          description: Timestamps when messages bounced.
        delayed:
          type: array
          items:
            $ref: '#/components/schemas/type_metrics:MetricTimestamp'
          description: Timestamps when messages were delayed.
        rejected:
          type: array
          items:
            $ref: '#/components/schemas/type_metrics:MetricTimestamp'
          description: Timestamps when messages were rejected.
        complained:
          type: array
          items:
            $ref: '#/components/schemas/type_metrics:MetricTimestamp'
          description: Timestamps when messages received complaints.
        received:
          type: array
          items:
            $ref: '#/components/schemas/type_metrics:MetricTimestamp'
          description: Timestamps when messages were received.
    type_metrics:ListMetricsResponse:
      type: object
      properties:
        message:
          $ref: '#/components/schemas/type_metrics:MessageMetrics'
          description: Message metrics grouped by event type.

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.metrics.list({
        startTimestamp: new Date("2024-01-15T09:30:00Z"),
        endTimestamp: new Date("2024-01-15T09:30:00Z"),
    });
}
main();

```

```python
from agentmail import AgentMail
from datetime import datetime

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.metrics.list(
    start_timestamp=datetime.fromisoformat("2024-01-15T09:30:00Z"),
    end_timestamp=datetime.fromisoformat("2024-01-15T09:30:00Z")
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/metrics?start_timestamp=2024-01-15T09%3A30%3A00Z&end_timestamp=2024-01-15T09%3A30%3A00Z"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("GET", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/metrics?start_timestamp=2024-01-15T09%3A30%3A00Z&end_timestamp=2024-01-15T09%3A30%3A00Z")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/metrics?start_timestamp=2024-01-15T09%3A30%3A00Z&end_timestamp=2024-01-15T09%3A30%3A00Z")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/metrics?start_timestamp=2024-01-15T09%3A30%3A00Z&end_timestamp=2024-01-15T09%3A30%3A00Z', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/metrics?start_timestamp=2024-01-15T09%3A30%3A00Z&end_timestamp=2024-01-15T09%3A30%3A00Z");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/metrics?start_timestamp=2024-01-15T09%3A30%3A00Z&end_timestamp=2024-01-15T09%3A30%3A00Z")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# List API Keys

GET https://api.agentmail.to/v0/api-keys

Reference: https://docs.agentmail.to/api-reference/api-keys/list

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: List API Keys
  version: endpoint_api-keys.list
paths:
  /v0/api-keys:
    get:
      operationId: list
      summary: List API Keys
      tags:
        - - subpackage_api-keys
      parameters:
        - name: limit
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Limit'
        - name: page_token
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:PageToken'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_api-keys:ListApiKeysResponse'
components:
  schemas:
    type_:Limit:
      type: integer
    type_:PageToken:
      type: string
    type_:Count:
      type: integer
    type_api-keys:ApiKeyId:
      type: string
    type_api-keys:Prefix:
      type: string
    type_api-keys:Name:
      type: string
    type_api-keys:CreatedAt:
      type: string
      format: date-time
    type_api-keys:ApiKey:
      type: object
      properties:
        api_key_id:
          $ref: '#/components/schemas/type_api-keys:ApiKeyId'
        prefix:
          $ref: '#/components/schemas/type_api-keys:Prefix'
        name:
          $ref: '#/components/schemas/type_api-keys:Name'
        used_at:
          type: string
          format: date-time
          description: Time at which api key was last used.
        created_at:
          $ref: '#/components/schemas/type_api-keys:CreatedAt'
      required:
        - api_key_id
        - prefix
        - name
        - created_at
    type_api-keys:ListApiKeysResponse:
      type: object
      properties:
        count:
          $ref: '#/components/schemas/type_:Count'
        next_page_token:
          $ref: '#/components/schemas/type_:PageToken'
        api_keys:
          type: array
          items:
            $ref: '#/components/schemas/type_api-keys:ApiKey'
          description: Ordered by `created_at` descending.
      required:
        - count
        - api_keys

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.apiKeys.list({});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.api_keys.list()

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/api-keys"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("GET", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/api-keys")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/api-keys")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/api-keys', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/api-keys");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/api-keys")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Create API Key

POST https://api.agentmail.to/v0/api-keys
Content-Type: application/json

Reference: https://docs.agentmail.to/api-reference/api-keys/create

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Create API Key
  version: endpoint_api-keys.create
paths:
  /v0/api-keys:
    post:
      operationId: create
      summary: Create API Key
      tags:
        - - subpackage_api-keys
      parameters:
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_api-keys:CreateApiKeyResponse'
        '400':
          description: Error response with status 400
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_api-keys:CreateApiKeyRequest'
components:
  schemas:
    type_api-keys:Name:
      type: string
    type_api-keys:CreateApiKeyRequest:
      type: object
      properties:
        name:
          $ref: '#/components/schemas/type_api-keys:Name'
      required:
        - name
    type_api-keys:ApiKeyId:
      type: string
    type_api-keys:Prefix:
      type: string
    type_api-keys:CreatedAt:
      type: string
      format: date-time
    type_api-keys:CreateApiKeyResponse:
      type: object
      properties:
        api_key_id:
          $ref: '#/components/schemas/type_api-keys:ApiKeyId'
        api_key:
          type: string
          description: API key.
        prefix:
          $ref: '#/components/schemas/type_api-keys:Prefix'
        name:
          $ref: '#/components/schemas/type_api-keys:Name'
        created_at:
          $ref: '#/components/schemas/type_api-keys:CreatedAt'
      required:
        - api_key_id
        - api_key
        - prefix
        - name
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.apiKeys.create({
        name: "name",
    });
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.api_keys.create(
    name="name"
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/api-keys"

	payload := strings.NewReader("{\n  \"name\": \"name\"\n}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/api-keys")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Post.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{\n  \"name\": \"name\"\n}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.post("https://api.agentmail.to/v0/api-keys")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{\n  \"name\": \"name\"\n}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('POST', 'https://api.agentmail.to/v0/api-keys', [
  'body' => '{
  "name": "name"
}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/api-keys");
var request = new RestRequest(Method.POST);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{\n  \"name\": \"name\"\n}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = ["name": "name"] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/api-keys")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Delete API Key

DELETE https://api.agentmail.to/v0/api-keys/{api_key}

Reference: https://docs.agentmail.to/api-reference/api-keys/delete

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Delete API Key
  version: endpoint_api-keys.delete
paths:
  /v0/api-keys/{api_key}:
    delete:
      operationId: delete
      summary: Delete API Key
      tags:
        - - subpackage_api-keys
      parameters:
        - name: api_key
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_api-keys:ApiKeyId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Successful response
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_api-keys:ApiKeyId:
      type: string

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.apiKeys.delete("api_key");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.api_keys.delete(
    api_key="api_key"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/api-keys/api_key"

	req, _ := http.NewRequest("DELETE", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/api-keys/api_key")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Delete.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.delete("https://api.agentmail.to/v0/api-keys/api_key")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('DELETE', 'https://api.agentmail.to/v0/api-keys/api_key', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/api-keys/api_key");
var request = new RestRequest(Method.DELETE);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/api-keys/api_key")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "DELETE"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# List Pods

GET https://api.agentmail.to/v0/pods

Reference: https://docs.agentmail.to/api-reference/pods/list

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: List Pods
  version: endpoint_pods.list
paths:
  /v0/pods:
    get:
      operationId: list
      summary: List Pods
      tags:
        - - subpackage_pods
      parameters:
        - name: limit
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Limit'
        - name: page_token
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:PageToken'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_pods:ListPodsResponse'
components:
  schemas:
    type_:Limit:
      type: integer
    type_:PageToken:
      type: string
    type_:Count:
      type: integer
    type_pods:PodId:
      type: string
    type_pods:Name:
      type: string
    type_pods:ClientId:
      type: string
    type_pods:Pod:
      type: object
      properties:
        pod_id:
          $ref: '#/components/schemas/type_pods:PodId'
        name:
          $ref: '#/components/schemas/type_pods:Name'
        updated_at:
          type: string
          format: date-time
          description: Time at which pod was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which pod was created.
        client_id:
          $ref: '#/components/schemas/type_pods:ClientId'
      required:
        - pod_id
        - name
        - updated_at
        - created_at
    type_pods:ListPodsResponse:
      type: object
      properties:
        count:
          $ref: '#/components/schemas/type_:Count'
        limit:
          $ref: '#/components/schemas/type_:Limit'
        next_page_token:
          $ref: '#/components/schemas/type_:PageToken'
        pods:
          type: array
          items:
            $ref: '#/components/schemas/type_pods:Pod'
          description: Ordered by `created_at` descending.
      required:
        - count
        - pods

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.pods.list({});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.pods.list()

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/pods"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("GET", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/pods")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/pods")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/pods', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/pods");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/pods")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get Pod

GET https://api.agentmail.to/v0/pods/{pod_id}

Reference: https://docs.agentmail.to/api-reference/pods/get

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get Pod
  version: endpoint_pods.get
paths:
  /v0/pods/{pod_id}:
    get:
      operationId: get
      summary: Get Pod
      tags:
        - - subpackage_pods
      parameters:
        - name: pod_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_pods:PodId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_pods:Pod'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_pods:PodId:
      type: string
    type_pods:Name:
      type: string
    type_pods:ClientId:
      type: string
    type_pods:Pod:
      type: object
      properties:
        pod_id:
          $ref: '#/components/schemas/type_pods:PodId'
        name:
          $ref: '#/components/schemas/type_pods:Name'
        updated_at:
          type: string
          format: date-time
          description: Time at which pod was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which pod was created.
        client_id:
          $ref: '#/components/schemas/type_pods:ClientId'
      required:
        - pod_id
        - name
        - updated_at
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.pods.get("pod_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.pods.get(
    pod_id="pod_id"
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/pods/pod_id"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("GET", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/pods/pod_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/pods/pod_id")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/pods/pod_id', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/pods/pod_id");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/pods/pod_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Create Pod

POST https://api.agentmail.to/v0/pods
Content-Type: application/json

Reference: https://docs.agentmail.to/api-reference/pods/create

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Create Pod
  version: endpoint_pods.create
paths:
  /v0/pods:
    post:
      operationId: create
      summary: Create Pod
      tags:
        - - subpackage_pods
      parameters:
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_pods:Pod'
        '400':
          description: Error response with status 400
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_pods:CreatePodRequest'
components:
  schemas:
    type_pods:Name:
      type: string
    type_pods:ClientId:
      type: string
    type_pods:CreatePodRequest:
      type: object
      properties:
        name:
          $ref: '#/components/schemas/type_pods:Name'
        client_id:
          $ref: '#/components/schemas/type_pods:ClientId'
    type_pods:PodId:
      type: string
    type_pods:Pod:
      type: object
      properties:
        pod_id:
          $ref: '#/components/schemas/type_pods:PodId'
        name:
          $ref: '#/components/schemas/type_pods:Name'
        updated_at:
          type: string
          format: date-time
          description: Time at which pod was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which pod was created.
        client_id:
          $ref: '#/components/schemas/type_pods:ClientId'
      required:
        - pod_id
        - name
        - updated_at
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.pods.create({});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.pods.create()

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/pods"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/pods")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Post.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.post("https://api.agentmail.to/v0/pods")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('POST', 'https://api.agentmail.to/v0/pods', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/pods");
var request = new RestRequest(Method.POST);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/pods")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Delete Pod

DELETE https://api.agentmail.to/v0/pods/{pod_id}

Reference: https://docs.agentmail.to/api-reference/pods/delete

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Delete Pod
  version: endpoint_pods.delete
paths:
  /v0/pods/{pod_id}:
    delete:
      operationId: delete
      summary: Delete Pod
      tags:
        - - subpackage_pods
      parameters:
        - name: pod_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_pods:PodId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Successful response
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_pods:PodId:
      type: string

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.pods.delete("pod_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.pods.delete(
    pod_id="pod_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/pods/pod_id"

	req, _ := http.NewRequest("DELETE", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/pods/pod_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Delete.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.delete("https://api.agentmail.to/v0/pods/pod_id")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('DELETE', 'https://api.agentmail.to/v0/pods/pod_id', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/pods/pod_id");
var request = new RestRequest(Method.DELETE);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/pods/pod_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "DELETE"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# List Inboxes

GET https://api.agentmail.to/v0/pods/{pod_id}/inboxes

Reference: https://docs.agentmail.to/api-reference/pods/inboxes/list

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: List Inboxes
  version: endpoint_pods/inboxes.list
paths:
  /v0/pods/{pod_id}/inboxes:
    get:
      operationId: list
      summary: List Inboxes
      tags:
        - - subpackage_pods
          - subpackage_pods/inboxes
      parameters:
        - name: pod_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_pods:PodId'
        - name: limit
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Limit'
        - name: page_token
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:PageToken'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_inboxes:ListInboxesResponse'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_pods:PodId:
      type: string
    type_:Limit:
      type: integer
    type_:PageToken:
      type: string
    type_:Count:
      type: integer
    type_inboxes:InboxId:
      type: string
    type_inboxes:DisplayName:
      type: string
    type_inboxes:ClientId:
      type: string
    type_inboxes:Inbox:
      type: object
      properties:
        pod_id:
          $ref: '#/components/schemas/type_pods:PodId'
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        display_name:
          $ref: '#/components/schemas/type_inboxes:DisplayName'
        client_id:
          $ref: '#/components/schemas/type_inboxes:ClientId'
        updated_at:
          type: string
          format: date-time
          description: Time at which inbox was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which inbox was created.
      required:
        - pod_id
        - inbox_id
        - updated_at
        - created_at
    type_inboxes:ListInboxesResponse:
      type: object
      properties:
        count:
          $ref: '#/components/schemas/type_:Count'
        limit:
          $ref: '#/components/schemas/type_:Limit'
        next_page_token:
          $ref: '#/components/schemas/type_:PageToken'
        inboxes:
          type: array
          items:
            $ref: '#/components/schemas/type_inboxes:Inbox'
          description: Ordered by `created_at` descending.
      required:
        - count
        - inboxes

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.pods.inboxes.list("pod_id", {});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.pods.inboxes.list(
    pod_id="pod_id"
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/pods/pod_id/inboxes"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("GET", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/pods/pod_id/inboxes")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/pods/pod_id/inboxes")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/pods/pod_id/inboxes', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/pods/pod_id/inboxes");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/pods/pod_id/inboxes")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get Inbox

GET https://api.agentmail.to/v0/pods/{pod_id}/inboxes/{inbox_id}

Reference: https://docs.agentmail.to/api-reference/pods/inboxes/get

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get Inbox
  version: endpoint_pods/inboxes.get
paths:
  /v0/pods/{pod_id}/inboxes/{inbox_id}:
    get:
      operationId: get
      summary: Get Inbox
      tags:
        - - subpackage_pods
          - subpackage_pods/inboxes
      parameters:
        - name: pod_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_pods:PodId'
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_inboxes:Inbox'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_pods:PodId:
      type: string
    type_inboxes:InboxId:
      type: string
    type_inboxes:DisplayName:
      type: string
    type_inboxes:ClientId:
      type: string
    type_inboxes:Inbox:
      type: object
      properties:
        pod_id:
          $ref: '#/components/schemas/type_pods:PodId'
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        display_name:
          $ref: '#/components/schemas/type_inboxes:DisplayName'
        client_id:
          $ref: '#/components/schemas/type_inboxes:ClientId'
        updated_at:
          type: string
          format: date-time
          description: Time at which inbox was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which inbox was created.
      required:
        - pod_id
        - inbox_id
        - updated_at
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.pods.inboxes.get("pod_id", "inbox_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.pods.inboxes.get(
    pod_id="pod_id",
    inbox_id="inbox_id"
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/pods/pod_id/inboxes/inbox_id"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("GET", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/pods/pod_id/inboxes/inbox_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/pods/pod_id/inboxes/inbox_id")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/pods/pod_id/inboxes/inbox_id', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/pods/pod_id/inboxes/inbox_id");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/pods/pod_id/inboxes/inbox_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Create Inbox

POST https://api.agentmail.to/v0/pods/{pod_id}/inboxes
Content-Type: application/json

Reference: https://docs.agentmail.to/api-reference/pods/inboxes/create

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Create Inbox
  version: endpoint_pods/inboxes.create
paths:
  /v0/pods/{pod_id}/inboxes:
    post:
      operationId: create
      summary: Create Inbox
      tags:
        - - subpackage_pods
          - subpackage_pods/inboxes
      parameters:
        - name: pod_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_pods:PodId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_inboxes:Inbox'
        '400':
          description: Error response with status 400
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_inboxes:CreateInboxRequest'
components:
  schemas:
    type_pods:PodId:
      type: string
    type_inboxes:DisplayName:
      type: string
    type_inboxes:ClientId:
      type: string
    type_inboxes:CreateInboxRequest:
      type: object
      properties:
        username:
          type: string
          description: Username of address. Randomly generated if not specified.
        domain:
          type: string
          description: >-
            Domain of address. Must be verified domain. Defaults to
            `agentmail.to`.
        display_name:
          $ref: '#/components/schemas/type_inboxes:DisplayName'
        client_id:
          $ref: '#/components/schemas/type_inboxes:ClientId'
    type_inboxes:InboxId:
      type: string
    type_inboxes:Inbox:
      type: object
      properties:
        pod_id:
          $ref: '#/components/schemas/type_pods:PodId'
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        display_name:
          $ref: '#/components/schemas/type_inboxes:DisplayName'
        client_id:
          $ref: '#/components/schemas/type_inboxes:ClientId'
        updated_at:
          type: string
          format: date-time
          description: Time at which inbox was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which inbox was created.
      required:
        - pod_id
        - inbox_id
        - updated_at
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.pods.inboxes.create("pod_id", {});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.pods.inboxes.create(
    pod_id="pod_id"
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/pods/pod_id/inboxes"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/pods/pod_id/inboxes")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Post.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.post("https://api.agentmail.to/v0/pods/pod_id/inboxes")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('POST', 'https://api.agentmail.to/v0/pods/pod_id/inboxes', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/pods/pod_id/inboxes");
var request = new RestRequest(Method.POST);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/pods/pod_id/inboxes")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Delete Inbox

DELETE https://api.agentmail.to/v0/pods/{pod_id}/inboxes/{inbox_id}

Reference: https://docs.agentmail.to/api-reference/pods/inboxes/delete

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Delete Inbox
  version: endpoint_pods/inboxes.delete
paths:
  /v0/pods/{pod_id}/inboxes/{inbox_id}:
    delete:
      operationId: delete
      summary: Delete Inbox
      tags:
        - - subpackage_pods
          - subpackage_pods/inboxes
      parameters:
        - name: pod_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_pods:PodId'
        - name: inbox_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_inboxes:InboxId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Successful response
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_pods:PodId:
      type: string
    type_inboxes:InboxId:
      type: string

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.pods.inboxes.delete("pod_id", "inbox_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.pods.inboxes.delete(
    pod_id="pod_id",
    inbox_id="inbox_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/pods/pod_id/inboxes/inbox_id"

	req, _ := http.NewRequest("DELETE", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/pods/pod_id/inboxes/inbox_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Delete.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.delete("https://api.agentmail.to/v0/pods/pod_id/inboxes/inbox_id")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('DELETE', 'https://api.agentmail.to/v0/pods/pod_id/inboxes/inbox_id', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/pods/pod_id/inboxes/inbox_id");
var request = new RestRequest(Method.DELETE);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/pods/pod_id/inboxes/inbox_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "DELETE"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# List Threads

GET https://api.agentmail.to/v0/pods/{pod_id}/threads

Reference: https://docs.agentmail.to/api-reference/pods/threads/list

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: List Threads
  version: endpoint_pods/threads.list
paths:
  /v0/pods/{pod_id}/threads:
    get:
      operationId: list
      summary: List Threads
      tags:
        - - subpackage_pods
          - subpackage_pods/threads
      parameters:
        - name: pod_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_pods:PodId'
        - name: limit
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Limit'
        - name: page_token
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:PageToken'
        - name: labels
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Labels'
        - name: before
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Before'
        - name: after
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:After'
        - name: ascending
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Ascending'
        - name: include_spam
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:IncludeSpam'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_threads:ListThreadsResponse'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_pods:PodId:
      type: string
    type_:Limit:
      type: integer
    type_:PageToken:
      type: string
    type_:Labels:
      type: array
      items:
        type: string
    type_:Before:
      type: string
      format: date-time
    type_:After:
      type: string
      format: date-time
    type_:Ascending:
      type: boolean
    type_:IncludeSpam:
      type: boolean
    type_:Count:
      type: integer
    type_inboxes:InboxId:
      type: string
    type_threads:ThreadId:
      type: string
    type_threads:ThreadLabels:
      type: array
      items:
        type: string
    type_threads:ThreadTimestamp:
      type: string
      format: date-time
    type_threads:ThreadReceivedTimestamp:
      type: string
      format: date-time
    type_threads:ThreadSentTimestamp:
      type: string
      format: date-time
    type_threads:ThreadSenders:
      type: array
      items:
        type: string
    type_threads:ThreadRecipients:
      type: array
      items:
        type: string
    type_threads:ThreadSubject:
      type: string
    type_threads:ThreadPreview:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:Attachment:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
      required:
        - attachment_id
        - size
    type_threads:ThreadAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_threads:ThreadLastMessageId:
      type: string
    type_threads:ThreadMessageCount:
      type: integer
    type_threads:ThreadSize:
      type: integer
    type_threads:ThreadUpdatedAt:
      type: string
      format: date-time
    type_threads:ThreadCreatedAt:
      type: string
      format: date-time
    type_threads:ThreadItem:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        labels:
          $ref: '#/components/schemas/type_threads:ThreadLabels'
        timestamp:
          $ref: '#/components/schemas/type_threads:ThreadTimestamp'
        received_timestamp:
          $ref: '#/components/schemas/type_threads:ThreadReceivedTimestamp'
        sent_timestamp:
          $ref: '#/components/schemas/type_threads:ThreadSentTimestamp'
        senders:
          $ref: '#/components/schemas/type_threads:ThreadSenders'
        recipients:
          $ref: '#/components/schemas/type_threads:ThreadRecipients'
        subject:
          $ref: '#/components/schemas/type_threads:ThreadSubject'
        preview:
          $ref: '#/components/schemas/type_threads:ThreadPreview'
        attachments:
          $ref: '#/components/schemas/type_threads:ThreadAttachments'
        last_message_id:
          $ref: '#/components/schemas/type_threads:ThreadLastMessageId'
        message_count:
          $ref: '#/components/schemas/type_threads:ThreadMessageCount'
        size:
          $ref: '#/components/schemas/type_threads:ThreadSize'
        updated_at:
          $ref: '#/components/schemas/type_threads:ThreadUpdatedAt'
        created_at:
          $ref: '#/components/schemas/type_threads:ThreadCreatedAt'
      required:
        - inbox_id
        - thread_id
        - labels
        - timestamp
        - senders
        - recipients
        - last_message_id
        - message_count
        - size
        - updated_at
        - created_at
    type_threads:ListThreadsResponse:
      type: object
      properties:
        count:
          $ref: '#/components/schemas/type_:Count'
        limit:
          $ref: '#/components/schemas/type_:Limit'
        next_page_token:
          $ref: '#/components/schemas/type_:PageToken'
        threads:
          type: array
          items:
            $ref: '#/components/schemas/type_threads:ThreadItem'
          description: Ordered by `timestamp` descending.
      required:
        - count
        - threads

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.pods.threads.list("pod_id", {});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.pods.threads.list(
    pod_id="pod_id"
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/pods/pod_id/threads"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("GET", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/pods/pod_id/threads")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/pods/pod_id/threads")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/pods/pod_id/threads', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/pods/pod_id/threads");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/pods/pod_id/threads")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get Thread

GET https://api.agentmail.to/v0/pods/{pod_id}/threads/{thread_id}

Reference: https://docs.agentmail.to/api-reference/pods/threads/get

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get Thread
  version: endpoint_pods/threads.get
paths:
  /v0/pods/{pod_id}/threads/{thread_id}:
    get:
      operationId: get
      summary: Get Thread
      tags:
        - - subpackage_pods
          - subpackage_pods/threads
      parameters:
        - name: pod_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_pods:PodId'
        - name: thread_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_threads:ThreadId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_threads:Thread'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_pods:PodId:
      type: string
    type_threads:ThreadId:
      type: string
    type_inboxes:InboxId:
      type: string
    type_threads:ThreadLabels:
      type: array
      items:
        type: string
    type_threads:ThreadTimestamp:
      type: string
      format: date-time
    type_threads:ThreadReceivedTimestamp:
      type: string
      format: date-time
    type_threads:ThreadSentTimestamp:
      type: string
      format: date-time
    type_threads:ThreadSenders:
      type: array
      items:
        type: string
    type_threads:ThreadRecipients:
      type: array
      items:
        type: string
    type_threads:ThreadSubject:
      type: string
    type_threads:ThreadPreview:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:Attachment:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
      required:
        - attachment_id
        - size
    type_threads:ThreadAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_threads:ThreadLastMessageId:
      type: string
    type_threads:ThreadMessageCount:
      type: integer
    type_threads:ThreadSize:
      type: integer
    type_threads:ThreadUpdatedAt:
      type: string
      format: date-time
    type_threads:ThreadCreatedAt:
      type: string
      format: date-time
    type_messages:MessageId:
      type: string
    type_messages:MessageLabels:
      type: array
      items:
        type: string
    type_messages:MessageTimestamp:
      type: string
      format: date-time
    type_messages:MessageFrom:
      type: string
    type_messages:MessageTo:
      type: array
      items:
        type: string
    type_messages:MessageCc:
      type: array
      items:
        type: string
    type_messages:MessageBcc:
      type: array
      items:
        type: string
    type_messages:MessageSubject:
      type: string
    type_messages:MessagePreview:
      type: string
    type_messages:MessageText:
      type: string
    type_messages:MessageHtml:
      type: string
    type_messages:MessageAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_messages:MessageInReplyTo:
      type: string
    type_messages:MessageReferences:
      type: array
      items:
        type: string
    type_messages:MessageHeaders:
      type: object
      additionalProperties:
        type: string
    type_messages:MessageSize:
      type: integer
    type_messages:MessageUpdatedAt:
      type: string
      format: date-time
    type_messages:MessageCreatedAt:
      type: string
      format: date-time
    type_messages:Message:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        message_id:
          $ref: '#/components/schemas/type_messages:MessageId'
        labels:
          $ref: '#/components/schemas/type_messages:MessageLabels'
        timestamp:
          $ref: '#/components/schemas/type_messages:MessageTimestamp'
        from:
          $ref: '#/components/schemas/type_messages:MessageFrom'
        reply_to:
          type: array
          items:
            type: string
          description: >-
            Reply-to addresses. In format `username@domain.com` or `Display Name
            <username@domain.com>`.
        to:
          $ref: '#/components/schemas/type_messages:MessageTo'
        cc:
          $ref: '#/components/schemas/type_messages:MessageCc'
        bcc:
          $ref: '#/components/schemas/type_messages:MessageBcc'
        subject:
          $ref: '#/components/schemas/type_messages:MessageSubject'
        preview:
          $ref: '#/components/schemas/type_messages:MessagePreview'
        text:
          $ref: '#/components/schemas/type_messages:MessageText'
        html:
          $ref: '#/components/schemas/type_messages:MessageHtml'
        extracted_text:
          type: string
          description: Extracted new text content.
        extracted_html:
          type: string
          description: Extracted new HTML content.
        attachments:
          $ref: '#/components/schemas/type_messages:MessageAttachments'
        in_reply_to:
          $ref: '#/components/schemas/type_messages:MessageInReplyTo'
        references:
          $ref: '#/components/schemas/type_messages:MessageReferences'
        headers:
          $ref: '#/components/schemas/type_messages:MessageHeaders'
        size:
          $ref: '#/components/schemas/type_messages:MessageSize'
        updated_at:
          $ref: '#/components/schemas/type_messages:MessageUpdatedAt'
        created_at:
          $ref: '#/components/schemas/type_messages:MessageCreatedAt'
      required:
        - inbox_id
        - thread_id
        - message_id
        - labels
        - timestamp
        - from
        - to
        - size
        - updated_at
        - created_at
    type_threads:Thread:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        labels:
          $ref: '#/components/schemas/type_threads:ThreadLabels'
        timestamp:
          $ref: '#/components/schemas/type_threads:ThreadTimestamp'
        received_timestamp:
          $ref: '#/components/schemas/type_threads:ThreadReceivedTimestamp'
        sent_timestamp:
          $ref: '#/components/schemas/type_threads:ThreadSentTimestamp'
        senders:
          $ref: '#/components/schemas/type_threads:ThreadSenders'
        recipients:
          $ref: '#/components/schemas/type_threads:ThreadRecipients'
        subject:
          $ref: '#/components/schemas/type_threads:ThreadSubject'
        preview:
          $ref: '#/components/schemas/type_threads:ThreadPreview'
        attachments:
          $ref: '#/components/schemas/type_threads:ThreadAttachments'
        last_message_id:
          $ref: '#/components/schemas/type_threads:ThreadLastMessageId'
        message_count:
          $ref: '#/components/schemas/type_threads:ThreadMessageCount'
        size:
          $ref: '#/components/schemas/type_threads:ThreadSize'
        updated_at:
          $ref: '#/components/schemas/type_threads:ThreadUpdatedAt'
        created_at:
          $ref: '#/components/schemas/type_threads:ThreadCreatedAt'
        messages:
          type: array
          items:
            $ref: '#/components/schemas/type_messages:Message'
          description: Messages in thread. Ordered by `timestamp` ascending.
      required:
        - inbox_id
        - thread_id
        - labels
        - timestamp
        - senders
        - recipients
        - last_message_id
        - message_count
        - size
        - updated_at
        - created_at
        - messages

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.pods.threads.get("pod_id", "thread_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.pods.threads.get(
    pod_id="pod_id",
    thread_id="thread_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/pods/pod_id/threads/thread_id"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/pods/pod_id/threads/thread_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/pods/pod_id/threads/thread_id")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/pods/pod_id/threads/thread_id', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/pods/pod_id/threads/thread_id");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/pods/pod_id/threads/thread_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get Attachment

GET https://api.agentmail.to/v0/pods/{pod_id}/threads/{thread_id}/attachments/{attachment_id}

Reference: https://docs.agentmail.to/api-reference/pods/threads/get-attachment

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get Attachment
  version: endpoint_pods/threads.getAttachment
paths:
  /v0/pods/{pod_id}/threads/{thread_id}/attachments/{attachment_id}:
    get:
      operationId: get-attachment
      summary: Get Attachment
      tags:
        - - subpackage_pods
          - subpackage_pods/threads
      parameters:
        - name: pod_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_pods:PodId'
        - name: thread_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_threads:ThreadId'
        - name: attachment_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_attachments:AttachmentId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_attachments:AttachmentResponse'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_pods:PodId:
      type: string
    type_threads:ThreadId:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:AttachmentResponse:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
        download_url:
          type: string
          description: URL to download the attachment.
        expires_at:
          type: string
          format: date-time
          description: Time at which the download URL expires.
      required:
        - attachment_id
        - size
        - download_url
        - expires_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.pods.threads.getAttachment("pod_id", "thread_id", "attachment_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.pods.threads.get_attachment(
    pod_id="pod_id",
    thread_id="thread_id",
    attachment_id="attachment_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/pods/pod_id/threads/thread_id/attachments/attachment_id"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/pods/pod_id/threads/thread_id/attachments/attachment_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/pods/pod_id/threads/thread_id/attachments/attachment_id")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/pods/pod_id/threads/thread_id/attachments/attachment_id', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/pods/pod_id/threads/thread_id/attachments/attachment_id");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/pods/pod_id/threads/thread_id/attachments/attachment_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# List Drafts

GET https://api.agentmail.to/v0/pods/{pod_id}/drafts

Reference: https://docs.agentmail.to/api-reference/pods/drafts/list

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: List Drafts
  version: endpoint_pods/drafts.list
paths:
  /v0/pods/{pod_id}/drafts:
    get:
      operationId: list
      summary: List Drafts
      tags:
        - - subpackage_pods
          - subpackage_pods/drafts
      parameters:
        - name: pod_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_pods:PodId'
        - name: limit
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Limit'
        - name: page_token
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:PageToken'
        - name: labels
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Labels'
        - name: before
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Before'
        - name: after
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:After'
        - name: ascending
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Ascending'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_drafts:ListDraftsResponse'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_pods:PodId:
      type: string
    type_:Limit:
      type: integer
    type_:PageToken:
      type: string
    type_:Labels:
      type: array
      items:
        type: string
    type_:Before:
      type: string
      format: date-time
    type_:After:
      type: string
      format: date-time
    type_:Ascending:
      type: boolean
    type_:Count:
      type: integer
    type_inboxes:InboxId:
      type: string
    type_threads:ThreadId:
      type: string
    type_drafts:DraftId:
      type: string
    type_drafts:DraftLabels:
      type: array
      items:
        type: string
    type_drafts:DraftTo:
      type: array
      items:
        type: string
    type_drafts:DraftCc:
      type: array
      items:
        type: string
    type_drafts:DraftBcc:
      type: array
      items:
        type: string
    type_drafts:DraftSubject:
      type: string
    type_drafts:DraftPreview:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:Attachment:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
      required:
        - attachment_id
        - size
    type_drafts:DraftAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_drafts:DraftSendStatus:
      type: string
      enum:
        - value: scheduled
        - value: sending
        - value: failed
    type_drafts:DraftSendAt:
      type: string
      format: date-time
    type_drafts:DraftUpdatedAt:
      type: string
      format: date-time
    type_drafts:DraftItem:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        draft_id:
          $ref: '#/components/schemas/type_drafts:DraftId'
        labels:
          $ref: '#/components/schemas/type_drafts:DraftLabels'
        to:
          $ref: '#/components/schemas/type_drafts:DraftTo'
        cc:
          $ref: '#/components/schemas/type_drafts:DraftCc'
        bcc:
          $ref: '#/components/schemas/type_drafts:DraftBcc'
        subject:
          $ref: '#/components/schemas/type_drafts:DraftSubject'
        preview:
          $ref: '#/components/schemas/type_drafts:DraftPreview'
        attachments:
          $ref: '#/components/schemas/type_drafts:DraftAttachments'
        send_status:
          $ref: '#/components/schemas/type_drafts:DraftSendStatus'
        send_at:
          $ref: '#/components/schemas/type_drafts:DraftSendAt'
        updated_at:
          $ref: '#/components/schemas/type_drafts:DraftUpdatedAt'
      required:
        - inbox_id
        - thread_id
        - draft_id
        - labels
        - updated_at
    type_drafts:ListDraftsResponse:
      type: object
      properties:
        count:
          $ref: '#/components/schemas/type_:Count'
        limit:
          $ref: '#/components/schemas/type_:Limit'
        next_page_token:
          $ref: '#/components/schemas/type_:PageToken'
        drafts:
          type: array
          items:
            $ref: '#/components/schemas/type_drafts:DraftItem'
          description: Ordered by `updated_at` descending.
      required:
        - count
        - drafts

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.pods.drafts.list("pod_id", {});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.pods.drafts.list(
    pod_id="pod_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/pods/pod_id/drafts"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/pods/pod_id/drafts")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/pods/pod_id/drafts")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/pods/pod_id/drafts', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/pods/pod_id/drafts");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/pods/pod_id/drafts")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get Draft

GET https://api.agentmail.to/v0/pods/{pod_id}/drafts/{draft_id}

Reference: https://docs.agentmail.to/api-reference/pods/drafts/get

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get Draft
  version: endpoint_pods/drafts.get
paths:
  /v0/pods/{pod_id}/drafts/{draft_id}:
    get:
      operationId: get
      summary: Get Draft
      tags:
        - - subpackage_pods
          - subpackage_pods/drafts
      parameters:
        - name: pod_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_pods:PodId'
        - name: draft_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_drafts:DraftId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_drafts:Draft'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_pods:PodId:
      type: string
    type_drafts:DraftId:
      type: string
    type_inboxes:InboxId:
      type: string
    type_threads:ThreadId:
      type: string
    type_drafts:DraftClientId:
      type: string
    type_drafts:DraftLabels:
      type: array
      items:
        type: string
    type_drafts:DraftReplyTo:
      type: array
      items:
        type: string
    type_drafts:DraftTo:
      type: array
      items:
        type: string
    type_drafts:DraftCc:
      type: array
      items:
        type: string
    type_drafts:DraftBcc:
      type: array
      items:
        type: string
    type_drafts:DraftSubject:
      type: string
    type_drafts:DraftPreview:
      type: string
    type_drafts:DraftText:
      type: string
    type_drafts:DraftHtml:
      type: string
    type_attachments:AttachmentId:
      type: string
    type_attachments:AttachmentFilename:
      type: string
    type_attachments:AttachmentSize:
      type: integer
    type_attachments:AttachmentContentType:
      type: string
    type_attachments:AttachmentContentDisposition:
      type: string
      enum:
        - value: inline
        - value: attachment
    type_attachments:AttachmentContentId:
      type: string
    type_attachments:Attachment:
      type: object
      properties:
        attachment_id:
          $ref: '#/components/schemas/type_attachments:AttachmentId'
        filename:
          $ref: '#/components/schemas/type_attachments:AttachmentFilename'
        size:
          $ref: '#/components/schemas/type_attachments:AttachmentSize'
        content_type:
          $ref: '#/components/schemas/type_attachments:AttachmentContentType'
        content_disposition:
          $ref: '#/components/schemas/type_attachments:AttachmentContentDisposition'
        content_id:
          $ref: '#/components/schemas/type_attachments:AttachmentContentId'
      required:
        - attachment_id
        - size
    type_drafts:DraftAttachments:
      type: array
      items:
        $ref: '#/components/schemas/type_attachments:Attachment'
    type_drafts:DraftInReplyTo:
      type: string
    type_drafts:DraftSendStatus:
      type: string
      enum:
        - value: scheduled
        - value: sending
        - value: failed
    type_drafts:DraftSendAt:
      type: string
      format: date-time
    type_drafts:DraftUpdatedAt:
      type: string
      format: date-time
    type_drafts:Draft:
      type: object
      properties:
        inbox_id:
          $ref: '#/components/schemas/type_inboxes:InboxId'
        thread_id:
          $ref: '#/components/schemas/type_threads:ThreadId'
        draft_id:
          $ref: '#/components/schemas/type_drafts:DraftId'
        client_id:
          $ref: '#/components/schemas/type_drafts:DraftClientId'
        labels:
          $ref: '#/components/schemas/type_drafts:DraftLabels'
        reply_to:
          $ref: '#/components/schemas/type_drafts:DraftReplyTo'
        to:
          $ref: '#/components/schemas/type_drafts:DraftTo'
        cc:
          $ref: '#/components/schemas/type_drafts:DraftCc'
        bcc:
          $ref: '#/components/schemas/type_drafts:DraftBcc'
        subject:
          $ref: '#/components/schemas/type_drafts:DraftSubject'
        preview:
          $ref: '#/components/schemas/type_drafts:DraftPreview'
        text:
          $ref: '#/components/schemas/type_drafts:DraftText'
        html:
          $ref: '#/components/schemas/type_drafts:DraftHtml'
        attachments:
          $ref: '#/components/schemas/type_drafts:DraftAttachments'
        in_reply_to:
          $ref: '#/components/schemas/type_drafts:DraftInReplyTo'
        references:
          type: array
          items:
            type: string
          description: IDs of previous messages in thread.
        send_status:
          $ref: '#/components/schemas/type_drafts:DraftSendStatus'
        send_at:
          $ref: '#/components/schemas/type_drafts:DraftSendAt'
        updated_at:
          $ref: '#/components/schemas/type_drafts:DraftUpdatedAt'
        created_at:
          type: string
          format: date-time
          description: Time at which draft was created.
      required:
        - inbox_id
        - thread_id
        - draft_id
        - labels
        - updated_at
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.pods.drafts.get("pod_id", "draft_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.pods.drafts.get(
    pod_id="pod_id",
    draft_id="draft_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/pods/pod_id/drafts/draft_id"

	req, _ := http.NewRequest("GET", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/pods/pod_id/drafts/draft_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/pods/pod_id/drafts/draft_id")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/pods/pod_id/drafts/draft_id', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/pods/pod_id/drafts/draft_id");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/pods/pod_id/drafts/draft_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# List Domains

GET https://api.agentmail.to/v0/pods/{pod_id}/domains

Reference: https://docs.agentmail.to/api-reference/pods/domains/list

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: List Domains
  version: endpoint_pods/domains.list
paths:
  /v0/pods/{pod_id}/domains:
    get:
      operationId: list
      summary: List Domains
      tags:
        - - subpackage_pods
          - subpackage_pods/domains
      parameters:
        - name: pod_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_pods:PodId'
        - name: limit
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:Limit'
        - name: page_token
          in: query
          required: false
          schema:
            $ref: '#/components/schemas/type_:PageToken'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_domains:ListDomainsResponse'
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_pods:PodId:
      type: string
    type_:Limit:
      type: integer
    type_:PageToken:
      type: string
    type_:Count:
      type: integer
    type_domains:DomainId:
      type: string
    type_domains:FeedbackEnabled:
      type: boolean
    type_domains:ClientId:
      type: string
    type_domains:DomainItem:
      type: object
      properties:
        pod_id:
          $ref: '#/components/schemas/type_pods:PodId'
        domain_id:
          $ref: '#/components/schemas/type_domains:DomainId'
        feedback_enabled:
          $ref: '#/components/schemas/type_domains:FeedbackEnabled'
        client_id:
          $ref: '#/components/schemas/type_domains:ClientId'
        updated_at:
          type: string
          format: date-time
          description: Time at which the domain was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which the domain was created.
      required:
        - domain_id
        - feedback_enabled
        - updated_at
        - created_at
    type_domains:ListDomainsResponse:
      type: object
      properties:
        count:
          $ref: '#/components/schemas/type_:Count'
        limit:
          $ref: '#/components/schemas/type_:Limit'
        next_page_token:
          $ref: '#/components/schemas/type_:PageToken'
        domains:
          type: array
          items:
            $ref: '#/components/schemas/type_domains:DomainItem'
          description: Ordered by `created_at` descending.
      required:
        - count
        - domains

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.pods.domains.list("pod_id", {});
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.pods.domains.list(
    pod_id="pod_id"
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/pods/pod_id/domains"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("GET", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/pods/pod_id/domains")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/pods/pod_id/domains")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/pods/pod_id/domains', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/pods/pod_id/domains");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/pods/pod_id/domains")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Create Domain

POST https://api.agentmail.to/v0/pods/{pod_id}/domains
Content-Type: application/json

Reference: https://docs.agentmail.to/api-reference/pods/domains/create

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Create Domain
  version: endpoint_pods/domains.create
paths:
  /v0/pods/{pod_id}/domains:
    post:
      operationId: create
      summary: Create Domain
      tags:
        - - subpackage_pods
          - subpackage_pods/domains
      parameters:
        - name: pod_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_pods:PodId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_domains:Domain'
        '400':
          description: Error response with status 400
          content: {}
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/type_domains:CreateDomainRequest'
components:
  schemas:
    type_pods:PodId:
      type: string
    type_domains:DomainName:
      type: string
    type_domains:FeedbackEnabled:
      type: boolean
    type_domains:CreateDomainRequest:
      type: object
      properties:
        domain:
          $ref: '#/components/schemas/type_domains:DomainName'
        feedback_enabled:
          $ref: '#/components/schemas/type_domains:FeedbackEnabled'
      required:
        - domain
        - feedback_enabled
    type_domains:DomainId:
      type: string
    type_domains:VerificationStatus:
      type: string
      enum:
        - value: NOT_STARTED
        - value: PENDING
        - value: INVALID
        - value: FAILED
        - value: VERIFYING
        - value: VERIFIED
    type_domains:RecordType:
      type: string
      enum:
        - value: TXT
        - value: CNAME
        - value: MX
    type_domains:RecordStatus:
      type: string
      enum:
        - value: MISSING
        - value: INVALID
        - value: VALID
    type_domains:VerificationRecord:
      type: object
      properties:
        type:
          $ref: '#/components/schemas/type_domains:RecordType'
          description: The type of the DNS record.
        name:
          type: string
          description: The name or host of the record.
        value:
          type: string
          description: The value of the record.
        status:
          $ref: '#/components/schemas/type_domains:RecordStatus'
          description: The verification status of this specific record.
        priority:
          type: integer
          description: The priority of the MX record.
      required:
        - type
        - name
        - value
        - status
    type_domains:ClientId:
      type: string
    type_domains:Domain:
      type: object
      properties:
        pod_id:
          $ref: '#/components/schemas/type_pods:PodId'
        domain_id:
          $ref: '#/components/schemas/type_domains:DomainId'
        status:
          $ref: '#/components/schemas/type_domains:VerificationStatus'
          description: The verification status of the domain.
        feedback_enabled:
          $ref: '#/components/schemas/type_domains:FeedbackEnabled'
        records:
          type: array
          items:
            $ref: '#/components/schemas/type_domains:VerificationRecord'
          description: A list of DNS records required to verify the domain.
        client_id:
          $ref: '#/components/schemas/type_domains:ClientId'
        updated_at:
          type: string
          format: date-time
          description: Time at which the domain was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which the domain was created.
      required:
        - domain_id
        - status
        - feedback_enabled
        - records
        - updated_at
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.pods.domains.create("pod_id", {
        domain: "example.com",
        feedbackEnabled: true,
    });
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.pods.domains.create(
    pod_id="pod_id",
    domain="example.com",
    feedback_enabled=True
)

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/pods/pod_id/domains"

	payload := strings.NewReader("{\n  \"domain\": \"example.com\",\n  \"feedback_enabled\": true\n}")

	req, _ := http.NewRequest("POST", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/pods/pod_id/domains")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Post.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{\n  \"domain\": \"example.com\",\n  \"feedback_enabled\": true\n}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.post("https://api.agentmail.to/v0/pods/pod_id/domains")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{\n  \"domain\": \"example.com\",\n  \"feedback_enabled\": true\n}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('POST', 'https://api.agentmail.to/v0/pods/pod_id/domains', [
  'body' => '{
  "domain": "example.com",
  "feedback_enabled": true
}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/pods/pod_id/domains");
var request = new RestRequest(Method.POST);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{\n  \"domain\": \"example.com\",\n  \"feedback_enabled\": true\n}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [
  "domain": "example.com",
  "feedback_enabled": true
] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/pods/pod_id/domains")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "POST"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Delete Domain

DELETE https://api.agentmail.to/v0/pods/{pod_id}/domains/{domain_id}

Reference: https://docs.agentmail.to/api-reference/pods/domains/delete

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Delete Domain
  version: endpoint_pods/domains.delete
paths:
  /v0/pods/{pod_id}/domains/{domain_id}:
    delete:
      operationId: delete
      summary: Delete Domain
      tags:
        - - subpackage_pods
          - subpackage_pods/domains
      parameters:
        - name: pod_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_pods:PodId'
        - name: domain_id
          in: path
          required: true
          schema:
            $ref: '#/components/schemas/type_domains:DomainId'
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Successful response
        '404':
          description: Error response with status 404
          content: {}
components:
  schemas:
    type_pods:PodId:
      type: string
    type_domains:DomainId:
      type: string

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.pods.domains.delete("pod_id", "domain_id");
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.pods.domains.delete(
    pod_id="pod_id",
    domain_id="domain_id"
)

```

```go
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/pods/pod_id/domains/domain_id"

	req, _ := http.NewRequest("DELETE", url, nil)

	req.Header.Add("Authorization", "Bearer <api_key>")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/pods/pod_id/domains/domain_id")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Delete.new(url)
request["Authorization"] = 'Bearer <api_key>'

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.delete("https://api.agentmail.to/v0/pods/pod_id/domains/domain_id")
  .header("Authorization", "Bearer <api_key>")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('DELETE', 'https://api.agentmail.to/v0/pods/pod_id/domains/domain_id', [
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/pods/pod_id/domains/domain_id");
var request = new RestRequest(Method.DELETE);
request.AddHeader("Authorization", "Bearer <api_key>");
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = ["Authorization": "Bearer <api_key>"]

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/pods/pod_id/domains/domain_id")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "DELETE"
request.allHTTPHeaderFields = headers

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

# Get Organization

GET https://api.agentmail.to/v0/organizations

Get the current organization.

Reference: https://docs.agentmail.to/api-reference/organizations/get

## OpenAPI Specification

```yaml
openapi: 3.1.1
info:
  title: Get Organization
  version: endpoint_organizations.get
paths:
  /v0/organizations:
    get:
      operationId: get
      summary: Get Organization
      description: Get the current organization.
      tags:
        - - subpackage_organizations
      parameters:
        - name: Authorization
          in: header
          description: >-
            Bearer authentication of the form `Bearer <token>`, where token is
            your auth token.
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Response with status 200
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/type_organizations:Organization'
components:
  schemas:
    type_:OrganizationId:
      type: string
    type_organizations:Organization:
      type: object
      properties:
        organization_id:
          $ref: '#/components/schemas/type_:OrganizationId'
        inbox_count:
          type: integer
          description: Current number of inboxes.
        domain_count:
          type: integer
          description: Current number of domains.
        inbox_limit:
          type: integer
          description: Maximum number of inboxes allowed.
        domain_limit:
          type: integer
          description: Maximum number of domains allowed.
        updated_at:
          type: string
          format: date-time
          description: Time at which organization was last updated.
        created_at:
          type: string
          format: date-time
          description: Time at which organization was created.
      required:
        - organization_id
        - inbox_count
        - domain_count
        - updated_at
        - created_at

```

## SDK Code Examples

```typescript
import { AgentMailClient } from "agentmail";

async function main() {
    const client = new AgentMailClient({
        environment: "https://api.agentmail.to",
        apiKey: "YOUR_TOKEN_HERE",
    });
    await client.organizations.get();
}
main();

```

```python
from agentmail import AgentMail

client = AgentMail(
    base_url="https://api.agentmail.to",
    api_key="YOUR_TOKEN_HERE"
)

client.organizations.get()

```

```go
package main

import (
	"fmt"
	"strings"
	"net/http"
	"io"
)

func main() {

	url := "https://api.agentmail.to/v0/organizations"

	payload := strings.NewReader("{}")

	req, _ := http.NewRequest("GET", url, payload)

	req.Header.Add("Authorization", "Bearer <api_key>")
	req.Header.Add("Content-Type", "application/json")

	res, _ := http.DefaultClient.Do(req)

	defer res.Body.Close()
	body, _ := io.ReadAll(res.Body)

	fmt.Println(res)
	fmt.Println(string(body))

}
```

```ruby
require 'uri'
require 'net/http'

url = URI("https://api.agentmail.to/v0/organizations")

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = true

request = Net::HTTP::Get.new(url)
request["Authorization"] = 'Bearer <api_key>'
request["Content-Type"] = 'application/json'
request.body = "{}"

response = http.request(request)
puts response.read_body
```

```java
HttpResponse<String> response = Unirest.get("https://api.agentmail.to/v0/organizations")
  .header("Authorization", "Bearer <api_key>")
  .header("Content-Type", "application/json")
  .body("{}")
  .asString();
```

```php
<?php

$client = new \GuzzleHttp\Client();

$response = $client->request('GET', 'https://api.agentmail.to/v0/organizations', [
  'body' => '{}',
  'headers' => [
    'Authorization' => 'Bearer <api_key>',
    'Content-Type' => 'application/json',
  ],
]);

echo $response->getBody();
```

```csharp
var client = new RestClient("https://api.agentmail.to/v0/organizations");
var request = new RestRequest(Method.GET);
request.AddHeader("Authorization", "Bearer <api_key>");
request.AddHeader("Content-Type", "application/json");
request.AddParameter("application/json", "{}", ParameterType.RequestBody);
IRestResponse response = client.Execute(request);
```

```swift
import Foundation

let headers = [
  "Authorization": "Bearer <api_key>",
  "Content-Type": "application/json"
]
let parameters = [] as [String : Any]

let postData = JSONSerialization.data(withJSONObject: parameters, options: [])

let request = NSMutableURLRequest(url: NSURL(string: "https://api.agentmail.to/v0/organizations")! as URL,
                                        cachePolicy: .useProtocolCachePolicy,
                                    timeoutInterval: 10.0)
request.httpMethod = "GET"
request.allHTTPHeaderFields = headers
request.httpBody = postData as Data

let session = URLSession.shared
let dataTask = session.dataTask(with: request as URLRequest, completionHandler: { (data, response, error) -> Void in
  if (error != nil) {
    print(error as Any)
  } else {
    let httpResponse = response as? HTTPURLResponse
    print(httpResponse)
  }
})

dataTask.resume()
```

