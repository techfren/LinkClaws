// src/toolkit.ts
import { AgentMailClient } from "agentmail";

// src/schemas.ts
import { z } from "zod";
var InboxIdSchema = z.string().describe("ID of inbox");
var ThreadIdSchema = z.string().describe("ID of thread");
var MessageIdSchema = z.string().describe("ID of message");
var AttachmentIdSchema = z.string().describe("ID of attachment");
var ListItemsParams = z.object({
  limit: z.number().optional().default(10).describe("Max number of items to return"),
  pageToken: z.string().optional().describe("Page token for pagination")
});
var GetInboxParams = z.object({
  inboxId: InboxIdSchema
});
var CreateInboxParams = z.object({
  username: z.string().optional().describe("Username"),
  domain: z.string().optional().describe("Domain"),
  displayName: z.string().optional().describe("Display name")
});
var ListInboxItemsParams = ListItemsParams.extend({
  inboxId: InboxIdSchema,
  labels: z.array(z.string()).optional().describe("Labels to filter items by"),
  before: z.string().pipe(z.coerce.date()).optional().describe("Filter items before datetime"),
  after: z.string().pipe(z.coerce.date()).optional().describe("Filter items after datetime")
});
var GetThreadParams = z.object({
  inboxId: InboxIdSchema,
  threadId: ThreadIdSchema
});
var GetAttachmentParams = z.object({
  inboxId: InboxIdSchema,
  threadId: ThreadIdSchema,
  attachmentId: AttachmentIdSchema
});
var BaseMessageParams = z.object({
  inboxId: InboxIdSchema,
  text: z.string().optional().describe("Plain text body"),
  html: z.string().optional().describe("HTML body"),
  labels: z.array(z.string()).optional().describe("Labels")
});
var SendMessageParams = BaseMessageParams.extend({
  to: z.array(z.string()).describe("Recipients"),
  cc: z.array(z.string()).optional().describe("CC recipients"),
  bcc: z.array(z.string()).optional().describe("BCC recipients"),
  subject: z.string().optional().describe("Subject")
});
var ReplyToMessageParams = BaseMessageParams.extend({
  messageId: MessageIdSchema,
  replyAll: z.boolean().optional().describe("Reply to all recipients")
});
var UpdateMessageParams = z.object({
  inboxId: InboxIdSchema,
  messageId: MessageIdSchema,
  addLabels: z.array(z.string()).optional().describe("Labels to add"),
  removeLabels: z.array(z.string()).optional().describe("Labels to remove")
});

// src/functions.ts
import { extractText, getDocumentProxy } from "unpdf";
import JSZip from "jszip";
function detectFileType(bytes) {
  if (bytes[0] === 37 && bytes[1] === 80 && bytes[2] === 68 && bytes[3] === 70) {
    return "application/pdf";
  }
  if (bytes[0] === 80 && bytes[1] === 75 && bytes[2] === 3 && bytes[3] === 4) {
    return "application/zip";
  }
  return void 0;
}
async function extractPdfText(bytes) {
  const pdf = await getDocumentProxy(bytes);
  const { text } = await extractText(pdf);
  return Array.isArray(text) ? text.join("\n") : text;
}
async function extractDocxText(bytes) {
  const zip = await JSZip.loadAsync(bytes);
  const documentXml = await zip.file("word/document.xml")?.async("string");
  if (!documentXml) return void 0;
  return documentXml.replace(/<w:p[^>]*>/g, "\n").replace(/<[^>]+>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&apos;/g, "'").replace(/\n{3,}/g, "\n\n").trim();
}
async function listInboxes(client, args) {
  return client.inboxes.list(args);
}
async function getInbox(client, args) {
  const { inboxId, ...options } = args;
  return client.inboxes.get(inboxId, options);
}
async function createInbox(client, args) {
  return client.inboxes.create(args);
}
async function deleteInbox(client, args) {
  const { inboxId } = args;
  return client.inboxes.delete(inboxId);
}
async function listThreads(client, args) {
  const { inboxId, ...options } = args;
  return client.inboxes.threads.list(inboxId, options);
}
async function getThread(client, args) {
  const { inboxId, threadId, ...options } = args;
  return client.inboxes.threads.get(inboxId, threadId, options);
}
async function getAttachment(client, args) {
  const { threadId, attachmentId } = args;
  const response = await client.threads.getAttachment(threadId, attachmentId);
  const arrayBuffer = await response.arrayBuffer();
  const fileBytes = new Uint8Array(arrayBuffer);
  const detectedType = detectFileType(fileBytes);
  let text = void 0;
  let fileType = detectedType;
  if (detectedType === "application/pdf") {
    text = await extractPdfText(fileBytes);
  } else if (detectedType === "application/zip") {
    text = await extractDocxText(fileBytes);
    if (text) {
      fileType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    } else {
      return { error: "Unsupported file type: ZIP archive (not a DOCX)", fileType };
    }
  } else {
    return { error: `Unsupported file type: ${detectedType || "unknown"}`, fileType };
  }
  return { text, fileType };
}
async function sendMessage(client, args) {
  const { inboxId, ...options } = args;
  return client.inboxes.messages.send(inboxId, options);
}
async function replyToMessage(client, args) {
  const { inboxId, messageId, ...options } = args;
  return client.inboxes.messages.reply(inboxId, messageId, options);
}
async function updateMessage(client, args) {
  const { inboxId, messageId, ...options } = args;
  return client.inboxes.messages.update(inboxId, messageId, options);
}

// src/tools.ts
var tools = [
  {
    name: "list_inboxes",
    description: "List inboxes",
    paramsSchema: ListItemsParams,
    func: listInboxes,
    annotations: {
      readOnlyHint: true,
      openWorldHint: false
    }
  },
  {
    name: "get_inbox",
    description: "Get inbox",
    paramsSchema: GetInboxParams,
    func: getInbox,
    annotations: {
      readOnlyHint: true,
      openWorldHint: false
    }
  },
  {
    name: "create_inbox",
    description: "Create inbox",
    paramsSchema: CreateInboxParams,
    func: createInbox,
    annotations: {
      readOnlyHint: false,
      destructiveHint: false,
      idempotentHint: false,
      openWorldHint: false
    }
  },
  {
    name: "delete_inbox",
    description: "Delete inbox",
    paramsSchema: GetInboxParams,
    func: deleteInbox,
    annotations: {
      readOnlyHint: false,
      destructiveHint: true,
      idempotentHint: true,
      openWorldHint: false
    }
  },
  {
    name: "list_threads",
    description: "List threads in inbox",
    paramsSchema: ListInboxItemsParams,
    func: listThreads,
    annotations: {
      readOnlyHint: true,
      openWorldHint: true
    }
  },
  {
    name: "get_thread",
    description: "Get thread",
    paramsSchema: GetThreadParams,
    func: getThread,
    annotations: {
      readOnlyHint: true,
      openWorldHint: true
    }
  },
  {
    name: "get_attachment",
    description: "Get attachment",
    paramsSchema: GetAttachmentParams,
    func: getAttachment,
    annotations: {
      readOnlyHint: true,
      openWorldHint: true
    }
  },
  {
    name: "send_message",
    description: "Send message",
    paramsSchema: SendMessageParams,
    func: sendMessage,
    annotations: {
      readOnlyHint: false,
      destructiveHint: false,
      idempotentHint: false,
      openWorldHint: true
    }
  },
  {
    name: "reply_to_message",
    description: "Reply to message",
    paramsSchema: ReplyToMessageParams,
    func: replyToMessage,
    annotations: {
      readOnlyHint: false,
      destructiveHint: false,
      idempotentHint: false,
      openWorldHint: true
    }
  },
  {
    name: "update_message",
    description: "Update message",
    paramsSchema: UpdateMessageParams,
    func: updateMessage,
    annotations: {
      readOnlyHint: false,
      destructiveHint: false,
      idempotentHint: true,
      openWorldHint: false
    }
  }
];

// src/toolkit.ts
var BaseToolkit = class {
  client;
  tools = {};
  constructor(client) {
    this.client = client ?? new AgentMailClient();
    this.tools = tools.reduce(
      (acc, tool) => {
        acc[tool.name] = this.buildTool(tool);
        return acc;
      },
      {}
    );
  }
};
var ListToolkit = class extends BaseToolkit {
  getTools(names) {
    if (!names) return Object.values(this.tools);
    return names.reduce((acc, name) => {
      if (name in this.tools) acc.push(this.tools[name]);
      return acc;
    }, []);
  }
};
var MapToolkit = class extends BaseToolkit {
  getTools(names) {
    if (!names) return this.tools;
    return names.reduce(
      (acc, name) => {
        if (name in this.tools) acc[name] = this.tools[name];
        return acc;
      },
      {}
    );
  }
};

export {
  ListToolkit,
  MapToolkit
};
//# sourceMappingURL=chunk-FBC74QBQ.js.map