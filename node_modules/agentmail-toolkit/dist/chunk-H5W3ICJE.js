// src/toolkit.ts
import { AgentMailClient } from "agentmail";

// src/schemas.ts
import { z } from "zod";
var InboxIdSchema = z.string().describe("ID of inbox");
var ThreadIdSchema = z.string().describe("ID of thread");
var MessageIdSchema = z.string().describe("ID of message");
var AttachmentIdSchema = z.string().describe("ID of attachment");
var ListItemsParams = z.object({
  limit: z.number().optional().default(10).describe("Max number of items to return"),
  pageToken: z.string().optional().describe("Page token for pagination")
});
var GetInboxParams = z.object({
  inboxId: InboxIdSchema
});
var CreateInboxParams = z.object({
  username: z.string().optional().describe("Username"),
  domain: z.string().optional().describe("Domain"),
  displayName: z.string().optional().describe("Display name")
});
var ListInboxItemsParams = ListItemsParams.extend({
  inboxId: InboxIdSchema,
  labels: z.array(z.string()).optional().describe("Labels to filter items by"),
  before: z.string().pipe(z.coerce.date()).optional().describe("Filter items before datetime"),
  after: z.string().pipe(z.coerce.date()).optional().describe("Filter items after datetime")
});
var GetThreadParams = z.object({
  inboxId: InboxIdSchema,
  threadId: ThreadIdSchema
});
var GetAttachmentParams = z.object({
  inboxId: InboxIdSchema,
  threadId: ThreadIdSchema,
  attachmentId: AttachmentIdSchema
});
var BaseMessageParams = z.object({
  inboxId: InboxIdSchema,
  text: z.string().optional().describe("Plain text body"),
  html: z.string().optional().describe("HTML body"),
  labels: z.array(z.string()).optional().describe("Labels")
});
var SendMessageParams = BaseMessageParams.extend({
  to: z.array(z.string()).describe("Recipients"),
  cc: z.array(z.string()).optional().describe("CC recipients"),
  bcc: z.array(z.string()).optional().describe("BCC recipients"),
  subject: z.string().optional().describe("Subject")
});
var ReplyToMessageParams = BaseMessageParams.extend({
  messageId: MessageIdSchema,
  replyAll: z.boolean().optional().describe("Reply to all recipients")
});
var UpdateMessageParams = z.object({
  inboxId: InboxIdSchema,
  messageId: MessageIdSchema,
  addLabels: z.array(z.string()).optional().describe("Labels to add"),
  removeLabels: z.array(z.string()).optional().describe("Labels to remove")
});

// src/functions.ts
import { CanvasFactory } from "pdf-parse/worker";
import { PDFParse } from "pdf-parse";
import mammoth from "mammoth";
import { fileTypeFromBuffer } from "file-type";
async function listInboxes(client, args) {
  return client.inboxes.list(args);
}
async function getInbox(client, args) {
  const { inboxId, ...options } = args;
  return client.inboxes.get(inboxId, options);
}
async function createInbox(client, args) {
  return client.inboxes.create(args);
}
async function deleteInbox(client, args) {
  const { inboxId } = args;
  return client.inboxes.delete(inboxId);
}
async function listThreads(client, args) {
  const { inboxId, ...options } = args;
  return client.inboxes.threads.list(inboxId, options);
}
async function getThread(client, args) {
  const { inboxId, threadId, ...options } = args;
  return client.inboxes.threads.get(inboxId, threadId, options);
}
async function getAttachment(client, args) {
  const { threadId, attachmentId } = args;
  const response = await client.threads.getAttachment(threadId, attachmentId);
  const fileBytes = Buffer.from(await response.arrayBuffer());
  const fileKind = await fileTypeFromBuffer(fileBytes);
  const fileType = fileKind?.mime;
  let text = void 0;
  if (fileType === "application/pdf") {
    const parser = new PDFParse({ data: fileBytes, CanvasFactory });
    const pdfData = await parser.getText();
    text = pdfData.text;
  } else if (fileType === "application/vnd.openxmlformats-officedocument.wordprocessingml.document") {
    const result = await mammoth.extractRawText({ buffer: fileBytes });
    text = result.value;
  } else {
    return { error: `Unsupported file type: ${fileType || "unknown"}`, fileType };
  }
  return { text, fileType };
}
async function sendMessage(client, args) {
  const { inboxId, ...options } = args;
  return client.inboxes.messages.send(inboxId, options);
}
async function replyToMessage(client, args) {
  const { inboxId, messageId, ...options } = args;
  return client.inboxes.messages.reply(inboxId, messageId, options);
}
async function updateMessage(client, args) {
  const { inboxId, messageId, ...options } = args;
  return client.inboxes.messages.update(inboxId, messageId, options);
}

// src/tools.ts
var tools = [
  {
    name: "list_inboxes",
    description: "List inboxes",
    paramsSchema: ListItemsParams,
    func: listInboxes
  },
  {
    name: "get_inbox",
    description: "Get inbox",
    paramsSchema: GetInboxParams,
    func: getInbox
  },
  {
    name: "create_inbox",
    description: "Create inbox",
    paramsSchema: CreateInboxParams,
    func: createInbox
  },
  {
    name: "delete_inbox",
    description: "Delete inbox",
    paramsSchema: GetInboxParams,
    func: deleteInbox
  },
  {
    name: "list_threads",
    description: "List threads in inbox",
    paramsSchema: ListInboxItemsParams,
    func: listThreads
  },
  {
    name: "get_thread",
    description: "Get thread",
    paramsSchema: GetThreadParams,
    func: getThread
  },
  {
    name: "get_attachment",
    description: "Get attachment",
    paramsSchema: GetAttachmentParams,
    func: getAttachment
  },
  {
    name: "send_message",
    description: "Send message",
    paramsSchema: SendMessageParams,
    func: sendMessage
  },
  {
    name: "reply_to_message",
    description: "Reply to message",
    paramsSchema: ReplyToMessageParams,
    func: replyToMessage
  },
  {
    name: "update_message",
    description: "Update message",
    paramsSchema: UpdateMessageParams,
    func: updateMessage
  }
];

// src/toolkit.ts
var BaseToolkit = class {
  client;
  tools = {};
  constructor(client) {
    this.client = client ?? new AgentMailClient();
    this.tools = tools.reduce(
      (acc, tool) => {
        acc[tool.name] = this.buildTool(tool);
        return acc;
      },
      {}
    );
  }
};
var ListToolkit = class extends BaseToolkit {
  getTools(names) {
    if (!names) return Object.values(this.tools);
    return names.reduce((acc, name) => {
      if (name in this.tools) acc.push(this.tools[name]);
      return acc;
    }, []);
  }
};
var MapToolkit = class extends BaseToolkit {
  getTools(names) {
    if (!names) return this.tools;
    return names.reduce(
      (acc, name) => {
        if (name in this.tools) acc[name] = this.tools[name];
        return acc;
      },
      {}
    );
  }
};

export {
  ListToolkit,
  MapToolkit
};
//# sourceMappingURL=chunk-H5W3ICJE.js.map