"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/ai-sdk.ts
var ai_sdk_exports = {};
__export(ai_sdk_exports, {
  AgentMailToolkit: () => AgentMailToolkit
});
module.exports = __toCommonJS(ai_sdk_exports);

// src/toolkit.ts
var import_agentmail = require("agentmail");

// src/schemas.ts
var import_zod = require("zod");
var InboxIdSchema = import_zod.z.string().describe("ID of inbox");
var ThreadIdSchema = import_zod.z.string().describe("ID of thread");
var MessageIdSchema = import_zod.z.string().describe("ID of message");
var AttachmentIdSchema = import_zod.z.string().describe("ID of attachment");
var ListItemsParams = import_zod.z.object({
  limit: import_zod.z.number().optional().default(10).describe("Max number of items to return"),
  pageToken: import_zod.z.string().optional().describe("Page token for pagination")
});
var GetInboxParams = import_zod.z.object({
  inboxId: InboxIdSchema
});
var CreateInboxParams = import_zod.z.object({
  username: import_zod.z.string().optional().describe("Username"),
  domain: import_zod.z.string().optional().describe("Domain"),
  displayName: import_zod.z.string().optional().describe("Display name")
});
var ListInboxItemsParams = ListItemsParams.extend({
  inboxId: InboxIdSchema,
  labels: import_zod.z.array(import_zod.z.string()).optional().describe("Labels to filter items by"),
  before: import_zod.z.string().pipe(import_zod.z.coerce.date()).optional().describe("Filter items before datetime"),
  after: import_zod.z.string().pipe(import_zod.z.coerce.date()).optional().describe("Filter items after datetime")
});
var GetThreadParams = import_zod.z.object({
  inboxId: InboxIdSchema,
  threadId: ThreadIdSchema
});
var GetAttachmentParams = import_zod.z.object({
  inboxId: InboxIdSchema,
  threadId: ThreadIdSchema,
  attachmentId: AttachmentIdSchema
});
var AttachmentSchema = import_zod.z.object({
  filename: import_zod.z.string().optional().describe("Filename"),
  content_id: import_zod.z.string().optional().describe("Content ID for inline attachments"),
  content: import_zod.z.base64().optional().describe("Base64 encoded content"),
  url: import_zod.z.url().optional().describe("URL")
});
var BaseMessageParams = import_zod.z.object({
  inboxId: InboxIdSchema,
  text: import_zod.z.string().optional().describe("Plain text body"),
  html: import_zod.z.string().optional().describe("HTML body"),
  labels: import_zod.z.array(import_zod.z.string()).optional().describe("Labels"),
  attachments: import_zod.z.array(AttachmentSchema).optional().describe("Attachments")
});
var SendMessageParams = BaseMessageParams.extend({
  to: import_zod.z.array(import_zod.z.string()).describe("Recipients"),
  cc: import_zod.z.array(import_zod.z.string()).optional().describe("CC recipients"),
  bcc: import_zod.z.array(import_zod.z.string()).optional().describe("BCC recipients"),
  subject: import_zod.z.string().optional().describe("Subject")
});
var ReplyToMessageParams = BaseMessageParams.extend({
  messageId: MessageIdSchema,
  replyAll: import_zod.z.boolean().optional().describe("Reply to all recipients")
});
var ForwardMessageParams = SendMessageParams.extend({
  messageId: MessageIdSchema
});
var UpdateMessageParams = import_zod.z.object({
  inboxId: InboxIdSchema,
  messageId: MessageIdSchema,
  addLabels: import_zod.z.array(import_zod.z.string()).optional().describe("Labels to add"),
  removeLabels: import_zod.z.array(import_zod.z.string()).optional().describe("Labels to remove")
});

// src/util.ts
var import_unpdf = require("unpdf");
var import_jszip = __toESM(require("jszip"), 1);
var safeFunc = async (func, client, args) => {
  try {
    return { isError: false, result: await func(client, args) };
  } catch (error) {
    if (error instanceof Error) return { isError: true, result: error.message };
    else return { isError: true, result: "Unknown error" };
  }
};
function detectFileType(bytes) {
  if (bytes[0] === 37 && bytes[1] === 80 && bytes[2] === 68 && bytes[3] === 70) {
    return "application/pdf";
  }
  if (bytes[0] === 80 && bytes[1] === 75 && bytes[2] === 3 && bytes[3] === 4) {
    return "application/zip";
  }
  return void 0;
}
async function extractPdfText(bytes) {
  const pdf = await (0, import_unpdf.getDocumentProxy)(bytes);
  const { text } = await (0, import_unpdf.extractText)(pdf);
  return Array.isArray(text) ? text.join("\n") : text;
}
async function extractDocxText(bytes) {
  const zip = await import_jszip.default.loadAsync(bytes);
  const documentXml = await zip.file("word/document.xml")?.async("string");
  if (!documentXml) return void 0;
  return documentXml.replace(/<w:p[^>]*>/g, "\n").replace(/<[^>]+>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&apos;/g, "'").replace(/\n{3,}/g, "\n\n").trim();
}

// src/functions.ts
async function listInboxes(client, args) {
  return client.inboxes.list(args);
}
async function getInbox(client, args) {
  const { inboxId, ...options } = args;
  return client.inboxes.get(inboxId, options);
}
async function createInbox(client, args) {
  return client.inboxes.create(args);
}
async function deleteInbox(client, args) {
  const { inboxId } = args;
  return client.inboxes.delete(inboxId);
}
async function listThreads(client, args) {
  const { inboxId, ...options } = args;
  return client.inboxes.threads.list(inboxId, options);
}
async function getThread(client, args) {
  const { inboxId, threadId, ...options } = args;
  return client.inboxes.threads.get(inboxId, threadId, options);
}
async function getAttachment(client, args) {
  const { threadId, attachmentId } = args;
  const attachment = await client.threads.getAttachment(threadId, attachmentId);
  try {
    const response = await fetch(attachment.downloadUrl);
    const arrayBuffer = await response.arrayBuffer();
    const fileBytes = new Uint8Array(arrayBuffer);
    const detectedType = detectFileType(fileBytes);
    if (detectedType === "application/pdf") {
      return { ...attachment, text: await extractPdfText(fileBytes) };
    } else if (detectedType === "application/zip") {
      return { ...attachment, text: await extractDocxText(fileBytes) };
    }
  } catch {
  }
  return attachment;
}
async function sendMessage(client, args) {
  const { inboxId, ...options } = args;
  return client.inboxes.messages.send(inboxId, options);
}
async function replyToMessage(client, args) {
  const { inboxId, messageId, ...options } = args;
  return client.inboxes.messages.reply(inboxId, messageId, options);
}
async function forwardMessage(client, args) {
  const { inboxId, messageId, ...options } = args;
  return client.inboxes.messages.forward(inboxId, messageId, options);
}
async function updateMessage(client, args) {
  const { inboxId, messageId, ...options } = args;
  return client.inboxes.messages.update(inboxId, messageId, options);
}

// src/tools.ts
var tools = [
  {
    name: "list_inboxes",
    description: "List inboxes",
    paramsSchema: ListItemsParams,
    func: listInboxes,
    annotations: {
      readOnlyHint: true,
      openWorldHint: false
    }
  },
  {
    name: "get_inbox",
    description: "Get inbox",
    paramsSchema: GetInboxParams,
    func: getInbox,
    annotations: {
      readOnlyHint: true,
      openWorldHint: false
    }
  },
  {
    name: "create_inbox",
    description: "Create inbox",
    paramsSchema: CreateInboxParams,
    func: createInbox,
    annotations: {
      readOnlyHint: false,
      destructiveHint: false,
      idempotentHint: false,
      openWorldHint: false
    }
  },
  {
    name: "delete_inbox",
    description: "Delete inbox",
    paramsSchema: GetInboxParams,
    func: deleteInbox,
    annotations: {
      readOnlyHint: false,
      destructiveHint: true,
      idempotentHint: true,
      openWorldHint: false
    }
  },
  {
    name: "list_threads",
    description: "List threads in inbox",
    paramsSchema: ListInboxItemsParams,
    func: listThreads,
    annotations: {
      readOnlyHint: true,
      openWorldHint: true
    }
  },
  {
    name: "get_thread",
    description: "Get thread",
    paramsSchema: GetThreadParams,
    func: getThread,
    annotations: {
      readOnlyHint: true,
      openWorldHint: true
    }
  },
  {
    name: "get_attachment",
    description: "Get attachment",
    paramsSchema: GetAttachmentParams,
    func: getAttachment,
    annotations: {
      readOnlyHint: true,
      openWorldHint: true
    }
  },
  {
    name: "send_message",
    description: "Send message",
    paramsSchema: SendMessageParams,
    func: sendMessage,
    annotations: {
      readOnlyHint: false,
      destructiveHint: false,
      idempotentHint: false,
      openWorldHint: true
    }
  },
  {
    name: "reply_to_message",
    description: "Reply to message",
    paramsSchema: ReplyToMessageParams,
    func: replyToMessage,
    annotations: {
      readOnlyHint: false,
      destructiveHint: false,
      idempotentHint: false,
      openWorldHint: true
    }
  },
  {
    name: "forward_message",
    description: "Forward message",
    paramsSchema: ForwardMessageParams,
    func: forwardMessage,
    annotations: {
      readOnlyHint: false,
      destructiveHint: false,
      idempotentHint: false,
      openWorldHint: true
    }
  },
  {
    name: "update_message",
    description: "Update message",
    paramsSchema: UpdateMessageParams,
    func: updateMessage,
    annotations: {
      readOnlyHint: false,
      destructiveHint: false,
      idempotentHint: true,
      openWorldHint: false
    }
  }
];

// src/toolkit.ts
var BaseToolkit = class {
  client;
  tools = {};
  constructor(client) {
    this.client = client ?? new import_agentmail.AgentMailClient();
    this.tools = tools.reduce(
      (acc, tool) => {
        acc[tool.name] = this.buildTool(tool);
        return acc;
      },
      {}
    );
  }
};
var MapToolkit = class extends BaseToolkit {
  getTools(names) {
    if (!names) return this.tools;
    return names.reduce(
      (acc, name) => {
        if (name in this.tools) acc[name] = this.tools[name];
        return acc;
      },
      {}
    );
  }
};

// src/ai-sdk.ts
var AgentMailToolkit = class extends MapToolkit {
  buildTool(tool) {
    return {
      description: tool.description,
      inputSchema: tool.paramsSchema,
      execute: async (args) => (await safeFunc(tool.func, this.client, args)).result
    };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AgentMailToolkit
});
//# sourceMappingURL=ai-sdk.cjs.map